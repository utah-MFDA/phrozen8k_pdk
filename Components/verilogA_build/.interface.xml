<!--
  File automatically created
  Command used:
  # release: 2.3.7 Feb  6 2024-08:01:28
  admsXml \
   -x \
   -e /usr/local/stow/Xyce/7.8-adms/share/xml/adms.implicit.xml \
   -e /usr/local/stow/Xyce/7.8-adms/share/xml/xyceVersion_nosac.xml \
   -e /usr/local/stow/Xyce/7.8-adms/share/xml/xyceBasicTemplates_nosac.xml \
   -e /usr/local/stow/Xyce/7.8-adms/share/xml/xyceAnalogFunction_nosac.xml \
   -e /usr/local/stow/Xyce/7.8-adms/share/xml/xyceHeaderFile_nosac.xml \
   -e /usr/local/stow/Xyce/7.8-adms/share/xml/xyceImplementationFile_nosac.xml
-->


<?escript name="/usr/local/stow/Xyce/7.8-adms/share/xml/adms.implicit.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
  This file is part of adms - http://sourceforge.net/projects/mot-adms.

  adms is a code generator for the Verilog-AMS language.

  Copyright (C) 2002-2012 Laurent Lemaitre <r29173@users.sourceforge.net>
  Copyright (C) 2015-2016 Guilherme Brondani Torri <guitorri@gmail.com>
                2012 Ryan Fox <ryan.fox@upverter.com>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<!--  Version modified for use with Xyce to add dependency propagation
      for analog function output variables
      To make use of this, use the "-x" flag to admsXml in order to
      disable its use of its own implicit rules, then put a "-e" flag followed
      by this file's name first in your list of admsXml command-line options
      to invoke it explicitly.
-->

<!-- built-in implicit transforms @GIT_VERSION=unknown@ -->
<!-- this file is saved in local working directory, then downloaded prior any -e xml files -->
<!-- unless flag '-x' is specified -->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/adms/admst.xml">

<admst:variable name="globalmodule"/>
<admst:variable name="globalassignment"/>
<admst:variable name="globalcontribution"/>
<admst:variable name="globalexpression"/>
<admst:variable name="globalopdependent" string="no"/>
<admst:variable name="globalpartitionning"/>
<admst:variable name="globaltreenode"/>
<admst:variable name="globalhandleafoutputs" string="no"/>
<admst:variable name="globalaf"/>
<admst:variable name="theDDXProbeToPush"/>
<admst:template match="e:dependency">
  <admst:choose>
    <admst:when test="[datatypename='expression']">
      <admst:variable name="globalexpression" path="."/>
      <admst:apply-templates select="tree" match="e:dependency"/>
      <admst:variable name="globalexpression"/>
      <admst:value-to select="dependency" path="tree/dependency"/>
      <admst:value-to select="dependency[.='constant' and $globalopdependent='yes']" string="noprobe"/>
      <admst:choose>
        <admst:when test="[nilled($globalpartitionning)]">
          <admst:value-to select="variable/usedinevaluate" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_model']">
          <admst:value-to select="variable/usedinmodel" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_instance']">
          <admst:value-to select="variable/usedininstance" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_step']">
          <admst:value-to select="variable/usedininitial_step" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='noise']">
          <admst:value-to select="variable/usedinnoise" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='final_step']">
          <admst:value-to select="variable/usedinfinal" string="yes"/>
        </admst:when>
      </admst:choose>
      <admst:reverse select="function"/>
      <admst:value-to select="math/value" path="tree/math/value"/>
    </admst:when>
    <admst:when test="[datatypename='probe']">
      <admst:value-to select="dependency" string="linear"/>
      <admst:push into="$globalexpression/probe" select="." onduplicate="ignore"/>
      <admst:if test="[$globalhandleafoutputs='yes']">
        <admst:push into="$globalaf/@probe" select="." onduplicate="ignore"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='array']">
      <admst:apply-templates select="variable" match="e:dependency"/>
      <admst:value-to select="dependency" path="variable/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='variable']">
      <admst:push into="$globalexpression/probe" select="probe" onduplicate="ignore"/>
      <admst:push into="$globalexpression/variable" select="." onduplicate="ignore"/>
      <admst:push into="$globaltreenode/@variable" select="." onduplicate="ignore"/>
      <admst:value-to select="dependency" path="prototype/dependency"/>

      <admst:if test="[$globalhandleafoutputs='yes']">
        <admst:push into="$globalaf/@probe" select="probe" onduplicate="ignore"/>
        <admst:push into="$globalaf/@variable" select="." onduplicate="ignore"/>
      </admst:if>

    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="e:dependency"/>
      <admst:value-to select="dependency" path="arg1/dependency"/>
      <admst:value-to select="[name='minus']/math/value" string="-%(arg1/math/value)"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="e:dependency"/>
      <!--
        +:             -:            *:            /:                                                          
          c  np l  nl    c  np l  nl   c  np l  nl   c  np nl nl                                                          
          np np l  nl    np np l  nl   np np l  nl   np np nl nl                                                          
          l  l  l  nl    l  l  l  nl   l  l  nl nl   l  l  nl nl                                                          
          nl nl nl nl    nl nl nl nl   nl nl nl nl   nl nl nl nl                                                          
      -->
      <admst:choose>
        <admst:when test="[arg1/dependency='nonlinear' or arg2/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[name='multtime' and (arg1|arg2)/dependency=('linear'|'linear')]">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[name='multdiv' and arg2/dependency='linear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[arg1/dependency='linear' or arg2/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[arg1/dependency='noprobe' or arg2/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="e:dependency"/>
      <!--
          ?: - arg1=c -  - arg1!=c -                                                            
             c  np l  nl np np l  nl                                                             
             np np l  nl np np l  nl                                                             
             l  l  l  nl l  l  l  nl                                                             
             nl nl nl nl nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[arg2/dependency='nonlinear' or arg3/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[arg2/dependency='linear' or arg3/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[arg1/dependency!='constant' or arg2/dependency='noprobe' or arg3/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:choose>
        <admst:when test="[name='ddx' or name='\$ddx' or name='\$derivate']">
          <admst:value-to select="$globalassignment/lhs/derivate" string="yes"/>
          <admst:apply-templates select="arguments[1]" match="e:dependency"/>
          <!-- recursively push a ddxprobe into argument 1-->
          <!-- call with argument 1 in select, set $theDDXProbeToPush to -->
          <!-- the PATH to thing to push in -->
          <admst:template match="pushDDXintoArg">
            <admst:choose>
              <admst:when test="[adms/datatypename='variable']">
                <admst:push into="ddxprobe" select="$theDDXProbeToPush"/>
              </admst:when>
              <admst:when test="[adms/datatypename='expression']">
                <admst:push into="variable/ddxprobe" select="$theDDXProbeToPush"/>
              </admst:when>
              <admst:when test="[adms/datatypename='mapply_binary']">
                <admst:apply-templates match="pushDDXintoArg" select="arg1"/>
                <admst:apply-templates match="pushDDXintoArg" select="arg2"/>
              </admst:when>
              <admst:when test="[adms/datatypename='mapply_ternary']">
                <admst:apply-templates match="pushDDXintoArg" select="arg2"/>
                <admst:apply-templates match="pushDDXintoArg" select="arg3"/>
              </admst:when>
              <admst:when test="[adms/datatypename='constant' or adms/datatypename='number']">
              </admst:when>
              <admst:otherwise>
                <admst:fatal format="Xyce/ADMS got a ddx expression %(.) of type %(adms/datatypename) and cannot proceed.  We currently support only mapply_binary, mapply_ternary and variable.\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:template>
          <!-- <admst:push into="$globalexpression/variable/ddxprobe" select="arguments[2]" onduplicate="ignore"/> -->
          <admst:variable name="theDDXProbeToPush" select="%(arguments[2])"/>
          <admst:apply-templates match="pushDDXintoArg" select="arguments[1]"/>
          <admst:choose>
            <admst:when test="arguments[1]/dependency[.='constant' or .='noprobe']">
              <admst:value-to select="dependency" path="arguments[1]/dependency"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='\$port_connected']">
          <admst:value-to select="dependency" string="constant"/>
          <admst:assert test="[arguments[1]/datatypename='node']" format="Argument %(arguments[1]) to port_connected is not a node\n"/>
          <admst:variable name="nodename" value="%(arguments[1]/name)"/>
          <admst:push into="arguments[1]/module/@optnodes" select="arguments[1]" onduplicate="ignore"/>
          <admst:value-to select="arguments[1]/module/node[name=$nodename]/#optional" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <!-- track dependencies of analog function output arguments -->
          <admst:variable name="function" select="%(.)"/>
          <admst:if test="[definition/datatypename='analogfunction']">
            <admst:if test="[exists(definition/variable[(output='yes') and (name!=$function/name)])]">
              <admst:variable name="globalhandleafoutputs" string="yes"/>
              <admst:variable name="globalaf" path="."/>
            </admst:if>
          </admst:if>
          <!-- process arguments normally -->
          <admst:apply-templates select="arguments" match="e:dependency"/>
          <!-- propagate dependencies into output arguments -->
          <admst:if test="[$globalhandleafoutputs='yes']">
            <admst:variable name="globalhandleafoutputs" string="no"/>
            <admst:variable name="globalaf"/>
            <admst:for-each select="definition/variable">
              <admst:if test="[(output='yes') and (name!=$function/name)]">
                <admst:variable name="position" select="%(position(.)-1)"/>
                <admst:fatal test="[$function/arguments[position(.)=$position]/datatypename!='variable']"
                             format="%(function/name) output arg $position is %(.), must be a variable\n"/>
                <admst:push into="$function/arguments[position(.)=$position]/probe" select="$function/@probe" onduplicate="ignore"/>
                <admst:push into="$function/arguments[position(.)=$position]/variable" select="$function/@variable" onduplicate="ignore"/>
                <admst:choose>
                  <admst:when test="$function/arguments/dependency[.='linear' or .='nonlinear']">
                    <admst:value-to select="$function/arguments[position(.)=$position]/dependency" string="nonlinear"/>
                    <admst:value-to select="$function/arguments[position(.)=$position]/prototype/dependency" string="nonlinear"/>
                  </admst:when>
                  <admst:when test="$function/arguments/dependency[.='noprobe']">
                    <admst:value-to select="$function/arguments[position(.)=$position]/dependency" string="noprobe"/>
                    <admst:value-to select="$function/arguments[position(.)=$position]/prototype/dependency" string="noprobe"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:value-to select="$function/arguments[position(.)=$position]/dependency" string="constant"/>
                    <admst:value-to select="$function/arguments[position(.)=$position]/prototype/dependency" string="constant"/>
                  </admst:otherwise>
                </admst:choose>
                <admst:choose>
                  <admst:when test="[$globalpartitionning='initial_model']">
                    <admst:value-to select="$function/arguments[position(.)=$position]/setinmodel" string="yes"/>
                  </admst:when>
                  <admst:when test="[$globalpartitionning='initial_instance']">
                    <admst:value-to select="$function/arguments[position(.)=$position]/setininstance" string="yes"/>
                  </admst:when>
                  <admst:when test="[$globalpartitionning='initial_step']">
                    <admst:value-to select="$function/arguments[position(.)=$position]/setininitial_step" string="yes"/>
                  </admst:when>
                  <admst:when test="[$globalpartitionning='noise']">
                    <admst:value-to select="$function/arguments[position(.)=$position]/setinnoise" string="yes"/>
                  </admst:when>
                  <admst:when test="[$globalpartitionning='final_step']">
                    <admst:value-to select="$function/arguments[position(.)=$position]/setinfinal" string="yes"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:value-to select="$function/arguments[position(.)=$position]/setinevaluate" string="yes"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:if>
            </admst:for-each>
            <admst:value-to select="$function/@probe"/>
            <admst:value-to select="$function/@variable"/>
          </admst:if>
          <admst:choose>
            <admst:when test="[(name='ddt' or name='\$ddt')or(name='idt' or name='\$idt')]">
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:when>
            <admst:when test="arguments/dependency[.='linear' or .='nonlinear']">
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:when>
            <admst:when test="arguments/dependency[.='noprobe']">
              <admst:value-to select="dependency" string="noprobe"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="dependency" string="constant"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:value-to test="dependency[.='linear' or .='nonlinear']" select="$globalexpression/hasVoltageDependentFunction" string="yes"/>
      <admst:value-to select="subexpression/expression" path="$globalexpression"/>
      <!-- fixme: these flags should be set after all contribs are transformed to ...<+F(...); canonical form -->
      <admst:value-to test="[name='ddt']" select="$globalcontribution/#fixmedynamic" path="1"/>
      <admst:value-to test="[name='white_noise']" select="$globalcontribution/#fixmewhitenoise" path="1"/>
      <admst:value-to test="[name='flicker_noise']" select="$globalcontribution/#fixmeflickernoise" path="1"/>
      <admst:value-to test="[name='\$temperature']" select="$globalassignment/lhs/TemperatureDependent" string="yes"/>
      <admst:choose>
        <admst:when
          test="[
          name='\$abstime' or
          name='\$realtime' or
          name='\$temperature' or
          name='\$vt' or
          name='idt' or
          name='ddt' or
          name='\$param_given' or
          name='\$port_connected' or
          name='\$given' or
          name='ddx' or
          name='flicker_noise' or
          name='white_noise'
          ]">
        </admst:when>

        <!-- Table 4-14 - Standard Functions -->
        <!-- Table 4-15 - Trigonometric and Hyperbolic Functions-->
        <admst:when
          test="[name='analysis' or name='\$analysis' or name='\$simparam' or name='simparam' or
          name='\$shrinka' or name='\$shrinkl' or name='\$limexp' or name='limexp' or name='\$limit' or
          name='ln' or
          name='log' or
          name='exp' or
          name='sqrt' or
          name='min' or
          name='max' or
          name='abs' or
          name='pow' or
          name='floor' or
          name='ceil' or
          name='sin' or
          name='cos' or
          name='tan' or
          name='asin' or
          name='acos' or
          name='atan' or
          name='atan2' or
          name='hypot' or
          name='sinh' or
          name='cosh' or
          name='tanh' or
          name='asinh' or
          name='acosh' or
          name='atanh'
          ]">
          <admst:push into="$globalexpression/function" select="."/>
          <admst:value-to select="class" string="builtin"/>
        </admst:when>
        <admst:when test="[name='transition']">
          <admst:push into="$globalexpression/function" select="."/>
        </admst:when>
        <admst:otherwise>
          <admst:assert test="[exists(definition)]" format="%(lexval/(f|':'|l|':'|c)): analog function '%(name)' is undefined\n"/>
          <admst:push into="$globalexpression/function" select="."/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:value-to select="math/value" path="value"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:warning format="%(lexval/(f|':'|l|':'|c)): non-standard scale factor: %(scalingunit)\n"/>
          <admst:value-to select="math/value" string="%(value)e+18"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:warning format="%(lexval/(f|':'|l|':'|c)): non-standard scale factor: %(scalingunit)\n"/>
          <admst:value-to select="math/value" string="%(value)e+15"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:value-to select="math/value" string="%(value)e+12"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:value-to select="math/value" string="%(value)e+9"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:value-to select="math/value" string="%(value)e+6"/>
        </admst:when>
        <admst:when test="[scalingunit='K']">
          <admst:value-to select="math/value" string="%(value)e+3"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:value-to select="math/value" string="%(value)e+3"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:value-to select="math/value" string="%(value)e+2"/>
          <admst:warning format="%(lexval/(f|':'|l|':'|c)): non-standard scale factor: %(scalingunit)\n"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:value-to select="math/value" string="%(value)e+1"/>
          <admst:warning format="%(lexval/(f|':'|l|':'|c)): non-standard scale factor: %(scalingunit)\n"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:warning format="%(lexval/(f|':'|l|':'|c)): non-standard scale factor: %(scalingunit)\n"/>
          <admst:value-to select="math/value" string="%(value)e-1"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:value-to select="math/value" string="%(value)e-2"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:value-to select="math/value" string="%(value)e-3"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:value-to select="math/value" string="%(value)e-6"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:value-to select="math/value" string="%(value)e-9"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:warning format="%(lexval/(f|':'|l|':'|c)): non-standard scale factor: %(scalingunit)\n"/>
          <admst:value-to select="math/value" string="%(value)e-10"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:value-to select="math/value" string="%(value)e-12"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:value-to select="math/value" string="%(value)e-15"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:value-to select="math/value" string="%(value)e-18"/>
        </admst:when>
        <admst:otherwise>
          <admst:error format="%(lexval/(f|':'|l|':'|c)): unit not supported: %(scalingunit)\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='string']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="dependency">
  <admst:choose>
    <admst:when test="[datatypename='callfunction']">
      <admst:apply-templates select="function/arguments" match="e:dependency"/>
      <admst:value-to select="dependency" path="function/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='whileloop']">
      <!--
        w, logic(D,while.d)            , d=wb.d                                               
              c                 !c                           
           c  wb,w,!c?(D,wb,!D) D,wb,!D                                                                                        
           !c wb                wb                                                                                             
      -->

      <!-- This template, like forloop, had broken conditions that can 
           possibly cause dependency to be called twice on the block with
           the consequence of reversing the block twice and polluting
           the datastructure with duplicates.  Let's try to make it less
           dangerous -->

      <admst:apply-templates select="while" match="e:dependency"/>
      <admst:choose>
        <admst:when test="[$globalopdependent='no']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="whileblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
          <admst:apply-templates select="while[dependency='constant']" match="e:dependency"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="whileblock" match="dependency"/>
        </admst:otherwise>
      </admst:choose>

      <!-- Original -->
      <!--
      <admst:apply-templates select="while" match="e:dependency"/>
      <admst:apply-templates select="[$globalopdependent='yes' or while/dependency='constant']/whileblock" match="dependency"/>
      <admst:if test="[$globalopdependent='no']">
        <admst:apply-templates select="while[dependency='constant']" match="e:dependency"/>
        <admst:if test="[while/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="whileblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:if>
      </admst:if>
      -->
      <!--
          wl:  w=c          w!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[whileblock/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[whileblock/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[while/dependency!='constant' or whileblock/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='forloop']">
      <!-- Xyce:  The original code for this had broken conditionals that
           could, in some cases, allow dependency to be called twice on
           the "forblock".  This is catastrophic and should not happen.
           Let's try to accomplish the dependency scanning without that
           logical hole -->
      <admst:apply-templates select="initial|update" match="dependency"/>
      <admst:apply-templates select="condition" match="e:dependency"/>
      <admst:choose>
        <admst:when test="[$globalopdependent='no']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="forblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
          <admst:apply-templates select="(initial|update)/[dependency='constant']" match="dependency"/>
          <admst:apply-templates select="condition[dependency='constant']" match="e:dependency"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="forblock" match="dependency"/>
          <admst:apply-templates select="(initial|update)/[dependency='constant']" match="dependency"/>
          <admst:apply-templates select="condition[dependency='constant']" match="e:dependency"/>
        </admst:otherwise>
      </admst:choose>
      <!-- Original code: -->
      <!--
      <admst:apply-templates select="initial|update" match="dependency"/>
      <admst:apply-templates select="condition" match="e:dependency"/>
      <admst:apply-templates select="[$globalopdependent='yes' or nilled((initial|condition|update)/[dependency!='constant'])]/forblock" match="dependency"/>
      <admst:if test="[$globalopdependent='no']">
        <admst:apply-templates select="(initial|update)/[dependency='constant']" match="dependency"/>
        <admst:apply-templates select="condition[dependency='constant']" match="e:dependency"/>
        <admst:if test="[condition/dependency!='constant' or initial/dependency!='constant' or update/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="forblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:if>
      </admst:if>
      -->
      <!--
          fl:  f=c          f!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[forblock/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[forblock/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[(condition!='constant' or initial!='constant' or update!='constant') or forblock/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='case']">
      <admst:variable name="globaltreenode" path="case"/>
      <admst:apply-templates select="case" match="e:dependency"/>
      <admst:variable name="globaltreenode"/>
      <admst:for-each select="caseitem">
        <admst:for-each select="condition">
          <admst:variable name="globaltreenode" path="."/>
          <admst:apply-templates select="." match="e:dependency"/>
          <admst:variable name="globaltreenode"/>
        </admst:for-each>
        <admst:apply-templates select="code" match="dependency"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:push into="$globalmodule/conditional" select="."/>
      <admst:apply-templates select="if" match="e:dependency"/>
      <admst:choose>
        <admst:when test="[$globalopdependent='no' and if/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="then|else" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="then|else" match="dependency"/>
        </admst:otherwise>
      </admst:choose>
      <!--
          cd:  i=c          i!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[then/dependency='nonlinear' or else/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[then/dependency='linear' or else/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[if/dependency!='constant' or then/dependency='noprobe' or else/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='contribution']">
      <admst:variable name="globalcontribution" path="."/>
      <admst:apply-templates select="rhs" match="e:dependency"/>
      <admst:variable name="globalcontribution"/>
      <admst:push into="lhs/probe" select="rhs/probe" onduplicate="ignore"/>
      <admst:value-to select="dependency" string="nonlinear"/>
    </admst:when>
    <admst:when test="[datatypename='assignment']">
      <admst:choose>
        <admst:when test="[lhs/datatypename='array']">
          <admst:variable name="lhs" path="lhs/variable"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="lhs" path="lhs"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[$globalpartitionning='initial_model']">
          <admst:value-to select="$lhs/setinmodel" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_instance']">
          <admst:value-to select="$lhs/setininstance" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_step']">
          <admst:value-to select="$lhs/setininitial_step" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='noise']">
          <admst:value-to select="$lhs/setinnoise" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='final_step']">
          <admst:value-to select="$lhs/setinfinal" string="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="$lhs/setinevaluate" string="yes"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="globalassignment" path="."/>
      <admst:apply-templates select="rhs" match="e:dependency"/>
      <admst:variable name="globalassignment"/>
      <admst:push into="$lhs/variable" select="rhs/variable" onduplicate="ignore"/>
      <admst:value-to test="rhs/variable[TemperatureDependent='yes']" select="$lhs/TemperatureDependent" string="yes"/>
      <!--
        d=rhs.d,d=(c and D)?np
        l(l,r,$globalopdependent)
        $globalopdependent='no'  $globalopdependent='yes'
        c  np l  nl               np np l  nl
        np np l  nl               np np l  nl
        l  l  l  nl               l  l  l  nl
        nl nl nl nl               nl nl nl nl
      -->
      <admst:value-to select="dependency" path="rhs/dependency"/>
      <admst:choose>
        <admst:when test="[$lhs/prototype/dependency='nonlinear' or rhs/dependency='nonlinear']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[$lhs/prototype/dependency='linear' or rhs/dependency='linear']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="linear"/>
        </admst:when>
        <admst:when test="[$globalopdependent='yes' or $lhs/prototype/dependency='noprobe' or rhs/dependency='noprobe']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>      
      <admst:push into="$lhs/probe" select="rhs/probe" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:reverse select="item|variable"/>
      <admst:variable name="forcepartitionning" string="yes"/>
      <admst:choose>
        <admst:when test="[name='initial_model']">
          <admst:variable name="globalpartitionning" string="initial_model"/>
        </admst:when>
        <admst:when test="[name='initial_instance']">
          <admst:variable name="globalpartitionning" string="initial_instance"/>
        </admst:when>
        <admst:when test="[name='initial_step']">
          <admst:variable name="globalpartitionning" string="initial_step"/>
        </admst:when>
        <admst:when test="[name='noise']">
          <admst:variable name="globalpartitionning" string="noise"/>
        </admst:when>
        <admst:when test="[name='final_step']">
          <admst:variable name="globalpartitionning" string="final_step"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="forcepartitionning" string="no"/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="item" match="dependency"/>
      <admst:variable test="[$forcepartitionning='yes']" name="globalpartitionning"/>
      <admst:choose>
        <admst:when test="item[dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="item[dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="item[dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="adms.implicit.xml.module">
  <admst:variable name="globalmodule" path="."/>
  <admst:reverse select="analogfunction|analogfunction/variable|node|variable
                         |instance|instance/terminal|contribution|forloop|whileloop|case|callfunction"/>
  <admst:value-to select="node[location='ground']/grounded" string="yes"/>
  <admst:for-each select="branch">
    <admst:value-to select="discipline" path="pnode/discipline"/>
    <admst:value-to select="[nnode/grounded='yes']/grounded" string="yes"/>
    <!-- FIXME: check that pnode/nnode have same discipline -->
  </admst:for-each>
  <admst:for-each select="source|probe">
    <admst:value-to select="discipline" path="branch/discipline"/>
    <admst:value-to select="[branch/grounded='yes']/grounded" string="yes"/>
  </admst:for-each>
  <admst:for-each select="instance">
    <admst:push into="module/instantiator" select=".." onduplicate="ignore"/>
    <admst:assert select="terminal" test="terminal[nodefrommodule/location='external']"
                  format="%(../instantiator).%(nodefrommodule/name): is not terminal\n"/>
    <admst:if test="[count(parameterset)!=0]">
      <admst:assert select="parameterset" test="parameterset[parameter/input='yes']"
                    format="%(../instantiator).%(parameter/name): is not input parameter\n"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="(analogfunction/tree)|(analog/code)" match="dependency"/>
  <admst:for-each select="variable">
    <admst:value-to select="[dependency!='constant']/OPdependent" string="yes"/>
    <admst:value-to select="output" path="input"/>
    <admst:for-each select="attribute">
      <admst:value-to select="[name='type' and value='instance']/../parametertype" string="instance"/>
      <admst:value-to select="[name='ask' and value='yes']/../output" string="yes"/>
      <admst:value-to select="[name='ask' and value='no']/../output" string="no"/>
      <!-- set output flag if desc or units attribute and we are a module-
            scoped variable,  not an input parameter, and have 
            desc or units attribute, per Verilog-A LRM 2.4, section 3.2.1 -->
      <admst:if test="[../input!='yes' and ../module/name=../block/name and name='desc' and value!='']">
          <admst:value-to select="../output" string="yes"/>
      </admst:if>
     <admst:if test="[../input!='yes' and ../module/name=../block/name and name='units' and value!='']">
          <admst:value-to select="../output" string="yes"/>
      </admst:if>
    </admst:for-each>
    <admst:apply-templates select="default" match="e:dependency"/>
    <admst:value-to
       select="default[exists(tree[datatypename='mapply_unary' and name='minus' and arg1/datatypename='number' and arg1/value='1.0'])]/value"
       string="is_neg_one"/>
    <admst:value-to select="default[exists(tree[datatypename='number' and value='0.0'])]/value" string="is_zero"/>
    <admst:value-to select="default[exists(tree[datatypename='number' and value='1.0'])]/value" string="is_one"/>
    <admst:value-to select="scope"
      test="[(input='yes' and parametertype='model') or (input='no' and (setinmodel='yes' or usedinmodel='yes')
        and (setininstance='yes' or setininitial_step='yes' or setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedininstance='yes' or usedininitial_step='yes' or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))]"
      string="global_model"/>
    <admst:value-to select="scope"
      test="[(input='yes' and parametertype='instance') or
      (input='no' and setinmodel='no' and usedinmodel='no' and
        (((setininstance='yes' or usedininstance='yes') and (setininitial_step='yes' or setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedininitial_step='yes' or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setininitial_step='yes' or usedininitial_step='yes') and (setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setinevaluate='yes' or usedinevaluate='yes') and (setinnoise='yes' or setinfinal='yes'
          or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setinnoise='yes' or usedinnoise='yes') and (setinfinal='yes' or usedinfinal='yes' or output='yes'))
        or ((setinfinal='yes' or usedinfinal='yes') and output='yes')
        or (setinmodel='no' and setininstance='no' and setinevaluate='no' and setinnoise='no' and setinfinal='no' and
            usedinmodel='no' and usedininstance='no' and usedinevaluate='no' and usedinnoise='no' and usedinfinal='no' and output='yes')
      ))]"
      string="global_instance"/>
    <admst:value-to select="isstate"
      test="[input='no' and scope='global_instance' and setininitial_step='yes' and (setinevaluate='yes' or usedinevaluate='yes')]"
      string="yes"/>
  </admst:for-each>
  <admst:template match="modify">
    <admst:choose>
      <admst:when test="[datatypename='block']">
        <admst:apply-templates select="reverse(item)" match="modify"/>
        <admst:value-to test="item[#modifys=1]" select="#modifys" path="1"/>
        <admst:value-to test="item[#modifyd=1]" select="#modifyd" path="1"/>
        <admst:value-to test="item[#modifyn=1]" select="#modifyn" path="1"/>
        <admst:value-to test="item[#modifyc=1]" select="#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='conditional']">
        <admst:apply-templates select="else|then" match="modify"/>
        <admst:value-to test="[then/#modifys=1 or else/#modifys=1]" select="#modifys|if/#modifys|if/variable/#modifys" path="1"/>
        <admst:value-to test="[then/#modifyd=1 or else/#modifyd=1]" select="#modifyd|if/#modifyd|if/variable/#modifyd" path="1"/>
        <admst:value-to test="[then/#modifyn=1 or else/#modifyn=1]" select="#modifyn|if/#modifyn|if/variable/#modifyn" path="1"/>
        <admst:value-to test="[then/#modifyc=1 or else/#modifyc=1]" select="#modifyc|if/#modifyc|if/variable/#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='whileloop']">
        <admst:apply-templates select="whileblock" match="modify"/>
        <admst:value-to test="[whileblock/#modifys=1]" select="#modifys|while/#modifys|while/variable/#modifys" path="1"/>
        <admst:value-to test="[whileblock/#modifyd=1]" select="#modifyd|while/#modifyd|while/variable/#modifyd" path="1"/>
        <admst:value-to test="[whileblock/#modifyn=1]" select="#modifyn|while/#modifyn|while/variable/#modifyn" path="1"/>
        <admst:value-to test="[whileblock/#modifyc=1]" select="#modifyc|while/#modifyc|while/variable/#modifyc" path="1"/>
        <admst:apply-templates select="whileblock" match="modify"/>
      </admst:when>
      <admst:when test="[datatypename='forloop']">
        <admst:choose>
          <admst:when test="[update/lhs/datatypename='array']">
            <admst:variable name="lhs" path="update/lhs/variable"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="lhs" path="update/lhs"/>
          </admst:otherwise>
        </admst:choose>
        <admst:apply-templates select="forblock" match="modify"/>
        <admst:value-to test="[forblock/#modifys=1]" select="#modifys|(condition|update)/#modifys|(condition|update/rhs)/($lhs|variable)/#modifys" path="1"/>
        <admst:value-to test="[forblock/#modifyd=1]" select="#modifyd|(condition|update)/#modifyd|(condition|update/rhs)/($lhs|variable)/#modifyd" path="1"/>
        <admst:value-to test="[forblock/#modifyn=1]" select="#modifyn|(condition|update)/#modifyn|(condition|update/rhs)/($lhs|variable)/#modifyn" path="1"/>
        <admst:value-to test="[forblock/#modifyc=1]" select="#modifyc|(condition|update)/#modifyc|(condition|update/rhs)/($lhs|variable)/#modifyc" path="1"/>
        <admst:apply-templates select="forblock" match="modify"/>
      </admst:when>
      <admst:when test="[datatypename='case']">
        <admst:apply-templates select="caseitem/code" match="modify"/>
        <admst:for-each select="caseitem">
          <admst:value-to test="[code/#modifys=1 and defaultcase='no']" select="#modifys|condition/#modifys|condition/@variable/#modifys" path="1"/>
          <admst:value-to test="[code/#modifyd=1 and defaultcase='no']" select="#modifyd|condition/#modifyd|condition/@variable/#modifyd" path="1"/>
          <admst:value-to test="[code/#modifyn=1 and defaultcase='no']" select="#modifyn|condition/#modifyn|condition/@variable/#modifyn" path="1"/>
          <admst:value-to test="[code/#modifyc=1 and defaultcase='no']" select="#modifyc|condition/#modifyc|condition/@variable/#modifyc" path="1"/>
        </admst:for-each>
        <admst:value-to test="caseitem[#modifys=1]" select="#modifys|case/@variable/#modifys" path="1"/>
        <admst:value-to test="caseitem[#modifyd=1]" select="#modifyd|case/@variable/#modifyd" path="1"/>
        <admst:value-to test="caseitem[#modifyn=1]" select="#modifyn|case/@variable/#modifyn" path="1"/>
        <admst:value-to test="caseitem[#modifyc=1]" select="#modifyc|case/@variable/#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='assignment']">
        <admst:choose>
          <admst:when test="[lhs/datatypename='array']">
            <admst:variable name="lhs" path="lhs/variable"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="lhs" path="lhs"/>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifys=1])]" select="#modifys|rhs/#modifys|rhs/variable/#modifys" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyd=1])]" select="#modifyd|rhs/#modifys|rhs/variable/#modifyd" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyn=1])]" select="#modifyn|rhs/#modifys|rhs/variable/#modifyn" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyc=1])]" select="#modifyc|rhs/#modifys|rhs/variable/#modifyc" path="1"/>
        <admst:value-to test="$lhs/ddxprobe" select="#ddxprobe" string="yes"/>
        <admst:push into="rhs/variable/ddxprobe" select="$lhs/ddxprobe" onduplicate="ignore"/>
      </admst:when>
      <admst:when test="[datatypename='contribution']">
        <admst:choose>
          <admst:when test="[#fixmedynamic=1]">
            <admst:value-to select="#modifyd|(lhs|rhs|rhs/variable)/#modifyd" path="1"/>
          </admst:when>
          <admst:when test="[#fixmeflickernoise=1]">
            <admst:value-to select="flickernoise|lhs/flickernoise" string="yes"/>
            <admst:value-to select="#modifyn|(lhs|rhs|rhs/variable)/#modifyn" path="1"/>
          </admst:when>
          <admst:when test="[#fixmewhitenoise=1]">
            <admst:value-to select="whitenoise|lhs/whitenoise" string="yes"/>
            <admst:value-to select="#modifyn|(lhs|rhs|rhs/variable)/#modifyn" path="1"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#modifys|(lhs|rhs|rhs/variable)/#modifys" path="1"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='blockvariable']">
      </admst:when>
      <admst:when test="[datatypename='nilled']"/>
      <admst:when test="[datatypename='callfunction']">
        <admst:value-to select="#modifyc|function/arguments/variable/#modifyc" path="1"/>
      </admst:when>
      <admst:otherwise><admst:fatal format="%(datatypename): case not handled\n"/></admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:apply-templates select="analog/code" match="modify"/>
  <admst:push into="@analogitems" select="assignment|assignment/rhs|contribution|contribution/rhs|block|forloop|whileloop|case|callfunction|conditional|conditional/if"/>
  <admst:value-to select="@analogitems[#modifys=1 or #modifyn=1 or #modifyc=1]/static" string="yes"/>
  <admst:value-to select="@analogitems[#modifys!=1 and #modifyn!=1 and #modifyc!=1]/dynamic" string="yes"/>

  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1])]/#modifys" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyd=1])]/#modifyd" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyn=1])]/#modifyn" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyc=1])]/#modifyc" path="1"/>

  <!-- let's try not counting noise source use as "insource", because Xyce
       only uses "insource" to figure out if we need derivatives.  We don't
       need derivatives for noise-only sources -->

  <!-- <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1 or #modifyd=1 or #modifyn=1])]/insource" string="yes"/> -->
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1 or #modifyd=1])]/insource" string="yes"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1 or #modifyn=1 or #modifyc=1])]/static" string="yes"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyd=1])]/dynamic" string="yes"/>
  <admst:value-to select="source[#modifys=1 or #modifyn=1]/static" string="yes"/>
  <admst:value-to select="source[#modifyd=1]/dynamic" string="yes"/>

  <!-- jacobian -->
  <admst:for-each select="contribution">
    <admst:variable name="mycontribution" path="."/>
    <admst:variable name="mysource" path="lhs"/>
    <admst:push into="$mysource/attribute" select="attribute"/>
    <!-- case I() <+ .V(). -->
    <admst:for-each select="rhs/probe[(nature=discipline/potential)and($mysource/nature=$mysource/discipline/flow)]">
      <admst:new datatype="jacobian" inputs="module,$mysource/branch/pnode,branch/pnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
      </admst:new>
      <admst:new test="branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/pnode,branch/nnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
      </admst:new>
      <admst:new test="$mysource/branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/nnode,branch/pnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
        <admst:new test="../branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/nnode,../branch/nnode">
          <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
        </admst:new>
      </admst:new>
      <admst:for-each select="/reverse(@jacobian)">
        <admst:choose>
          <admst:when test="module/jacobian[row=../../row and column=../../column]">
            <admst:variable name="jacobian" path="module/jacobian[row=../../row and column=../../column]"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="jacobian" path="."/>
            <admst:value-to select="[row=column]/diagonal" string="yes"/>
            <admst:push into="module/jacobian" select="."/>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to test="$mycontribution[dynamic='yes']" select="$jacobian/dynamic" string="yes"/>
        <admst:value-to test="$mycontribution[dynamic='no']" select="$jacobian/static" string="yes"/>
      </admst:for-each>
      <admst:value-to select="/@jacobian"/>
    </admst:for-each>
  </admst:for-each>
  <admst:reverse select="jacobian"/>
</admst:template>

<admst:template match="adms.implicit.xml.nature">
  <admst:reverse select="/argv|/discipline|/nature"/>
  <admst:for-each select="/nature">
    <admst:value-to select="ddt_nature" path="/nature[name='%(../../ddt_name)']"/>
    <admst:value-to select="idt_nature" path="/nature[name='%(../../idt_name)']"/>
  </admst:for-each>
</admst:template>

<admst:template match="adms.implicit.xml">
  <admst:apply-templates select="." match="adms.implicit.xml.nature"/>
  <admst:apply-templates select="/module" match="adms.implicit.xml.module"/>
</admst:template>

<admst:apply-templates select="." match="adms.implicit.xml"/>

<!--admst:sendmail>
  <admst:subject>automatic mailing from %(/simulator/fullname)</admst:subject>
  <admst:arguments recipient="%(/simulator/fullname)"/>
  <admst:to recipient="r29173@freescale.com"/>
  <admst:message>
  </admst:message>
</admst:sendmail-->


</admst>

<?escript name="/usr/local/stow/Xyce/7.8-adms/share/xml/xyceVersion_nosac.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!-- simulator settings -->
<admst:value-to select="/simulator/package_name" value="Xyce"/>
<admst:value-to select="/simulator/package_tarname" value="Xyce"/>
<admst:value-to select="/simulator/package_version" value="7.7.0"/>
<admst:value-to select="/simulator/package_string" value="Xyce 7.7.0"/>
<admst:value-to select="/simulator/package_bugreport" value="xyce@sandia.gov"/>

</admst>

<?escript name="/usr/local/stow/Xyce/7.8-adms/share/xml/xyceBasicTemplates_nosac.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst PUBLIC "-//adms//DTD admst 2.0//-" "http://mot-adms.sourceforge.net/xml-files/adms/admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

  <!--
  Purpose:  Provide a basic set of ADMST templates for working on Xyce
            modules
      Creator:   Tom Russo, SNL, Electrical and Microsystems Modeling
      Creation Date: 8 May 2008

     Copyright 2002-2023 National Technology & Engineering Solutions of
     Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
     NTESS, the U.S. Government retains certain rights in this software.

     This file is part of the Xyce(TM) Parallel Electrical Simulator.

     Xyce(TM) is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     Xyce(TM) is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Xyce(TM).
     If not, see <http://www.gnu.org/licenses/>.


   =================================================================-
   =================================================================-
    simple templates for producing commonly-used information
   =================================================================-
   =================================================================-
  -->

<!-- declare a global var used for collectAssignedVariables-->
<admst:variable name="theGlobalAssignedVarsTarget"/>
<!-- some variables we'll use later -->
<!-- This one will be set to the current probe with respect to which we're
     differentiating -->
<admst:variable name="derivProbe"/>
<admst:variable name="derivProbe2"/>
<admst:variable name="initializeOnDeclare" select="yes"/>
<admst:variable name="probeList"/>
<admst:variable name="doSecondDerivs" select="no"/>
<admst:variable name="collapseFailure" select="no"/>

  <!--
   =================================================================-
   xyceNumberNodes
    return the number of nodes (internal and external)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberNodes">
    <admst:text format="%(count(node[grounded='no']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberProbes
    return the number of nodes (internal and external)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberProbes">
    <admst:text format="%(count(probe)+count(@extraProbeBranches))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberInternalNodes
    return the number of nodes (internal)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberInternalNodes">
    <admst:text format="%(count(node[grounded='no' and location='internal']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberExternalNodes
    return the number of nodes (External)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberExternalNodes">
    <admst:text format="%(count(node[grounded='no' and location='external']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberOptionalNodes
    return the number of optional nodes in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberOptionalNodes">
    <admst:text format="%(count(node[grounded='no' and location='external' and exists(#optional)]))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberRequiredNodes
    return the number of required nodes in the given
    module.  This is the number of location='external' nodes less
    the number of optionals.
   =================================================================-
  -->
  <admst:template match="xyceNumberRequiredNodes">
    <admst:text format="%(count(node[grounded='no' and location='external' and not exists(#optional)]))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberLeadCurrents
    return the number of lead currents needed
   =================================================================-
  -->
  <admst:template match="xyceNumberLeadCurrents">
    <admst:choose>
      <admst:when test="[count(node[grounded='no' and location='external']) = 2 ]">
        <admst:text format="1"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="%(count(node[grounded='no' and location='external']))"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   xyceDeviceNamespace
    Given a module, return what Xyce namespace we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceDeviceNamespace">
    <admst:return name="classname" value="ADMS%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceClassBaseName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceClassBaseName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceClassName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceInstanceClassName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)Instance"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelClassName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceModelClassName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)Model"/>
  </admst:template>

  <!--
   =================================================================-
   xyceGuardSymbol: make a symbol for the header file to use to prevent
   multiple inclusion
   =================================================================-
  -->
  <admst:template match="xyceGuardSymbol">
    <admst:return name="symbolname" value="Xyce_N_DEV_ADMS%(name)_h"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNodeConstantName
    given a node, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceNodeConstantName">
    <admst:return name="nodeConstant" value="admsNodeID_%(name)"/>
  </admst:template>
  <!--
   =================================================================-
   xyceBranchConstantName
    given a branch, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceBranchConstantName">
    <admst:return name="branchConstant" value="admsBRA_ID_%(pnode)_%(nnode)"/>
  </admst:template>


  <!--
   =================================================================-
   xyceProbeConstantName
    given a probe, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_%(nature)_%(branch/pnode)_%(branch/nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xycePotentialProbeConstantName
    given a branch, generate the name of the integer symbol used to
    identify its associated potetial probe constant in Xyce
   =================================================================-
  -->
  <admst:template match="xycePotentialProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_V_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceFlowProbeConstantName
    given a branch, generate the name of the integer symbol used to
    identify it's associated flow probe in Xyce
   =================================================================-
  -->
  <admst:template match="xyceFlowProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_I_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceJacobianOffsetName
    given a jacobian element, generate the name of the integer symbol
    used to identify its offset
   =================================================================-
  -->
  <admst:template match="xyceJacobianOffsetName">
    <admst:text format="A_%(row/name)_Equ_%(column/name)_NodeOffset"/>
  </admst:template>

  <!--
   =================================================================-
   xycedFdXPtrName
    given a jacobian element, generate the name of the pointer var
    used to identify its location
   =================================================================-
  -->
  <admst:template match="xycedFdXPtrName">
    <admst:text format="f_%(row/name)_Equ_%(column/name)_Node_Ptr"/>
  </admst:template>
  <!--
   =================================================================-
   xycedQdXPtrName
    given a jacobian element, generate the name of the pointer var
    used to identify its location
   =================================================================-
  -->
  <admst:template match="xycedQdXPtrName">
    <admst:text format="q_%(row/name)_Equ_%(column/name)_Node_Ptr"/>
  </admst:template>

  <!--
   =================================================================-
    xyceDeclareVariable
    Given a variable, emit a C++ declaration for that variable
   =================================================================-
  -->
  <admst:template match="xyceDeclareVariable">
    <admst:assert test="adms[datatypename='variable' or datatypename='variableprototype']" format="xyceDeclareVariable expecting datatypename=variable or variableprototype, got %(adms/datatypename)"/>
    <admst:choose>
      <admst:when test="[type='real' and exists(probe) and not($globalCurrentScope='sensitivity')]">
        <admst:text format="double"/>
      </admst:when>
      <!-- Bah.  Looks like "variable" dependency doesn't get propagated past
           one level.

           Tried having  and exists(variable[input='yes']) here, and it
           seems to have missed some.  So we have to make ALL reals in
           sensitivity be FADS
      -->
      <admst:when test="[type='real' and $globalCurrentScope='sensitivity' and exists(#Pdependent)]">
        <admst:text format="double"/>
      </admst:when>
      <admst:otherwise>
        <admst:apply-templates select="." match="verilog2CXXtype"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format=" %(name)"/>
    <admst:if test="[$initializeOnDeclare='yes']">
      <admst:text format="=0.0"/>
    </admst:if>
    <admst:text format=";\n"/>
    <admst:if test="[type='real' and $globalCurrentScope='sensitivity' and exists(#Pdependent)]">
        <admst:text format="double d_%(name)_dX=0.0;\n"/>
    </admst:if>
    <admst:if test="[type='real' and exists(probe) and not($globalCurrentScope='sensitivity') and (insource='yes' or not(nilled(ddxprobe)))]">
      <admst:variable name="myVar" path="."/>
      <admst:for-each select="probe">
        <admst:variable name="myprobe" path="."/>
        <admst:text format="    "/>
        <admst:text format=" double d_%($myVar/name)_d%(nature)_%(branch/pnode)_%(branch/nnode)"/>
        <admst:if test="[$initializeOnDeclare='yes']">
          <admst:text format="=0.0"/>
        </admst:if>
        <admst:text format=";\n"/>
        <admst:if test="[../insource='yes' and $doSecondDerivs='yes']">
          <!-- this looks fishy to me and presupposes that all ddxprobes are of form V(X,GND), 
               and never V(X,Y) but the former is pretty much what all ddx() usage is in the wild.  -->
          <admst:if test="[exists($myVar/ddxprobe/branch/pnode[.=$myprobe/branch/pnode or .=$myprobe/branch/nnode])]">
            <admst:for-each select="$myVar/probe">
              <admst:text format="    "/>
              <admst:text format=" double d_%($myVar/name)_d%($myprobe/nature)_%($myprobe/branch/pnode)_%($myprobe/branch/nnode)_d%(./nature)_%(./branch/pnode)_%(./branch/nnode)"/>
              <admst:if test="[$initializeOnDeclare='yes']">
                <admst:text format="=0.0"/>
              </admst:if>
              <admst:text format=";\n"/>
            </admst:for-each>
          </admst:if>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:template>

  <!--
   =================================================================-
   =================================================================-
    Specialized templates for dealing with guessing device model cards
    and/or header files to include
   =================================================================-
   -->

   <!--
   =================================================================-
   xyceIncludeModelBaseHeader
   Given a module, this template generates an appropriate "#include"
   for the base device IF the module has a "xyceModelGroup" attribute.
   If the attribute doesn't exist, no include is generated.

   Recognized groups:        Header included:
      MOSFET                  N_DEV_MOSFET1.h
      <anything else>         N_DEV_<that>.h
   =================================================================-
   -->
   <admst:template match="xyceIncludeModelBaseHeader">
     <admst:choose>
       <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
         <admst:choose>
           <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
             <admst:text format="#include &lt;N_DEV_MOSFET1.h&gt;\n"/>
           </admst:when>
           <admst:when test="[attribute[name='xyceModelGroup']/value='BJT' 
                       or attribute[name='xyceModelGroup']/value='JFET'
                       or attribute[name='xyceModelGroup']/value='Diode' 
                       or attribute[name='xyceModelGroup']/value='Resistor' 
                       or attribute[name='xyceModelGroup']/value='Capacitor']">
             <admst:text format="#include &lt;N_DEV_%(attribute[name='xyceModelGroup']/value).h&gt;\n"/>
           </admst:when>
           <admst:otherwise>
             <admst:fatal format="Xyce-specific module attribute xyceModelGroup given but has unknown value %(attribute[name='xyceModelGroup']/value).  Please remove this attribute.\n"/>
           </admst:otherwise>
         </admst:choose>
       </admst:when>
     </admst:choose>
   </admst:template>

   <!--
   =================================================================-
   xyceDeclareTraits
   Given a module, this template generates an appropriate "typedef"
   for the DeviceTraits.  IF the module has a "xyceModelGroup" attribute,
   then this uses the base group instance as the group in the template.
   If the attribute doesn't exist, no base group is used.

   Recognized groups:        Base instance:
      MOSFET                  MOSFET1
      <anything else>         <verbatim>
   =================================================================-
   -->
   <admst:template match="xyceDeclareTraits">
struct Traits: public DeviceTraits&lt;Model, Instance
     <admst:choose>
       <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
         <admst:choose>
           <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
             <admst:text format=", MOSFET1::Traits"/>
           </admst:when>
           <admst:otherwise>
             <admst:text format=", %(attribute[name='xyceModelGroup']/value)::Traits"/>
           </admst:otherwise>
         </admst:choose>
       </admst:when>
     </admst:choose>&gt;
{

    <!-- Figure out a level number -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceLevelNumber'])]">
        <admst:variable name="theLevelNumber" select="%(attribute[name='xyceLevelNumber']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theLevelNumber" select="1"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Choose a device name -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceDeviceName'])]">
        <admst:variable name="theDeviceName" select="%(attribute[name='xyceDeviceName']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theDeviceName" select="ADMS %(name)"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Figure out what spice symbol we use -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceSpiceDeviceName'])]">
        <admst:variable name="theSpiceDevice" select="%(attribute[name='xyceSpiceDeviceName']/value)"/>
      </admst:when>
      <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
        <admst:choose>
          <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:variable name="theSpiceDevice" select="m"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='JFET']">
            <admst:variable name="theSpiceDevice" select="j"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:variable name="theSpiceDevice" select="q"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
            <admst:variable name="theSpiceDevice" select="d"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
            <admst:variable name="theSpiceDevice" select="r"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
            <admst:variable name="theSpiceDevice" select="c"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theSpiceDevice" select="%(.)"/>
      </admst:otherwise>
    </admst:choose>

    <admst:text format="  static const char *name() {return &quot;%($theDeviceName)&quot;;}\n"/>
    <admst:text format="  static const char *deviceTypeName() {return &quot;%(upper-case($theSpiceDevice)) level %($theLevelNumber)&quot;;}\n"/>
  static int numNodes() {return <admst:text format="%(xyceNumberRequiredNodes(.))"/>;}

  <admst:if test="[exists(@optnodes)]">
  static int numOptionalNodes() {return %(xyceNumberOptionalNodes(.));};
  </admst:if>

  static bool modelRequired() {return 
     <admst:choose>
       <admst:when test="variable[parametertype='model' and input='yes']">
         <admst:text format="true"/>
       </admst:when>
       <admst:otherwise>
         <admst:text format="false"/>
       </admst:otherwise>
     </admst:choose>
     <admst:text format=";}"/>
  static bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &amp;configuration, const FactoryBlock &amp;factory_block);
  static void loadModelParameters(ParametricData&lt;Model&gt; &amp;model_parameters);
  static void loadInstanceParameters(ParametricData&lt;Instance&gt; &amp;instance_parameters);
};
   </admst:template>

  <!--
   =================================================================-
   xyceDeviceFactoryandRegisterDevice

   Given a module, this template generates appropriate code for a
   device factory and registerDevice method.  If the attribute
   xyceDeviceName exists, we use that as the name of the device.  If
   not, we use "ADMS <module name>".  Other expected attributes are:

      xyceSpiceDeviceName:   if not given, guess at one from xyceModelGroup.
                             If that is not given, emit a "FIXME"
      xyceLevelNumber:       If not given, "FIXME"

   -->
  <admst:template match="xyceDeviceFactoryandRegisterDevice">

    <!-- Figure out what spice symbol we use -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceSpiceDeviceName'])]">
        <admst:variable name="theSpiceDevice" select="%(attribute[name='xyceSpiceDeviceName']/value)"/>
      </admst:when>
      <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
        <admst:choose>
          <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:variable name="theSpiceDevice" select="m"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='JFET']">
            <admst:variable name="theSpiceDevice" select="j"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:variable name="theSpiceDevice" select="q"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
            <admst:variable name="theSpiceDevice" select="d"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
            <admst:variable name="theSpiceDevice" select="r"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
            <admst:variable name="theSpiceDevice" select="c"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theSpiceDevice" select="%(.)"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Figure out a level number -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceLevelNumber'])]">
        <admst:variable name="theLevelNumber" select="%(attribute[name='xyceLevelNumber']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theLevelNumber" select="1"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Now emit the factory -->
    <admst:text format="Device *Traits::factory(const Configuration &amp;configuration, const FactoryBlock &amp;factory_block)\n"/>
    <admst:text format="{\n"/>
    <admst:text format="  return new DeviceMaster&lt;Traits&gt;(configuration, factory_block, factory_block.solverState_, factory_block.deviceOptions_);\n"/>
    <admst:text format="}\n\n"/>

    <!-- and the registerDevice -->
    <admst:text format="void\nregisterDevice(const DeviceCountMap&amp; deviceMap, const std::set&lt;int&gt;&amp; levelSet)\n"/>
    <admst:text format="{\n"/>
    <admst:text format="if (deviceMap.empty() ||\n((deviceMap.find(&quot;%(upper-case($theSpiceDevice))&quot;) != deviceMap.end() &amp;&amp; (levelSet.find(%($theLevelNumber))!=levelSet.end()))))\n{\n"/>
     <admst:choose>
       <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
         <admst:choose>
           <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
             <admst:text format="MOSFET1::registerDevice();\n"/>
           </admst:when>
           <admst:otherwise>
             <admst:text format="%(attribute[name='xyceModelGroup']/value)::registerDevice();\n\n"/>
           </admst:otherwise>
         </admst:choose>
       </admst:when>
     </admst:choose>
    <admst:text format="  Config&lt;Traits&gt;::addConfiguration()\n"/>
    <admst:text format="    .registerDevice(&quot;%($theSpiceDevice)&quot;, %($theLevelNumber))"/>

    <!-- and all the registerModelTypes... -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceModelCardType'])]">
        <admst:for-each select="attribute[name='xyceModelCardType']">
          <admst:text format="\n    .registerModelType(&quot;%(./value)&quot;, %($theLevelNumber))"/>
        </admst:for-each>
      </admst:when>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
            <admst:choose>
              <admst:when  test="[attribute[name='xyceModelGroup']/value='MOSFET']">
                <admst:text format="\n    .registerModelType(&quot;nmos&quot;, %($theLevelNumber))"/>
                <admst:text format="\n    .registerModelType(&quot;pmos&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when  test="[attribute[name='xyceModelGroup']/value='JFET']">
                <admst:text format="\n    .registerModelType(&quot;njf&quot;, %($theLevelNumber))"/>
                <admst:text format="\n    .registerModelType(&quot;pjf&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
                <admst:text format="\n    .registerModelType(&quot;npn&quot;, %($theLevelNumber))"/>
                <admst:text format="\n    .registerModelType(&quot;pnp&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
                <admst:text format="\n    .registerModelType(&quot;d&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
                <admst:text format="\n    .registerModelType(&quot;r&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
                <admst:text format="\n    .registerModelType(&quot;c&quot;, %($theLevelNumber))"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <!-- If the device requires a model (i.e. there are any
                  parameters of type "model"), and no modely type has
                  been given in attributes, emit comments to fix the issue -->
            <admst:if test="variable[(parametertype='model' and input='yes') or (parametertype='instance' and exists(attribute/[name='xyceAlsoModel']) and input='yes')]">

                <admst:text format="\n    .registerModelType(&quot;%($theSpiceDevice)&quot;, %($theLevelNumber))\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>

    <admst:text format=";\n}\n}\n\n"/>

  </admst:template>


  <!--
   =================================================================-
   xyceSetTypeVariable

   If the module defines a xyceModelGroup AND a non-null xyceTypeVariable,
   emit the hackish code that sets the type variable based on the model
   card type.

   Input type is a module.
   =================================================================-
  -->
  <admst:template match="xyceSetTypeVariable">
    <admst:if test="[exists(attribute[name='xyceModelGroup']) and (attribute[name='xyceModelGroup']/value='MOSFET' or attribute[name='xyceModelGroup']/value='BJT' or attribute[name='xyceModelGroup']/value='JFET')]">
      <admst:variable name="Ptype" value="-1"/>
      <admst:if test="[exists(attribute[name='xycePTypeValue']) and attribute[name='xyceTypePtypeValue']/value != '']">
        <admst:variable name="Ptype" value="%(attribute[name='xycePTypeValue']/value)"/>
      </admst:if>
      <admst:if test="[exists(attribute[name='xyceTypeVariable']) and attribute[name='xyceTypeVariable']/value != '']">
        <admst:text format="\n// set internal model type based on model card type\n"/>
        <admst:choose>
          <admst:when  test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:text format="if (getType() == &quot;pmos&quot; || getType() == &quot;PMOS&quot;)\n"/>
          </admst:when>
          <admst:when  test="[attribute[name='xyceModelGroup']/value='JFET']">
            <admst:text format="if (getType() == &quot;pjf&quot; || getType() == &quot;PJF&quot;)\n"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:text format="if (getType() == &quot;pnp&quot; || getType() == &quot;PNP&quot;)\n"/>
          </admst:when>
        </admst:choose>
        <admst:text format="    %(attribute[name='xyceTypeVariable']/value) = %($Ptype);\n"/>
      </admst:if>
    </admst:if>
  </admst:template>


  <!--
   =================================================================-
   =================================================================-
    Specialized templates for declaring and initializing Instance and
    Model variables
   =================================================================-

   =================================================================-
   xyceDeclareInstanceVariables
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and declare them
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareInstanceVariables">
    <admst:text format="    // Begin verilog Instance Variables\n"/>
    <admst:text format="    //   Instance Parameters\n"/>
    <admst:for-each select="variable[parametertype='instance' and input='yes']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %(name);\n"/>
    </admst:for-each>
    <admst:text format="    //  Variables of global_instance scope\n"/>
    <admst:for-each select="variable[scope='global_instance' and input='no']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <admst:text format="    // end verilog Instance Variables=====\n"/>
  </admst:template>


  <!--
   =================================================================-
   xyceDeclareNodeConstants
    Declare const integers giving the node number of all named nodes
   =================================================================-
  -->
  <admst:template match="xyceDeclareNodeConstants">
    <admst:text format="   // node numbers\n"/>
    <admst:for-each select="node[grounded='no' and location='external']">
      <admst:text test="[exists(#optional)]" format="// optional node %(.):\n"/>
      <admst:text format="    static const int %(xyceNodeConstantName(.)/[name='nodeConstant']/value) = %(position(.)-1);\n"/>
    </admst:for-each>
    <admst:variable name="numext" select="%(count(node[grounded='no' and location='external']))"/>
    <admst:for-each select="node[grounded='no' and location='internal']">
      <admst:text format="    static const int %(xyceNodeConstantName(.)/[name='nodeConstant']/value) = %(position(.)-1)+$numext;\n"/>
    </admst:for-each>
    <admst:text format="    static const int admsNodeID_GND = -1;\n"/>
    <admst:text format="   // end node numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareBranchConstants
    Declare const integers giving the node number of all named nodes
   =================================================================-
  -->
  <admst:template match="xyceDeclareBranchConstants">
    <admst:text format="   // Additional IDs for branch equations\n"/>
    <admst:for-each select="/module/@extraUnknowns">
      <admst:text format="    static const int %(xyceBranchConstantName(.)/[name='branchConstant']/value) = %(position(.)-1 + count(/module/node[grounded='no']));\n"/>
    </admst:for-each>
    <admst:text format="   // end branch numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareProbeConstants
    Declare const integers giving the probe number of all used probes
   =================================================================-
  -->
  <admst:template match="xyceDeclareProbeConstants">
    <admst:text format="   // Probe numbers\n"/>
    <admst:for-each select="$thisModule/probe">
      <admst:text format="    static const int %(xyceProbeConstantName(.)/[name='probeConstant']/value) = %(position(.)-1);\n"/>
    </admst:for-each>
    <admst:for-each select="@extraProbeBranches">
      <admst:text format="    static const int %(xyceFlowProbeConstantName(.)/[name='probeConstant']/value) = %(count($thisModule/probe)+position(.)-1);\n"/>
    </admst:for-each>
    <admst:text format="   // end probe numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLimitedProbeStoreLIDs
    Declare integers for store LIDs of limited probes, given a module
   =================================================================-
  -->
  <admst:template match="xyceDeclareLimitedProbeStoreLIDs">
    <admst:text format="   // Store LIDs\n"/>
    <admst:for-each select="@limitedProbes">
      <admst:text format="    int %(xyceLimitedProbeStoreLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="   // end store LIDs\n"/>
  </admst:template>
  <!--
   =================================================================-
   xyceDeclareOutputStoreLIDs
    Declare integers for store LIDs of output variables, given a module
   =================================================================-
  -->
  <admst:template match="xyceDeclareOutputStoreLIDs">
    <admst:text format="   // Store LIDs for output vars\n"/>
    <admst:for-each select="variable[output='yes' and input!='yes']">
      <admst:text format="    int li_store_%(name);\n"/>
    </admst:for-each>
    <admst:text format="   // end store LIDs for output vars\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceInitializers
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and generate
   an initializer list for the constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceInstanceInitializers">
    <admst:if test="[exists(variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)("/>
      <admst:choose>
        <admst:when test="[exists(default) and not exists(#dependent)]">
          <admst:text format="%(printTerm(default))"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="0.0"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="0"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="&quot;&quot;"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:text format=")"/>
      <admst:if test="[type='real' and exists(probe) and not($globalCurrentScope='sensitivity') and (insource='yes' or not(nilled(ddxprobe)))]">
        <admst:text format=",\n"/>
        <admst:join select="probe" separator=",\n">
          <admst:text format="d_%(../name)_d%(nature)_%(branch/pnode)_%(branch/nnode)(0.0)"/>
        </admst:join>
    </admst:if>
    </admst:join>
    <!-- now initialize the LIDs: -->
    <admst:if test="[exists(node[grounded='no'])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="node[grounded='no']" separator=",\n    ">
      <admst:text format="%(xyceNodeLIDVariable(.))(-1)"/>
    </admst:join>
    <admst:if test="[exists(@extraUnknowns)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="@extraUnknowns" separator=",\n    ">
      <admst:text format="%(xyceBranchLIDVariable(.))(-1)"/>
    </admst:join>
    <admst:text format=",\n    "/>
    <admst:choose>
      <admst:when test="[count($theModule/node[grounded='no' and location='external']) = 2 ]">
        <admst:text format="%(xyceLeadBranchLIDVariable(node[2]))(-1)"/>
      </admst:when>
      <admst:otherwise>
        <admst:join select="node[grounded='no' and location='external']" separator=",\n    ">
          <admst:text format="%(xyceLeadBranchLIDVariable(.))(-1)"/>
        </admst:join>
      </admst:otherwise>
    </admst:choose>
    <!-- now initialize the jacobian pointers: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedFdXPtrName(.))(0)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(0)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <!-- for the Q jacobian -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedQdXPtrName(.))(0)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(0)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <!-- now initialize the jacobian offsets: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xyceJacobianOffsetName(.))(-1)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset(-1)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset(-1)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset(-1)"/>
      </admst:join>
    </admst:for-each>
    <!-- now initialize the store lids -->
    <admst:if test="[count(@limitedProbes)>0]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="@limitedProbes" separator=",\n    ">
      <admst:text format="%(xyceLimitedProbeStoreLIDVariable(.))(-1)"/>
    </admst:join>
    <admst:if test="[count(variable[output='yes' and input!='yes'])>0]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[output='yes' and input!='yes']" separator=",\n    ">
      <admst:text format="li_store_%(name)(-1)"/>
    </admst:join>
    <admst:if test="[count(node[#collapsible='yes'])>0]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="node[#collapsible='yes']" separator=",\n    ">
      <admst:text format="collapseNode_%(name)(false)"/>
    </admst:join>
    <admst:if test="[count(callfunction[function/name='\$bound_step'])>0]">
      <admst:text format=",\n  maxTimeStep_(getDeviceOptions().defaultMaxTimeStep)"/>
    </admst:if>
    <admst:text format=",\n    admsTemperature(getDeviceOptions().temp.getImmutableValue&lt;double&gt;())\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelInitializers
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and generate
   an initializer list for the constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceModelInitializers">
    <admst:if test="[exists(variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)("/>
      <admst:choose>
        <admst:when test="[exists(default) and not exists(#dependent)]">
          <admst:text format="%(printTerm(default))"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="0.0"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="0"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="&quot;&quot;"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:text format=")"/>
    </admst:join>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceCopyInitializers
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and generate
   an initializer list for the copy constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceInstanceCopyInitializers">
    <admst:if test="[exists(variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)(right.%(name))"/>
    </admst:join>
    <!-- now initialize the LIDs: -->
    <admst:if test="[exists(node[grounded='no'])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="node[grounded='no']" separator=",\n    ">
      <admst:text format="%(xyceNodeLIDVariable(.))(right.%(xyceNodeLIDVariable(.)))"/>
    </admst:join>
    <!-- now initialize the jacobian offsets: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedFdXPtrName(.))(right.%(xycedFdXPtrName(.)))"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(right.f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(right.f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(right.f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <!-- same for Q -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedQdXPtrName(.))(right.%(xycedQdXPtrName(.)))"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(right.q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(right.q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(right.q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:text format=",\n    admsTemperature(right.admsTemperature)\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelCopyInitializers
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and generate
   an initializer list for the copy constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceModelCopyInitializers">
    <admst:if test="[exists(variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)(right.%(name))"/>
    </admst:join>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareModelVariables
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and declare them.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareModelVariables">
    <admst:text format="// Begin verilog Model Variables\n"/>
    <admst:text format="//   Model Parameters\n"/>
    <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %(name);\n"/>
    </admst:for-each>
    <admst:text format="    //  Variables of global_model scope\n"/>
    <admst:for-each select="variable[scope='global_model' and input='no']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
      <admst:if test="[type='real' and exists(probe)]">
        <admst:warning format="WARNING!  global model variable %(name) has probe dependence.  That smells like an error.\n"/>
      </admst:if>
    </admst:for-each>
    <admst:text format="    // end verilog model variables====="/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareNodeLIDVariables
   Generate a set of declarations for LID variables given module's
   nodes.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareNodeLIDVariables">
    <admst:text format="    // Nodal LID Variables\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:text format="    int %(xyceNodeLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="    // end Nodal LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareBranchLIDVariables
   Generate a set of declarations for LID variables given module's
   branch equations.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareBranchLIDVariables">
    <admst:text format="    // Branch LID Variables\n"/>
    <admst:for-each select="@extraUnknowns">
      <admst:text format="    int %(xyceBranchLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="    // end Branch LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLeadBranchLIDVariables
   Generate a set of declarations for LID variables given module's
   branch equations.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareLeadBranchLIDVariables">
    <admst:text format="    // Lead (branch) LID Variables\n"/>

    <!-- two-terminal devices are special, we only use one of the
         two possible lead currents, the first one. -->
    <admst:choose>
      <admst:when test="[count(node[grounded='no' and location='external']) = 2 ]">
        <!-- The first node is always GND -->
        <admst:text format="    int %(xyceLeadBranchLIDVariable(node[2]));\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:for-each select="node[grounded='no' and location='external']">
          <admst:text format="    int %(xyceLeadBranchLIDVariable(.));\n"/>
        </admst:for-each>
      </admst:otherwise>
    </admst:choose>
    <admst:text format="    // end Lead (branch) LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareJacobianOffsets
   given a module, declare the batch of Offset variables used when
   accessing jacobian elements
   =================================================================-
  -->
  <admst:template match="xyceDeclareJacobianOffsets">
    <admst:text format="    // Jacobian  pointers\n"/>
    <!-- normal jacobian pointers -->
    <admst:for-each select="jacobian">
      <admst:text format="    double * %(xycedFdXPtrName(.));\n"/>
    </admst:for-each>
    <!-- extra pointers for columns from branch equation dependencies -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>
    <!-- extra pointers for branch equation rows -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="    double * f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr;\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>

    <!-- now the same thing for Q -->
    <admst:for-each select="jacobian">
      <admst:text format="    double * %(xycedQdXPtrName(.));\n"/>
    </admst:for-each>
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
        <admst:for-each select="@nodeDeps">
          <admst:text format="    double * q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr;\n"/>
        </admst:for-each>
        <admst:for-each select="@branchDeps">
          <admst:text format="    double * q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr;\n"/>
        </admst:for-each>
    </admst:for-each>
    <admst:text format="    // Jacobian offsets\n"/>
    <!-- normal jacobian pointers -->
    <admst:for-each select="jacobian">
      <admst:text format="    int %(xyceJacobianOffsetName(.));\n"/>
    </admst:for-each>
    <!-- extra pointers for columns from branch equation dependencies -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    int A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset;\n"/>
      </admst:for-each>
    </admst:for-each>
    <!-- extra pointers for branch equation rows -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="    int A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset;\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    int A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset;\n"/>
      </admst:for-each>
    </admst:for-each>

    <admst:text format="    // end of Jacobian and pointers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareFadArrays
   Given a module, generate declaration of contribution arrays
   =================================================================-
  -->
  <admst:template match="xyceDeclareFadArrays">
    <admst:text format=" // Arrays to hold probes\n"/>
    <admst:text format=" std::vector &lt; double &gt; probeVars;\n"/>
    <admst:text format=" std::vector &lt; std::vector &lt; double &gt; &gt; d_probeVars;\n"/>
    <admst:text format=" // Arrays to hold contributions\n"/>
    <admst:text format=" // dynamic contributions are differentiated w.r.t time\n"/>
    <admst:text format=" std::vector &lt; double &gt; staticContributions;\n"/>
    <admst:text format=" std::vector &lt; std::vector &lt; double &gt; &gt; d_staticContributions;\n"/>
    <admst:text format=" std::vector &lt; double &gt; dynamicContributions;\n"/>
    <admst:text format=" std::vector &lt; std::vector &lt; double &gt; &gt; d_dynamicContributions;\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLimitingTemporaries
   Declare the various temporary variables that we need for limiting
   in updateIntermediateVarsBlock.  Pass in the module.
   =================================================================-
  -->
  <admst:template match="xyceDeclareLimitingTemporaries">
    <admst:text format=" // temporary variables for limiting\n"/>
    <admst:for-each select="@limiters">
      <admst:text format=" double %(printTerm(lhs))_orig,%(printTerm(lhs))_limited,%(printTerm(lhs))_old;\n"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceNodeLIDVariable
   Given a node, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceNodeLIDVariable">
    <admst:text format="li_%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceBranchLIDVariable
   Given a branch, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceBranchLIDVariable">
    <admst:text format="li_BRA_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceLeadBranchLIDVariable
   Given a lead node, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceLeadBranchLIDVariable">
    <admst:text format="li_branch_i%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceLimitedProbeStoreLIDVariable
   Given a probe, return its associated state LID variable for limiting
   =================================================================-
  -->
  <admst:template match="xyceLimitedProbeStoreLIDVariable">
    <admst:text format="li_store_%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNoiseContributionName
   Given a contribution that has either white or flicker noise
   (and ONLY one term)
   construct a name for the noise.
   This noise name cannot just be the "name" argument of the noise
   function, because that is not guaranteed unique to the device
   (fbh has four terms named "thermal", for example)

   We will use "<type>_<posnode>_<negnode>".  If there is a name
   argument, we'll append "_<namearg" to the name.


  -->
  <admst:template match="xyceNoiseContributionName">
    <!-- first sanity check.  In this implementation, we ONLY support
         noise contributions that are simple "I(branch)<+ type_noise()"
         and cannot work with more complex RHS expressions. -->
    <admst:assert test="adms[datatypename='contribution']" format="xyceNoiseContribution called on something other than a contribution!\n"/>
    <admst:assert test="[datatypename='contribution' and (whitenoise='yes' or flickernoise='yes')]" format="xyceNoiseContribution called on contribution %(.), with no noise function!\n"/>
    <admst:assert test="[rhs/tree/datatypename='function']" format="xyceNoiseContribution called on contribution %(.) whose rhs is not a simple noise function!\n"/>
    <admst:choose>
      <admst:when test="[rhs/tree/name='white_noise']">
        <admst:variable name="theReturnName" select="white"/>
      </admst:when>
      <admst:when test="[rhs/tree/name='flicker_noise']">
        <admst:variable name="theReturnName" select="flicker"/>
      </admst:when>
    </admst:choose>
    <admst:variable name="theReturnName" select="%($theReturnName)_%(lhs/branch/pnode)_%(lhs/branch/nnode)"/>
    <admst:choose>
      <admst:when test="[rhs/tree/name='white_noise' and count(rhs/tree/arguments)=2]">
        <admst:return name="givenName" value="%(rhs/tree/arguments[2])"/>
      </admst:when>
      <admst:when test="[rhs/tree/name='flicker_noise' and count(rhs/tree/arguments)=3]">
        <admst:return name="givenName" value="%(rhs/tree/arguments[3])"/>
      </admst:when>
    </admst:choose>
    <admst:return name="noiseName" value="$theReturnName"/>
  </admst:template>
  <!--
   =================================================================-
   xyceAnalogFunctionDeclaration
    Given an analog function, return a declaration for putting in
    the header file.
   =================================================================-
  -->
  <admst:template match="xyceAnalogFunctionDeclaration">
    <admst:value-of select="name"/>
    <admst:variable name="function" select="%s"/>
    <admst:apply-templates
       select="."
       match="verilog2CXXtype"/>
    <admst:text format=" $function("/>
    <admst:join
       select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]"
       separator=", ">
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:if test="[output='yes']">
        <admst:text format="&amp; "/>
      </admst:if>
      <admst:text format=" %(name)"/>
    </admst:join>
    <admst:text format=");\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceAnalogFunctionDefinition
   Given an analog function, return a non-templated definition of
   the function (not just a declaration)
   =================================================================-
  -->
  <admst:template match="xyceAnalogFunctionDefinition">
    <admst:variable name="function" select="%(name)"/>
    <!-- save the return type -->
    <admst:variable name="returnType" select="%(type)"/>


    <!-- must output variables defined as input, output, or inout, but not
         the one that has the same name as the function -->
    <admst:apply-templates
       select="."
       match="verilog2CXXtype"/>
    <admst:text format=" $function("/>
    <admst:join
       select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]"
       separator=", ">
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <!-- only pass by reference if it's an output variable. -->
      <admst:if test="[output='yes']">
        <admst:text format="&amp; "/>
      </admst:if>
      <admst:text format=" %(name)"/>
    </admst:join>
    <admst:text format=")\n"/>
    <admst:text format="{\n"/>

    <admst:apply-templates select="." match="verilog2CXXtype"/>
    <admst:text format=" %($function);\n"/>

    <admst:for-each select="variable[input='no' and output='no']">
      <admst:text format="%(verilog2CXXtype(.)) "/>
      <admst:text format="%(name);\n"/>
    </admst:for-each>
    <admst:apply-templates select="tree" match="%(adms/datatypename)"/>
    <admst:text format="return(%(name));\n"/>
    <admst:text format="}\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceCopyModelVars
     given a module, generate code for assuring that instance vars
     that override model vars get appropriate defaults
   =================================================================-
  -->
  <admst:template match="xyceCopyModelVars">
    <admst:for-each select="variable[parametertype='instance' and exists(attribute[name='xyceAlsoModel']) and input='yes']">
      <admst:text format="   if (!(given(&quot;%(name)&quot;)))\n"/>
      <admst:text format="   {\n"/>
      <admst:text format="      %(name) = model_.%(name);\n"/>
      <admst:text format="   }\n"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceRegisterJacLIDs
     given a module, generate code for initializing jacobian LIDs
   =================================================================-
  -->
  <admst:template match="xyceRegisterJacLIDs">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:text format="  IntPair jacLoc;\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationNumber" select="%(position(.)-1)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(row/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(column/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    jacLoc = pairToJacStampMap[IntPair(%(xyceNodeConstantName(row)/[name='nodeConstant']/value),%(xyceNodeConstantName(column)/[name='nodeConstant']/value))];\n"/>
        <admst:text format="    %(xyceJacobianOffsetName(.)) = jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

      <!-- set up pointers for extra columns due to branches-->
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:variable name="theNode" select="%(.)"/>
      <admst:for-each select="@branchDeps">
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%($theNodeName))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    jacLoc=pairToJacStampMap[IntPair(%(xyceNodeConstantName($theNode)/[name='nodeConstant']/value),%(xyceBranchConstantName(.)/[name='branchConstant']/value))];\n"/>
        <admst:text format="    A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset = jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

    </admst:for-each>

    <!-- Now we need to generate the pointers for the extra rows for branch
         equations -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:variable name="theBranch" select="%(.)"/>
      <admst:for-each select="@nodeDeps">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    jacLoc = pairToJacStampMap[IntPair(%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value),%(xyceNodeConstantName(.)/[name='nodeConstant']/value))];\n"/>
        <admst:text format="    A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>

      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    jacLoc = pairToJacStampMap[IntPair(%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value),%(xyceBranchConstantName(.)/[name='branchConstant']/value))];\n"/>
        <admst:text format="    A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset=jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
      </admst:for-each>
    </admst:for-each>
  </admst:template>


  <!--
   =================================================================-
   xyceSetupPointers
     given a module, generate code for initializing jacobian LIDs
   =================================================================-
  -->
  <admst:template match="xyceSetupPointers">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationNumber" select="%(position(.)-1)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(row/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(column/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    %(xycedFdXPtrName(.)) = &amp;(dFdx[%(xyceNodeLIDVariable(row))][%(xyceJacobianOffsetName(.))]);\n"/>
        <admst:text format="    %(xycedQdXPtrName(.)) = &amp;(dQdx[%(xyceNodeLIDVariable(row))][%(xyceJacobianOffsetName(.))]);\n"/>
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

      <!-- set up pointers for extra columns due to branches-->
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:variable name="theNode" select="%(.)"/>
      <admst:for-each select="@branchDeps">
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%($theNodeName))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr = &amp;(dFdx[%(xyceNodeLIDVariable($theEquation))][A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset]);\n"/>
        <admst:text format="    q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr = &amp;(dQdx[%(xyceNodeLIDVariable($theEquation))][A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset]);\n"/>
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

    </admst:for-each>

    <!-- Now we need to generate the pointers for the extra rows for branch
         equations -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:variable name="theBranch" select="%(.)"/>
      <admst:for-each select="@nodeDeps">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr = &amp;(dFdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset]);\n"/>
        <admst:text format="    q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr =  &amp;(dQdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset]);\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>

      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr=&amp;(dFdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset]);\n"/>
        <admst:text format="    q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr=&amp;(dQdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset]);\n"/>
      </admst:for-each>
    </admst:for-each>

  </admst:template>


  <!--
   =================================================================-
   xyceGenerateJacStamp
     given a module, generate code for initializing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceGenerateJacStamp">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:text format="    jacStamp.resize(%(count(node[grounded='no'])));\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:text format="    jacStamp[$theEquationConstant].resize(%(count($theModule/jacobian[row/name='$theEquationName'])+count(@branchDeps)));\n"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    jacStamp[$theEquationConstant][%(position(.)-1)] = %(xyceNodeConstantName(column)/[name='nodeConstant']/value);\n"/>
      </admst:for-each>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format="    // Extra columns for dependence on branches\n"/>
        <admst:text format="    {\n      int tempOffset=0;\n"/>
        <admst:for-each select="@branchDeps">
        <admst:text format="    jacStamp[$theEquationConstant][%(count($theModule/jacobian[row/name='$theEquationName']))+(tempOffset++)] = %(xyceBranchConstantName(.)/[name='branchConstant']/value);\n"/>
        </admst:for-each>
        <admst:text format="    }\n\n"/>
      </admst:if>

    </admst:for-each>
    <admst:apply-templates select="." match="xyceAugmentJacStamp"/>
  </admst:template>

  <!--
   =================================================================-
   xyceGenerateJacStamp2
     given a module, generate code for initializing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceGenerateJacStamp2">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:text format="PairVector jacobianElements;\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    jacobianElements.push_back(IntPair($theEquationConstant,%(xyceNodeConstantName(column)/[name='nodeConstant']/value)));\n"/>
      </admst:for-each>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format="    // Extra columns for dependence on branches\n"/>
        <admst:for-each select="@branchDeps">
        <admst:text format="    jacobianElements.push_back(IntPair($theEquationConstant,%(xyceBranchConstantName(.)/[name='branchConstant']/value)));\n"/>
        </admst:for-each>
      </admst:if>

    </admst:for-each>

    <admst:if test="[not(nilled(@extraUnknowns))]">
      <admst:text format="    // Jacobian rows for branch equations\n"/>
    </admst:if>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="theRow" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
      <admst:variable name="theBranchName" select="%(.)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="jacobianElements.push_back(IntPair($theRow,%(xyceNodeConstantName(.)/[name='nodeConstant']/value)));   // Branch eqn %($theBranchName) - node %(./name)\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="jacobianElements.push_back(IntPair($theRow,%(xyceBranchConstantName(.)/[name='branchConstant']/value))); // Branch eqn %($theBranchName) - branch var %(.)\n"/>
      </admst:for-each>
    </admst:for-each>

  </admst:template>


  <!--
   =================================================================-
   xyceAugmentJacStamp
     given a module, generate code for adding branch equations/variables
     to an existing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceAugmentJacStamp">

<!--
    <admst:for-each select="@extraJac1">
      <admst:variable name="theRow" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
      <admst:variable name="theRowName" select="%(name)"/>
      //Augment jacobian row for %($theRowName)
    {
      int rowsize;
      int tempColOffset=0;
      rowsize=jacStamp[%($theRow)].size();
      jacStamp[%($theRow)].resize(rowsize+%(count(@branchDeps)));
      <admst:for-each select="@branchDeps">
      jacStamp[%($theRow)][rowsize+(tempColOffset++)] = %(xyceBranchConstantName(.)/[name='branchConstant']/value); // eqn %($theRowName) - branch var %(.)
      </admst:for-each>
    }
    </admst:for-each>
-->
    <admst:if test="[not(nilled(@extraUnknowns))]">
      <admst:text format="    // Jacobian rows for branch equations\n"/>
    </admst:if>
    <admst:for-each select="@extraUnknowns">
    {
      int jacsize=jacStamp.size();
      jacStamp.resize(jacsize+1);
      <admst:variable name="theRow" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
      <admst:variable name="theBranchName" select="%(.)"/>
      jacStamp[$theRow].resize(%(count(@nodeDeps)+count(@branchDeps)));
      int tempCol = 0;
      <admst:for-each select="@nodeDeps">
      jacStamp[$theRow][tempCol++] = %(xyceNodeConstantName(.)/[name='nodeConstant']/value);   // Branch eqn %($theBranchName) - node %(./name)
      </admst:for-each>
      <admst:for-each select="@branchDeps">
      jacStamp[$theRow][tempCol++] = %(xyceBranchConstantName(.)/[name='branchConstant']/value); // Branch eqn %($theBranchName) - branch var %(.)
      </admst:for-each>
    }
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceLabelNoiseContributions
   Add a "#noiseContIndex" variable to each contribution that has
   noise.  This will be used later to index into a vector of
   contributions.
   The thing passed in should be a module.
   =================================================================-
  -->
  <admst:template match="xyceLabelNoiseContributions">
    <admst:for-each select="contribution[whitenoise='yes' or flickernoise='yes']">
      <admst:value-to select="#noiseContIndex" value="%(position(.)-1)"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   collectBranchDepends
   Given a branch (which is assumed to have an associated
   branch variable due to use of flow probes and/or potential sources),
   count up how many jacobian columns should be allocated for the
   associated branch equation.  When returns, /module/@countNodes
   will list all the nodes this branch equation depends on (through
   potential probes) and /module/@countBranches will list the branch
   flows it depends on (through flow probes).
   =================================================================-
   -->
  <admst:template match="collectBranchDepends">
    <admst:variable name="thePnode" select="%(pnode)"/>
    <admst:variable name="theNnode" select="%(nnode)"/>
    <admst:reset select="/module/@countNodes"/>
    <admst:reset select="/module/@countBranches"/>
    <admst:for-each select="/module/contribution[lhs/branch/pnode=$thePnode and lhs/branch/nnode=$theNnode]">
      <admst:for-each select="rhs/probe">
        <admst:choose>
          <!-- potential probes on the RHS add nodal dependencies to
               the branch equation-->
          <admst:when test="[nature=discipline/potential]">
            <admst:push into="/module/@countNodes" select="branch/pnode" onduplicate="ignore"/>
            <admst:if test="[branch/nnode/grounded='no']">
              <admst:push into="/module/@countNodes" select="branch/nnode" onduplicate="ignore"/>
            </admst:if>
          </admst:when>
          <!-- flow probes on the RHS add branch dependencies to the
               branch equation -->
          <admst:otherwise>
            <admst:push into="/module/@countBranches" select="branch" onduplicate="ignore"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
      <!-- Finally, if this is a potential source, the branch equation
           also depends on the nodes of the lhs.  If it's a flow source,
           the branch equation depends on the flow variable.
      -->
      <admst:choose>
        <admst:when test="[lhs/nature=lhs/discipline/potential]">
          <admst:push into="/module/@countNodes" select="lhs/branch/pnode" onduplicate="ignore"/>
          <admst:if test="[lhs/branch/nnode/grounded='no']">
            <admst:push into="/module/@countNodes" select="lhs/branch/nnode" onduplicate="ignore"/>
            </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:push into="/module/@countBranches" select="lhs/branch" onduplicate="ignore"/>
        </admst:otherwise>
      </admst:choose>

    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   =================================================================-
   Basic templates for processing verilog

   =================================================================-
   =================================================================-

   =================================================================-
   collectAssignedVariables
   Given a node of the ADMS data tree, determine all variables that
   appear on the left-hand side of assignments in that node and all
   of its children.  This is done recursively.

   The list of all those variables is deposited in the @assignedVars
   array of the *PARENT* of the node passed in.  This is fishy, and
   I wish I could figure out a way to do it without pushing the data
   up above the node we start with.

   Since we push data upward, it's probably best not to call this on
   the top level "analog/code" node of the tree, but rather loop over
   all of that node's children instead if one needs to process it.
   =================================================================-
  -->
<admst:template match="collectAssignedVariables">
  <admst:choose>
    <!-- ASSIGNMENT -->
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="../@assignedVars" select="lhs" onduplicate="ignore"/>

      <!-- now try to collect "assignments" that are just output vars
           of analog function calls -->
      <admst:value-of select=".."/>
      <admst:variable name="theGlobalAssignedVarsTarget" select="%p"/>
      <admst:apply-templates select="rhs" match="collectAssignedVariables"/>
      <admst:variable name="theGlobalAssignedVarsTarget"/>

    </admst:when>
    <!-- BLOCK -->
    <admst:when test="adms[datatypename='block']">
      <!-- recurse -->
      <admst:for-each select="item">
        <admst:apply-templates select="." match="collectAssignedVariables"/>
      </admst:for-each>
      <!-- the result should be that our current node, which is a block,
           has received all the variables of all its children listed in
           @assignedVars -->
    </admst:when>
    <!-- CONDITIONAL -->
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="collectAssignedVariables"/>
      <admst:apply-templates select="else" match="collectAssignedVariables"/>
    </admst:when>
    <!-- WHILELOOP -->
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="collectAssignedVariables"/>
    </admst:when>
    <!-- FORLOOP -->
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="initial" match="collectAssignedVariables"/>
      <admst:apply-templates select="forblock" match="collectAssignedVariables"/>
      <admst:apply-templates select="update" match="collectAssignedVariables"/>
    </admst:when>
    <!-- CASE -->
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="caseitem" match="collectAssignedVariables"/>
    </admst:when>
    <!-- caseitem -->
    <admst:when test="adms[datatypename='caseitem']">
      <admst:apply-templates select="code" match="collectAssignedVariables"/>
    </admst:when>
    <!-- CODE -->
    <admst:when test="adms[datatypename='code']">
      <admst:apply-templates select="item" match="collectAssignedVariables">
      </admst:apply-templates>
    </admst:when>
    <!-- none of the following types can do assignment -->
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>

    <!-- All of these things can happen only if we are being called on the
         RHS of an assignment, and we're probing only for analog function
         calls that have output vars (and therefore "assign" to those vars)
    -->
    <admst:when test="adms[datatypename='expression']">
      <admst:apply-templates select="tree" match="collectAssignedVariables"/>
    </admst:when>
    <admst:when test="adms[datatypename='expression']">
      <admst:apply-templates select="tree" match="collectAssignedVariables"/>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="collectAssignedVariables"/>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="collectAssignedVariables"/>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="collectAssignedVariables"/>
    </admst:when>

    <!-- Now, the real place where new assigned vars might exist -->
    <admst:when test="adms[datatypename='function']">
      <admst:apply-templates select="arguments" match="collectAssignedVariables"/>
      <!-- Now, if we're an analog function, do some real work on the
           output variables, if there are any -->
      <admst:if test="[definition/datatypename='analogfunction']">
        <admst:variable name="theFunction" select="%(.)"/>
        <admst:for-each select="definition/variable">
          <admst:if test="[(output='yes') and (name!=$theFunction/name)]">
            <admst:variable name="thePosition" select="%(position(.)-1)"/>
            <!-- <admst:message format="Found an output var %($theFunction/arguments[position(.)=$thePosition]/name) to mark as assigned\n"/> -->
            <admst:push into="$theGlobalAssignedVarsTarget/@assignedVars" select="$theFunction/arguments[position(.)=$thePosition]" onduplicate="ignore"/>
          </admst:if>
        </admst:for-each>
      </admst:if>
    </admst:when>

    <!-- these do nothing -->
    <admst:when test="adms[datatypename='variable' or datatypename='number' or datatypename='string' or datatypename='probe']"/>

    <admst:otherwise>
      <admst:fatal format="'datatypename=%(adms/datatypename)':collectAssignedVariables cannot process this type, should not be reached.\n"/>
    </admst:otherwise>
  </admst:choose>
  <!-- At this point, we have processed our own and our children's variables,
       and our @assignedVars array contains all the variables we or our
       children have assigned into.  Pass this information up to our parent
       if we haven't already done it (because we're an assignment). -->
  <admst:if test="adms[datatypename!='assignment']">
    <admst:variable name="parent" select="%(..)"/>
    <admst:variable name="this" select="%(.)"/>
    <admst:for-each select="@assignedVars">
      <!-- <admst:message format="Got something other than assignment (%($this/datatypename)), pushing %(.) into parent which is of type %($parent/datatypename)\n"/> -->
      <admst:variable name="thisName" value="%(name)"/>
      <!-- not enough to push with 'onduplicate="ignore"' because the actual
           variable node has more info than just the name, and different
           instances aren't actually duplicates just because the name is the
           same. This would result in multiple declarations if we're not
           careful. -->
      <!-- <admst:message format="Want to push variable %(.) into parent.  This variable is defined in environment of type %(block/adms/datatypename) and scope is %(scope).\n"/> -->
      <admst:variable name="pushUp" string="yes"/>
      <admst:if test="[$this/adms/datatypename='block' and block=$this]">
        <!-- <admst:message format="I think this should be local and we shouldn't push up\n"/> -->
        <admst:variable name="pushUp" string="no"/>
      </admst:if>
      <admst:if test="[$pushUp = 'yes']">
          <admst:push into="$parent/@assignedVars" select="." onduplicate="ignore"/>
      </admst:if>
    </admst:for-each>
  </admst:if>
</admst:template>

<!--
 =================================================================-
 collectInterdependentParams
 Given a module, run through all the parameter variables it has and
 mark as "#dependent='yes'" any that have default values that depend
 on other variables in any way.

 These variables cannot have their defaults determined by their addPar
 calls, and must have their defaults set (if not given in the netlist)
 at constructor time instead.

 This template is intended to be called early in processing, like
 collectLimters and collectCollapsibles
 =================================================================-
 -->
 <admst:template match="collectInterdependentParams">
   <admst:for-each select="variable[(parametertype='instance' or parametertype='model') and input='yes' and exists(default)]">
     <admst:apply-templates select="default" match="recursiveDetectVariableDependence">
       <admst:if test="[returned('isDependent')/value = 'yes']">
         <admst:value-to select="../#dependent" string="yes"/>
       </admst:if>
     </admst:apply-templates>
   </admst:for-each>
 </admst:template>

<!--
 =================================================================-
 collectParamDependence
 Given a variable, run through everything it depends on, and check
 if it depends on any parameters

This is necessary because ADMS only stores parameter dependence
that is explicit.   Parameter dependence that is inherited from
other variables does not get propagated into a variable's
"variarable" structure
 =================================================================-
 -->
 <admst:template match="collectParamDependence">
   <admst:variable name="isDependent" value="no"/>
   <admst:apply-templates select="." match="recursiveDetectParameterDependence">
     <admst:if test="[returned('isDependent')/value = 'yes']">
       <admst:value-to select="#Pdependent" string="yes"/>
     </admst:if>
   </admst:apply-templates>
 </admst:template>

<!--
 =================================================================-
 recursiveDetectVariableDependence
 Given a node, try to determine if the expression it represents has
 dependence on any variables
 =================================================================-
 -->
 <admst:template match="recursiveDetectVariableDependence">
 <admst:choose>
   <admst:when test="[datatypename='number']">
     <admst:return name="isDependent" value="no"/>
   </admst:when>
   <admst:when test="[datatypename='variable']">
     <admst:return name="isDependent" value="yes"/>
   </admst:when>
   <admst:when test="[datatypename='expression']">
     <admst:apply-templates select="tree" match="recursiveDetectVariableDependence">
       <admst:return name="isDependent" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
   </admst:when>
   <admst:when test="[datatypename='mapply_unary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:return name="isDependent" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
   </admst:when>
   <admst:when test="[datatypename='mapply_binary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg2" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:choose>
       <admst:when test="[$isDependent1='yes' or $isDependent2='yes']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:return name="isDependent" value="no"/>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:when test="[datatypename='mapply_ternary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg2" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg3" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent3" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:choose>
       <admst:when test="[$isDependent1='yes' or $isDependent2='yes' or $isDependent3='yes']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:return name="isDependent" value="no"/>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:when test="[datatypename='function']">
     <admst:choose>
       <admst:when test="[name='\$simparam']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:variable name="isFuncDependent" value="no"/>
         <admst:apply-templates select="arguments" match="recursiveDetectVariableDependence">
           <admst:if test="[returned('isDependent')/value = 'yes']">
             <admst:variable name="isFuncDependent" value="yes"/>
           </admst:if>
         </admst:apply-templates>
         <admst:choose>
           <admst:when test="[$isFuncDependent='yes']">
             <admst:return name="isDependent" value="yes"/>
           </admst:when>
           <admst:otherwise>
             <admst:return name="isDependent" value="no"/>
           </admst:otherwise>
         </admst:choose>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:otherwise>
     <admst:return name="isDependent" value="no"/>
   </admst:otherwise>
 </admst:choose>
 </admst:template>

<!--
 =================================================================-
 recursiveDetectParameterDependence
 Given any node, try to determine if the expression it represents has
 dependence on any parameters
 =================================================================-
 -->
<admst:template match="recursiveDetectParameterDependence">
  <admst:variable name="isDependent" value="no"/>
  <admst:choose>
    <!-- if we've already been through this and already flagged as pdep, don't do again -->
    <admst:when test="[exists(#Pdependent)]">
      <admst:variable name="isDependent" value="yes"/>
    </admst:when>
    <admst:when test="[datatypename='number']">
      <!-- no changie da value.  -->
    </admst:when>
    <admst:when test="[datatypename='string']">
      <!-- no changie da value.  -->
    </admst:when>
    <admst:when test="[(datatypename='variable' or datatypename='variableprototype') and type='real']">
      <admst:choose>
        <!-- This variable is a real parameter or explicitly depends on one or more real parameters -->
        <admst:when test="[exists(#Pdependent)]">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:when test="[input='yes' or exists(variable[input='yes'])]">
          <admst:variable name="isDependent" value="yes"/>
          <admst:value-to select="#Pdependent" value="yes"/>
        </admst:when>
        <!-- This variable does not explicitly depend on one or more parameters,
             but does depend on one or more non-parameter variables-->
        <admst:when test="[count(variable) > 0]">
          <admst:for-each select="variable">
            <admst:if test="[not (name=../name or (exists(#DONOTLOOP) and #DONOTLOOP='yes'))]">
              <!-- temporarily mark this variable as in process-->
              <admst:value-to select="#DONOTLOOP" value="yes"/>
              <admst:apply-templates select="." match="recursiveDetectParameterDependence">
                <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
                <admst:if test="[$isDependent1='yes']">
                  <admst:variable name="isDependent" value="yes"/>
                  <admst:value-to select="#Pdependent" value="yes"/>
                </admst:if>
              </admst:apply-templates>
              <!--clear the donotloop flag, seems to be no way to delete
                  a croixvar-->
              <admst:value-to select="#DONOTLOOP" value="no"/>
            </admst:if>
          </admst:for-each>
        </admst:when>
        <!-- This variable does not explicitly depend on one or more parameters,
             and does not depend other non-parameter variables-->
        <admst:otherwise>
          <!-- <admst:message format="recursiveDetectParameterDependence %(name) is independent of variables altogether\n"/>-->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='expression']">
      <admst:apply-templates select="tree" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
        <admst:if test="[$isDependent1='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:if>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
        <admst:if test="[$isDependent1='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:if>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[$isDependent1='yes' or $isDependent2='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <!-- no changie da value -->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent3" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[$isDependent1='yes' or $isDependent2='yes' or $isDependent3='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <!-- just leave isDependent where it is -->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:choose>
        <admst:when test="[name='\$simparam']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="isFuncDependent" value="no"/>
          <admst:apply-templates select="arguments" match="recursiveDetectParameterDependence">
            <admst:if test="[returned('isDependent')/value = 'yes']">
              <admst:variable name="isFuncDependent" value="yes"/>
            </admst:if>
          </admst:apply-templates>
          <admst:if test="[$isFuncDependent='yes']">
            <admst:variable name="isDependent" value="yes"/>
          </admst:if>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='probe']">
      <!-- no changie da value -->
    </admst:when>
    <admst:when test="[(datatypename='variable' or datatypename='variableprototype') and type!='real']">
      <!-- ignore it: sensitivity is never run on integer vars -->
    </admst:when>
    <admst:otherwise>
      <admst:message format=" recursiveDetectParameterDependence on %(.) unimplemented datatype %(datatypename)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="[$isDependent='yes']">
    <admst:value-to select="#Pdependent" value="yes"/>
  </admst:if>
  <admst:return name="isDependent" value="$isDependent"/>
</admst:template>

<!--
 =================================================================-
 recursiveDetectProbeDependence
 Given any node, recursively populate $probeList (a path to an @
 var) with the probes it depends on.
 =================================================================-
 -->
<admst:template match="recursiveDetectProbeDependence">
  <admst:choose>
    <!-- if this is one of the datatypes that has its own probe list stored by
         ADMS itself, just copy that and be done-->
    <admst:when test="[datatypename='variable' or datatypename='expression']">
      <admst:if test="[not(nilled(probe))]">
        <admst:push into="$probeList" select="probe" onduplicate="ignore"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="recursiveDetectProbeDependence"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="recursiveDetectProbeDependence"/>
      <admst:apply-templates select="arg2" match="recursiveDetectProbeDependence"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="recursiveDetectProbeDependence"/>
      <admst:apply-templates select="arg2" match="recursiveDetectProbeDependence"/>
      <admst:apply-templates select="arg3" match="recursiveDetectProbeDependence"/>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:apply-templates select="arguments" match="recursiveDetectProbeDependence"/>
    </admst:when>
    <admst:otherwise>
      <!-- do nothing -->
    </admst:otherwise>
  </admst:choose>
</admst:template>

 <!--
 =================================================================-
 collectLimiters
 Given a module, create an "arobavar" (@limiters) containing all the
 assignments in which the verilog limiter function is called.
 Also, create another arobavar (@limitedProbes) containing just
 the probes that are limited by those assignments.
 This template is called early in processing, and the arrays it
 produces will be used to produce the various bits of code needed
 to implement voltage limiting in the device.

  Example:  <admst:apply-templates select="/module" match="collectLimiters"/>

  will result in there being a /module/@limiters and /module/@limitedProbes
 =================================================================-
-->

<admst:template match="collectLimiters">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:for-each select="assignment[rhs/function/name='\$limit']">
    <admst:push into="../@limiters" select="." onduplicate="ignore"/>
  </admst:for-each>
  <admst:for-each select="@limiters">
    <admst:for-each select="rhs/probe">
      <admst:value-to select="#limited" string="yes"/>
      <admst:if test="[../function/[name='\$limit']/arguments[2]/datatypename='string']">
        <admst:if test="[../function/[name='\$limit']/arguments[2]/value='typedpnjlim' or ../function/[name='\$limit']/arguments[2]/value='typedpnjlim_new' or ../function/[name='\$limit']/arguments[2]/value='typeddummy' or ../function/[name='\$limit']/arguments[2]/value='typedfetlim' or (../function/[name='\$limit']/arguments[3]/datatypename='string' and ../function/[name='\$limit']/arguments[3]/value='typed')]">
          <admst:value-to select="#typed" string="yes"/>
        </admst:if>
      </admst:if>
      <admst:push into="$thisModule/@limitedProbes" select="." onduplicate="ignore"/>
    </admst:for-each>
  </admst:for-each>
</admst:template>

<!--
 =================================================================-
 collectCollapsibles
 This template is intended to be called very early in verilog processing.
 It runs through all contributions and tries to identify those that
 allow some node to be collapsed into another (i.e. contributions of the
 form "V(a,b) <+ 0;"
 If it locates such a collapsible, it adds a "#collapsible='yes'" variable
 to the node, and a "@collapsesTo" variable containing the node to which
 this one could collapse.
 In considering which node to collapse of a,b, if there's only one internal
 in the pair, that's the collapsible one.  If both are internal, it'll
 collapse the negative into the positive.
 =================================================================-
 -->
<admst:template match="collectCollapsibles">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:if test="[not exists(#calledCollectCollapsibles)]">
    <admst:for-each select="$thisModule/contribution[lhs/discipline/potential=lhs/nature]">
      <admst:if test="[(rhs/datatypename='expression' and rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0')) or (rhs/datatypename='number' and (rhs/value='0' or rhs/value='0.0'))]">
        <admst:choose>
          <admst:when test="lhs/branch[grounded='no']">
            <admst:choose>
              <admst:when test="lhs/branch/nnode[location='internal' or (location='external' and exists(#optional))]">
                <!-- <admst:if test="[lhs/branch/nnode/location='internal']">
                  <admst:warning format="collectCollapsibles found internal nnode %(lhs/branch/nnode/name) it wants to collapse into %(lhs/branch/pnode/name)\n"/>
                </admst:if> -->
                <admst:if test="[lhs/branch/nnode/location='external']">
                   <admst:warning format="while processing collapse contributions %(.):  found optional external node %(lhs/branch/nnode/name) we want to collapse into %(lhs/branch/pnode/name).  This might be dangerous and should only work if the optional node is not given at run time.\n"/>
                </admst:if>
                <!-- nnode is internal, collapse it into pnode -->
                <admst:if test="[exists(lhs/branch/nnode/#collapsible) and lhs/branch/nnode/#collapsible='yes']">
                  <!-- nnode is already collapsible to something, so don't just
                       blindly collapse it to pnode... check that pnode is
                       not collapsible, and collapse p into n if not -->
                  <!-- <admst:warning format="    %(lhs/branch/nnode/name) is already collapsible onto ...%(lhs/branch/nnode/@collapsesTo/name)\n"/> -->
                  <admst:choose>
                    <admst:when test="[not(exists(lhs/branch/pnode/#collapsible))]">
                      <!-- <admst:warning format="    but %(lhs/branch/pnode/name) is not collapsible, so maybe we can collapse it onto %(lhs/branch/nnode/name) instead of the other way around...\n"/> -->
                      <admst:choose>
                        <admst:when test="[lhs/branch/pnode/name=lhs/branch/nnode/@collapsesTo/name]">
                          <!-- <admst:warning format="But that is OK, because we were already going to do that collapsing!\n"/> -->
                        </admst:when>
                        <admst:when test="[lhs/branch/pnode/location='external' and not(exists(lhs/branch/pnode/#optional))]">
                          <!-- <admst:warning format="     unfortunately, that is external... rearranging\n"/> -->
                          <!-- <admst:warning format="     we would make %(lhs/branch/nnode/@collapsesTo/name) collapse to %(lhs/branch/nnode/name) instead, and make %(lhs/branch/nnode/name) collapse to %(lhs/branch/pnode/name) instead\n"/> -->
                          <admst:if test="[lhs/branch/nnode/@collapsesTo/location='external']">
                            <admst:fatal format="Fatal error with collapse contribution %(.) --- we would wind up collapsing an external node onto an internal!\n"/>
                          </admst:if>
                          <admst:variable name="saveCollapse" select="%(lhs/branch/nnode/@collapsesTo)"/>
                          <admst:if test="[exists($saveCollapse/#collapsible)]">
                            <admst:fatal format="fatal error with collapse contribution %(.) --- tried to rearrange collapsing of %(lhs/branch/nnode/name) and %($saveCollapse/name) but the latter is already collapsible.\n"/>
                          </admst:if>
                          <admst:value-to select="$saveCollapse/#collapsible" string="yes"/>
                          <admst:push into="$saveCollapse/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
                          <admst:reset select="lhs/branch/nnode/@collapsesTo"/>
                          <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
                        </admst:when>
                        <admst:otherwise>
                          <admst:if test="[lhs/branch/pnode/location='external' and exists(lhs/branch/pnode/#optional)]">
                            <admst:warning format="   Issue while processing %(.): trying to collapse optional external node %(lhs/branch/pnode/name) onto node %(lhs/branch/nnode/name).  This can only work at run time if the optional node is not given when collapse is needed.\n"/>
                          </admst:if>
                          <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
                          <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
                        </admst:otherwise>
                      </admst:choose>
                    </admst:when>
                    <admst:otherwise>
                      <!-- this is only an error if trying to collapse nnode
                           into something OTHER than what it already collapses
                           to.  -->
                      <admst:if test="[(lhs/branch/pnode/name != lhs/branch/nnode/@collapsesTo/name) and (lhs/branch/nnode/name != lhs/branch/pnode/@collapsesTo/name)]">
                        <admst:error format="Problem with contribution: %(.)\nNot yet supported: collapsing a node multiply... both %(lhs/branch/nnode/name) and %(lhs/branch/pnode/name) are already collapsible.  %(lhs/branch/nnode/name) collapses already into %(lhs/branch/nnode/@collapsesTo) and %(lhs/branch/pnode/name) collapses already into %(lhs/branch/pnode/@collapsesTo)\n"/>
                      </admst:if>
                    </admst:otherwise>
                  </admst:choose>
                </admst:if>
                <admst:if test="[not(exists(lhs/branch/nnode/#collapsible))]">
                  <!-- nnode is not already collapsible, collapse it into p -->
                  <admst:value-to select="lhs/branch/nnode/#collapsible" string="yes"/>
                  <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
                </admst:if>
              </admst:when>
              <admst:when test="lhs/branch/pnode[location='internal']">
                <!-- we only get here if nnode was external -->
                <admst:choose>
                  <admst:when test="[exists(lhs/branch/pnode/#collapsible)]">
                    <admst:fatal format=" Collapse contribution '%(.)' requests collapse of internal node %(lhs/branch/pnode/name) onto external node %(lhs/branch/nnode/name), but %(lhs/branch/pnode/name) is already collapsible to %(lhs/branch/pnode/@collapsesTo) as a result of earlier collapses, and we cannot proceed!\n"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
                    <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="lhs/branch/nnode/[grounded='yes']">
                <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
                <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
              </admst:when>
              <admst:when test="lhs/branch/pnode/[grounded='yes']">
                <admst:value-to select="lhs/branch/nnode/#collapsible" string="yes"/>
                <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
              </admst:when>
            </admst:choose>

          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:for-each>
    <admst:value-to select="$thisModule/#calledCollectCollapsibles" string="yes"/>
  </admst:if>
</admst:template>

<!--
 =================================================================-
 declareCollapsibleBools
 For each node that may be collapsed, generate a declaration of a bool
 that will be used by Xyce to tell whether to collapse it or not.
 Pass the module in the select field of the apply-templates call.
 =================================================================-
 -->
<admst:template match="declareCollapsibleBools">
  <admst:if test="[count(node[#collapsible='yes'])>0]">
    <admst:text format="     // bools for collapsing nodes\n"/>
    <admst:for-each select="node[#collapsible='yes']">
      <admst:text format="     bool collapseNode_%(name);\n"/>
    </admst:for-each>
  </admst:if>
</admst:template>

  <!--
      recursiveFindContrib
      This template is passed any item from the analog/code block,
      and recurses downward until it finds a contribution of the form
      V(branch) <+ 0;   (or 0.0)
      When it finds one, it recurses upwards through the ADMS data tree
      using the upwardRecurseCheckDepend template.
  -->

  <admst:template match="recursiveFindContrib">
    <admst:choose>
      <admst:when test="adms[datatypename='block']">
        <admst:apply-templates select="item" match="recursiveFindContrib"/>
      </admst:when>
      <admst:when test="adms[datatypename='conditional']">
        <admst:apply-templates select="then" match="recursiveFindContrib"/>
        <admst:apply-templates select="else" match="recursiveFindContrib"/>
      </admst:when>
      <admst:when test="adms[datatypename='case']">
        <admst:for-each select="caseitem">
          <admst:apply-templates select="code" match="recursiveFindContrib"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="adms[datatypename='contribution']">
        <admst:if test="[(lhs/discipline/potential=lhs/nature) and ((rhs/datatypename='expression' and rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0')) or (rhs/datatypename='number' and (rhs/value='0' or rhs/value='0.0')))]">
          <admst:apply-templates select="." match="upwardRecurseCheckDepend"/>
        </admst:if>
      </admst:when>
    </admst:choose>
  </admst:template>

  <!--
      upwardRecurseCheckDepend
      Given any ADMS data tree item, recurse UPWARD through the ADMS data
      tree.  Check that all conditionals depend only on variables of
      global_instance or global_model scope, or are input parameters.

      Flag a fatal error if any local variables are used in these
      conditional expressions.  We just flag the error, we don't
      abort, so the entire processing of the module can proceed and
      report all errors.  The caller must check the "$collapseFailure"
      variable and abort if it's "yes".

      The starting point should be a contribution that collapses nodes, e.g.
      V(branch) <+ 0;
      -->
  <admst:template match="upwardRecurseCheckDepend">
    <admst:choose>
      <admst:when test="adms[datatypename='expression']">
        <admst:for-each select="variable">
          <admst:if test="[not (input='yes' or (scope='global_instance' or scope='global_model'))]">
            <admst:warning format="Collapse error:  Node collapse conditional depends on variable %(name), which is not an input parameter and which has scope of '%(scope)'.\n\n  Only variables of global_instance or global_model scope may be used in collapse conditionals in this version of Xyce/ADMS.\n\n  To clear this error, move bias-independent intialization of %(name) into an '@(initial_instance)' or '@(initial_model) block.\n"/>
            <admst:variable name="collapseFailure" string="yes"/>
          </admst:if>
          <admst:if test="[OPdependent='yes']">
            <admst:warning format="  Collapse error:  Node collapse conditional depends on variable %(name) that is bias-dependent.  Collapse conditionals must be bias-independent.\n"/>
            <admst:variable name="collapseFailure" string="yes"/>
          </admst:if>
        </admst:for-each>
      </admst:when>
      <admst:when test="adms[datatypename='conditional']">
        <admst:apply-templates select="if" match="upwardRecurseCheckDepend"/>
      </admst:when>
      <admst:when test="adms[datatypename='case']">
        <admst:apply-templates select="case" match="upwardRecurseCheckDepend"/>
      </admst:when>
    </admst:choose>
    <admst:if test="[not(../adms/datatypename = 'analog' or ./adms/datatypename='expression')]">
      <admst:apply-templates select=".." match="upwardRecurseCheckDepend"/>
    </admst:if>
  </admst:template>


  <!--
      evaluateCollapse
      Emit code for evaluating when to collapse nodes.
      Only assignments that assign to variables that collapse depends on
      are emitted.
      Control structures that CONTAIN assignments that are emitted will also
      be generated, e.g.

      if (foo)
        bar=baz;

      will generate code if bar is a collapse-determining variable.

      TODO:  If we find we need to generate FOR or WHILE loops, then we
      should give up and report an error.  Handling these constructs correctly
      is too difficult, and no rational model should ever have collapse
      determination that requires it.  No currently known models do.

  -->
  <admst:template match="evaluateCollapse">
    <admst:choose>

      <!--IF/ELSE-->
      <admst:when test="[datatypename='conditional']">
        <admst:choose>
          <admst:when test="if[nilled(variable[OPdependent='yes'])]">
            <admst:choose>
              <admst:when test="if/math[dependency='constant']">
                <admst:variable name="thenOutputSomething" string="no"/>
                <admst:variable name="thenOutput" string=""/>
                <admst:variable name="elseOutputSomething" string="no"/>
                <admst:variable name="elseOutput" string=""/>
                <admst:apply-templates select="then" match="evaluateCollapse">
                  <admst:value-of select="returned('outputSomething')/value"/>
                  <admst:variable name="thenOutputSomething" select="%s"/>
                  <admst:value-of select="returned('output')/value"/>
                  <admst:variable name="thenOutput" select="%s"/>
                </admst:apply-templates>
                <admst:if test="[exists(else)]">
                  <admst:apply-templates select="else" match="evaluateCollapse">
                    <admst:value-of select="returned('outputSomething')/value"/>
                    <admst:variable name="elseOutputSomething" select="%s"/>
                    <admst:value-of select="returned('output')/value"/>
                    <admst:variable name="elseOutput" select="%s"/>
                  </admst:apply-templates>
                </admst:if>

                <admst:if test="[$thenOutputSomething='yes']">
                  <admst:variable name="output" string="if (%(processTerm(if)/[name='returnedExpression']/value))"/>
                  <admst:variable name="output" string="$output\n{\n$thenOutput\n}\n"/>
                  <admst:if test="[$elseOutputSomething='yes']">
                    <admst:variable name="output" string="$output\nelse\n{\n$elseOutput\n}\n"/>
                  </admst:if>
                  <admst:variable name="outputSomething" string="yes"/>
                </admst:if>
                <admst:if test="[$thenOutputSomething='no' and $elseOutputSomething='yes']">
                  <admst:variable name="output" string="if (!(%(processTerm(if)/[name='returnedExpression']/value)))"/>
                  <admst:variable name="output" string="$output\n{\n$elseOutput\n}\n"/>
                </admst:if>

                <admst:choose>
                  <admst:when test="[$thenOutputSomething='yes' or $elseOutputSomething='yes']">
                    <admst:return name="outputSomething" string="yes"/>
                    <admst:return name="output" string="$output"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="outputSomething" string="no"/>
                    <admst:return name="output" string=""/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="thenOutputSomething" string="no"/>
                <admst:variable name="thenOutput" string=""/>
                <admst:variable name="elseOutputSomething" string="no"/>
                <admst:variable name="elseOutput" string=""/>
                <admst:apply-templates select="then" match="evaluateCollapse">
                  <admst:value-of select="returned('outputSomething')/value"/>
                  <admst:variable name="thenOutputSomething" select="%s"/>
                  <admst:value-of select="returned('output')/value"/>
                  <admst:variable name="blockOutput" select="%s"/>
                  <admst:if test="[$thenOutputSomething = 'yes']">
                    <admst:variable name="thenOutput" string="%($blockOutput)\n"/>
                  </admst:if>
                </admst:apply-templates>
                <admst:apply-templates select="else" match="evaluateCollapse">
                  <admst:value-of select="returned('outputSomething')/value"/>
                  <admst:variable name="elseOutputSomething" select="%s"/>
                  <admst:value-of select="returned('output')/value"/>
                  <admst:variable name="blockOutput" select="%s"/>
                  <admst:if test="[$elseOutputSomething = 'yes']">
                    <admst:variable name="outputSomething" string="yes"/>
                    <admst:variable name="elseOutput" string="%($blockOutput)"/>
                  </admst:if>
                </admst:apply-templates>
                <admst:variable name="output" string="%($thenOutput)%($elseOutput)"/>
                <admst:choose>
                  <admst:when test="[$thenOutputSomething='yes' or $elseOutputSomething='yes']">
                    <admst:return name="outputSomething" string="yes"/>
                    <admst:return name="output" string="$output"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="outputSomething" string="no"/>
                    <admst:return name="output" string=""/>
                  </admst:otherwise>
                </admst:choose>

              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:return name="outputSomething" string="no"/>
            <admst:return name="output" string=""/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>

      <!-- CASE -->
      <admst:when test="[datatypename='case']">
        <admst:choose>
          <admst:when test="case[nilled(variable[OPdependent='yes'])]">
            <admst:variable name="caseOutputSomething" string="no"/>
            <admst:variable name="fullCaseOutput" string=""/>
            <admst:variable name="haveDefault" string="no"/>
            <admst:if test="[count(caseitem[defaultcase='yes'])>0]">
              <admst:variable name="haveDefault" string="yes"/>
            </admst:if>
            <admst:choose>
              <admst:when test="case/math[dependency='constant']">
                <admst:variable name="caseConditionExpr" string="%(processTerm(case)/[name='returnedExpression']/value)"/>
                <admst:for-each select="caseitem[defaultcase='no']">
                  <admst:apply-templates select="code" match="evaluateCollapse">
                    <admst:value-of select="returned('outputSomething')/value"/>
                    <admst:variable name="caseItemOutputSomething" select="%s"/>
                    <admst:value-of select="returned('output')/value"/>
                    <admst:variable name="caseItemOutput" select="%s"/>
                    <admst:if test="[$caseItemOutputSomething='yes']">
                      <admst:variable name="caseOutputSomething" string="yes"/>
                    </admst:if>
                    <!-- now assemble the conditional for output -->
                    <admst:variable name="oredCondition" string=""/>
                    <admst:for-each select="../condition">
                      <admst:apply-templates select="." match="%(datatypename)">
                        <admst:if test="[$oredCondition != '']">
                          <admst:variable name="oredCondition" string="$oredCondition || "/>
                        </admst:if>
                        <admst:variable name="oredCondition" string="$oredCondition ($caseConditionExpr == %(returned('returnedExpression')/value))"/>
                      </admst:apply-templates>
                    </admst:for-each>  <!-- condition -->
                  </admst:apply-templates>
                  <!-- add the conditional to the output -->
                  <admst:variable name="fullCaseOutput" string="$fullCaseOutput if ( $oredCondition )\n"/>
                  <admst:if test="[$caseItemOutputSomething = 'yes']">
                    <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n$caseItemOutput\n}\nelse\n"/>
                  </admst:if>
                  <admst:if test="[$caseItemOutputSomething = 'no']">
                    <admst:variable name="fullCaseOutput" string="$fullCaseOutput\n{\n // nothing to see here \n}\nelse\n"/>
                  </admst:if>
                </admst:for-each> <!-- non-default caseitem-->
                <!-- now handle a default if we have one
                     because we've been emitting all those "else" lines,
                     we will emit an empty block just to keep syntax right -->
                <admst:if test="[$haveDefault='no']">
                  <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n // there is no default \n}\n"/>
                </admst:if>
                <admst:if test="[$haveDefault='yes']">
                  <admst:for-each select="caseitem[defaultcase='yes']">
                    <admst:apply-templates select="code" match="evaluateCollapse">
                      <admst:value-of select="returned('outputSomething')/value"/>
                      <admst:variable name="caseItemOutputSomething" select="%s"/>
                      <admst:value-of select="returned('output')/value"/>
                      <admst:variable name="caseItemOutput" select="%s"/>
                      <admst:if test="[$caseItemOutputSomething='yes']">
                        <admst:variable name="caseOutputSomething" string="yes"/>
                    <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n$caseItemOutput\n}\n"/>
                      </admst:if>
                      <admst:if test="[$caseItemOutputSomething='no']">
                        <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n//nothing to see here\n}\n"/>
                      </admst:if>
                    </admst:apply-templates>
                  </admst:for-each> <!-- really just one default -->
                </admst:if>
                <admst:return name="outputSomething" string="$caseOutputSomething"/>
                <admst:return name="output" string="$fullCaseOutput"/>
              </admst:when>
              <admst:otherwise>
                <admst:error format="evaluateCollapse: case not constant, we can't handle that yet.\n"/>
                <admst:return name="outputSomething" string="no"/>
                <admst:return name="output" string=""/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
             <!-- do nothing -->
            <admst:return name="outputSomething" string="no"/>
            <admst:return name="output" string=""/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>

      <!--CONTRIBUTION-->
      <admst:when test="[datatypename='contribution']">
        <admst:choose>
          <admst:when test="lhs[discipline/potential=nature]">
            <admst:choose>
              <admst:when test="[exists(lhs/branch/nnode/#collapsible) and lhs/branch/nnode/#collapsible='yes' and lhs/branch/nnode/@collapsesTo=lhs/branch/pnode]">
                <admst:return name="output" string="collapseNode_%(lhs/branch/nnode/name) = true;\n"/>
                <admst:return name="outputSomething" string="yes"/>
              </admst:when>
              <admst:when test="[exists(lhs/branch/pnode/#collapsible) and lhs/branch/pnode/#collapsible='yes' and lhs/branch/pnode/@collapsesTo=lhs/branch/nnode]">
                <admst:return name="output" string="collapseNode_%(lhs/branch/pnode/name) = true;\n"/>
                <admst:return name="outputSomething" string="yes"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="output" string=""/>
                <admst:return name="outputSomething" string="no"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:return name="output" string=""/>
            <admst:return name="outputSomething" string="no"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>

      <!--BLOCK-->
      <admst:when test="[datatypename='block']">
        <admst:value-to select="./#tempOutput" value=""/>
        <admst:value-to select="./#tempOutputSomething" value="no"/>
        <admst:variable name="outputSomething" value="no"/>
        <admst:if test="[name != '']">
          <admst:value-to select="./#tempOutput" value="// begin block named %(name)\n"/>
        </admst:if>
        <admst:for-each select="variable[#collapseDepends='yes']">
          <admst:value-to select="./#tempOutputSomething" value="yes"/>
          <admst:variable name="outputSomething" value="yes"/>
          <admst:if test="[type='integer']">
            <admst:value-to select="../#tempOutput" value="%(../#tempOutput)int %(name);\n"/>
          </admst:if>
          <admst:if test="[type='real']">
            <admst:value-to select="../#tempOutput" value="%(../#tempOutput)double %(name)\n"/>
          </admst:if>
          <admst:if test="[type='string']">
            <admst:value-to select="../#tempOutput" value="%(../#tempOutput)char * %(name)\n"/>
          </admst:if>
        </admst:for-each>

        <admst:apply-templates select="item" match="evaluateCollapse">
          <admst:value-of select="returned('outputSomething')/value"/>
          <admst:variable name="blockOutputSomething" select="%s"/>
          <admst:value-of select="returned('output')/value"/>
          <admst:variable name="blockOutput" select="%s"/>
          <admst:if test="[$blockOutputSomething = 'yes']">
            <admst:variable name="outputSomething" string="yes"/>
            <admst:value-to select="../#tempOutputSomething" value="yes"/>
            <admst:variable name="tempOutput" select="%(../#tempOutput)\n$blockOutput"/>
            <admst:value-to select="../#tempOutput" value="$tempOutput"/>
          </admst:if>
        </admst:apply-templates>
        <admst:variable name="output" select="%(./#tempOutput)"/>
        <admst:if test="[name != '']">
          <admst:variable name="output" select="%($output)\n// end block  named %(name)\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[./#tempOutputSomething='yes']">
            <admst:return name="output" string="$output"/>
            <admst:return name="outputSomething" string="yes"/>
          </admst:when>
          <admst:otherwise>
            <admst:return name="output" string=""/>
            <admst:return name="outputSomething" string="no"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>


      <!--other stuff to ignore-->
      <admst:when test="[datatypename='expression' or datatypename='probe' or datatypename='variable' or datatypename='mapply_unary' or datatypename='mapply_binary' or datatypename='mapply_ternary' or datatypename='function' or datatypename='number' or datatypename='string' or datatypename='nilled' or datatypename='blockvariable' or datatypename='callfunction' or datatypename='case' or datatypename='whileloop' or datatypename='forloop' or datatypename='assignment']">
        <admst:return name="output" string=""/>
        <admst:return name="outputSomething" string="no"/>
      </admst:when>

      <admst:otherwise>
        <admst:fatal format="%(datatypename): adms element not implemented\n"/>
      </admst:otherwise>
    </admst:choose>

    <!-- we have to clear this now, and it has to be after the return.
         If we clear it before the return, somehow $output gets cleared.  Is
         that because it's still tied to the memory location of #tempoutput?
         And if we do NOT clear it, we consume all available memory and puke
         on complex files. -->
    <admst:value-to select="./#tempOutput" value=""/>
  </admst:template>

<!--
   =================================================================-
   collectExtraUnknowns
   Another "execute early in the processing" deal.
   Any use of "flow probes" requires an extra unknown (the flow through
   the branch).
   Any use of "potential sources" *also* requires an extra unknown (also
   the flow through the branch).
   These two cases also, naturally, require an additional equation.  There
   are multiple possibilities:

    A)  Flow probe used only in a flow source, without any associated
        contribution:
        I(b2) &lt;+ I(b1);
        In this case, the extra unknown is I(b1), and the extra equation is
          V(b1) = 0.

    B)  Flow probe used in a flow source, with an associated contribution:
        I(b1) &lt;+ expression;
        I(b2) &lt;+ A*I(b1);
        In this case, the extra unknown is I(b1), but the extra equation is:
          sum(contributions into I(b1)) -I(b1) = 0

    C)  Potential source
        V(B1) &lt;+ expression_not_referencing_the_branch_B1;
        Extra unknown is still I(B1), extra equation is:
          sum (all contributions into V(B1)) - V(B1) = 0

    D) Potential source referencing a flow probe:
        V(b1) &lt;+ expression;
        V(b2) &lt;+ A*I(B1)
        Extra unknown is I(B1), extra equation same as C

   Of course, each of these impacts the loads for the KCLs of the endpoints
   of B1 and B2.

      A) add/subtract I(B1) to endpoint nodes of B1
      B) add/subtract I(B1) to endpoint nodes of B1
      C) add/subtract I(B1) to endpoints of B1
      D) add/subtract I(B1) to endpoints of B1, use unknown I(B1) in
         equations for endpoints of B2.

   There are other cases, too, but these are already handled elsewhere.

   The purpose of this template is to figure out which new unknowns to
   allocate for, which is pretty easy (look for flow probes in the module's
   list of probes, and look for potential sources that aren't already flagged
   as collapsible (zero RHS) in the module's list of sources: each one
   means there has to be an associated current branch).

   Determining what type of *equation* to do really depends on the contribution
   involved.
   -->
<admst:template match="collectExtraUnknowns">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:reset select="$thisModule/@extraUnknowns"/>

  <!-- First find the extra unknowns due to flow probes -->
  <admst:for-each select="/module/probe[nature=discipline/flow]">
    <admst:push into="$thisModule/@extraUnknowns" select="branch" onduplicate="ignore"/>
    <admst:value-to select="#branchvar" string="yes" />
  </admst:for-each>

  <!-- Now find the extra unknowns due to potential sources -->
  <admst:for-each select="$thisModule/source[not(exists(branch/nnode/#collapsible)) and not(exists(branch/pnode/#collapsible)) and nature=discipline/potential]">
    <admst:push into="$thisModule/@extraUnknowns" select="branch" onduplicate="ignore"/>
  </admst:for-each>

  <!-- we now know the extra unknowns, which are all branches.  Unfortunately,
       ADMS does not store any information about this stuff in its "jacobian"
       structure, which makes life difficult for us.  So let us create our
       own data.  -->
  <!-- we'll make three arrays to help us figure out jacobian stuff

       we need a list of nodes
       that depend on branch variables.  We'll push the branch into the
       node. We handle this by pushing the list of branch dependencies
       into the actual node structure.

       We need  a list of branches that depend on nodal vars.
       This will let us create the jacobian row for the branch and fill it
       with nodal dependencies.  These will simply be put in an array
       inside the @extraUnknowns array called @nodeDeps.

       We need a list of branches that depend on branch vars.
       This will let us augment the branch equation rows.  This, too,
       will be stored in the @branchDeps array under the @extraUnknowns.
       -->
    <admst:for-each select="$thisModule/@extraUnknowns">
    <admst:variable name="thisBranch" select="%(.)"/>

      <admst:push into="pnode/@branchDeps" select="." onduplicate="ignore"/>
      <admst:if test="[nnode/grounded = 'no']">
        <admst:push into="nnode/@branchDeps" select="." onduplicate="ignore"/>
      </admst:if>

      <admst:apply-templates match="collectBranchDepends" select="."/>
      <admst:for-each select="/module/@countNodes">
        <admst:push into="$thisBranch/@nodeDeps" select="." onduplicate="ignore"/>
      </admst:for-each>
      <admst:for-each select="/module/@countBranches">
        <admst:push into="$thisBranch/@branchDeps" select="." onduplicate="ignore"/>
      </admst:for-each>
    </admst:for-each>

    <!-- Finally, we have an issue:  if a voltage source is uses, but
         the corresponding current probe is never used (such is done if
         one has a pure voltage source), then our process so far will never
         allocate a place for the current branch probe that we need to use in
         updateIntermediateVars.  So here, we'll go through our list of
         extra branch equations and make a list of branches for which there
         is no probe in the tree.  This will be used later to allocate what's
         missing. -->
    <admst:reset select="$thisModule/@extraProbeBranches"/>
    <admst:for-each select="$thisModule/@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(nnode/name)"/>
      <admst:if test="[not(exists($thisModule/probe[nature=discipline/flow and branch/pnode/name=$thePnodeName and branch/nnode/name=$theNnodeName]))]">
        <admst:push into="$thisModule/@extraProbeBranches" select="." onduplicate="ignore"/>
      </admst:if>
    </admst:for-each>

<!--   Debugging output commented out

  <admst:for-each select="$thisModule/@extraUnknowns">
    // branch %(.) depends on nodes %(@nodeDeps)
    // branch %(.) depends on branches %(@branchDeps)

  </admst:for-each>

  <admst:for-each select="$thisModule/node[grounded='no']">
    <admst:if test="[not(nilled(@branchDeps))]">
      // Node %(.) depends on branches %(@branchDeps)

    </admst:if>
  </admst:for-each>
-->
</admst:template>

<!--
   =================================================================-
   finishUpBranchEquations

   Branch equations are of the form:
     (sum of contributions into source) - (value of source) = 0

   Our contribution template does the sum part, but we now need to do
   the last bit.

    . must be a module
   =================================================================-
   -->
  <admst:template match="finishUpBranchEquations">

    <admst:variable name="thisModule" select="%(.)"/>
    <admst:for-each select="./contribution[lhs/nature=lhs/discipline/potential and not(rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">
      <!-- do nothing if a noise term -->
      <admst:if test="[whitenoise='no' and flickernoise='no']">

        <!-- The extra terms into the voltage nodes are only done once,
             and only into the static contributions. -->
        <admst:variable name="pnode" select="%(lhs/branch/pnode)"/>
        <admst:variable name="pnodeConstant" select="%(xyceNodeConstantName($pnode)/[name='nodeConstant']/value)"/>
        <admst:variable name="nnode" select="%(lhs/branch/nnode)"/>
        <admst:if test="[rhs/static='yes' or (rhs/dynamic='yes' and not(exists($thisModule/contribution[lhs/nature=lhs/discipline/potential and lhs/branch/pnode=$pnode and lhs/branch/nnode=$nnode and rhs/static='yes'])))]">
          // Additional term resulting from contributions into %(lhs)

          <admst:text format="staticContributions[$pnodeConstant] += probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
          <admst:text format="d_staticContributions[$pnodeConstant][%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)] += d_probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)][%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
          <admst:if test="$nnode[grounded='no']">
            <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
            <admst:text format="staticContributions[$nnodeConstant] -= probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
            <admst:text format="d_staticContributions[$nnodeConstant][%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)] -= d_probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)][%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
          </admst:if>
        </admst:if>
      </admst:if>
    </admst:for-each>

    <admst:for-each select="./@extraUnknowns">
      <!-- There is one special case:  a branch where the
           flow probe is used AND there is a flow source for it.
            In this case the branch equation is
              (sum of contributions into I(branch)) - I(branch) =0

            In all other cases, the branch equation will always be:
              (sum of contributions into V(branch)) - V(branch) = 0
       -->
       <admst:text format="  // Final term for branch equation %(xyceBranchConstantName(.)/[name='branchConstant']/value) \n"/>
  <admst:variable name="thePnodeName" select="%(pnode/name)"/>
  <admst:variable name="theNnodeName" select="%(nnode/name)"/>
       <admst:choose>
         <admst:when test="[exists(/module/contribution[lhs/branch/pnode/name='$thePnodeName' and lhs/branch/nnode/name='$theNnodeName' and lhs/nature=lhs/discipline/flow]) and not exists(/module/contribution[lhs/branch/pnode/name='$thePnodeName' and lhs/branch/nnode/name='$theNnodeName' and lhs/nature=lhs/discipline/potential])]">
           <admst:warning format="This module makes use of flow probe in branch ($thePnodeName,$theNnodeName) without any associated potential contribution to that branch, and with the use of flow contributions to that branch.  This particular use case is broken in Xyce/ADMS.\n"/>
           <admst:text format="  staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)] -= probeVars[%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
           <admst:text format="  d_staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)] -= d_probeVars[%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
         </admst:when>
         <admst:otherwise>
           <!-- ICK.  In this case, we don't usually HAVE a probe variable,
                and so we must calculate the drop V(branch) directly.
                We don't rely on automatic differentiation to do derivatives
                w.r.t. this, and will have to have a manual +/- dependence in
                the
                branch's static jacobian. -->
           <admst:text format="// Derivative of this term with respect to node is +/-1\n"/>
           <admst:text format="// Handling of that derivative is done explicitly in the loadDAEdFdX method\n"/>
           <admst:text format="  staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)] -= (*solVectorPtr)[%(xyceNodeLIDVariable(./pnode))]"/>
           <admst:if test="[nnode/grounded='no']">
             <admst:text format="-(*solVectorPtr)[%(xyceNodeLIDVariable(./nnode))]"/>
           </admst:if>
         <admst:text format=";\n"/>
         </admst:otherwise>
       </admst:choose>

    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   functionPrecomputation
     When evaluating assignments, we also need to evaluate (sometimes)
     the derivatives of the variables.  If the RHS of an assignment
     contains function calls, generating the assignment and its
     derivative assignments becomes problematic.  To address this,
     Xyce/ADMS will emit precomputation lines that evaluate the
     function and store its result in a variable, and the variable
     will be used in the actual expression instead.  This will also
     enable us to deal with derivatives of functions in a similar manner
     through functionDerivativePrecomputation.
   =================================================================-
  -->
  <admst:template match="functionPrecomputation">
    <!-- the index of this function call in the expression in which
         it appears -->
    <admst:variable name="functionIndex" select="%(index(../function,.))"/>
    <!-- The name of the function being called, one simple for the
         variable name, the other more complex for the call -->
    <admst:variable name="functionNameS" select="%(funcnameSimple(.)/[name='fname']/value)"/>
    <admst:variable name="functionName" select="%(funcname(.)/[name='fname']/value)"/>

    <admst:choose>
      <admst:when test="[class='analog']">
        <admst:text format="%(analogFunctionEvaluatorConstruction(.)/[name='returnedExpression']/value);\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="double value_%($functionNameS)_%($functionIndex) = %(functionCall(.)/[name='returnedExpression']/value);\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <!--
   =================================================================-
   functionDerivativePrecomputation
     When evaluating assignments, we also need to evaluate (sometimes)
     the derivatives of the variables.  If the RHS of an assignment
     contains function calls, generating the assignment and its
     derivative assignments becomes problematic.  As with
     functionPrecomputation, we go over the function in advance of
     emitting the assignment, and compute as needed the derivatives of
     function calls with respect to their arguments.  Note that to get
     the actual derivative of the function call with respect to solution,
     you still have to use the chain rule.

     We will name these derivative variables:
       deriv_<function name>_<index>_d<argnum>
     where index is the unique index of this function call within
     the expression, and the argnum is the number of the argument
     starting at zero.

   =================================================================-
  -->
  <admst:template match="functionDerivativePrecomputation">
    <admst:if test="[hasVoltageDependentFunction='yes' or $globalCurrentScope='sensitivity']">
      <admst:for-each select="function">
        <admst:variable name="functionIndex" select="%(index(../function,.))"/>
        <admst:variable name="functionNameS" select="%(funcnameSimple(.)/[name='fname']/value)"/>
        <admst:variable name="functionName" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:variable name="varType" select="double "/>

        <admst:choose>
          <admst:when test="[name='exp' or name='ln' or name='log' or name='sqrt' or name='abs' or name='limexp' or name='cos' or name='sin' or name='tan' or name='acos' or name='asin' or name='atan' or name='cosh' or name='sinh' or name='tanh' or name='acosh' or name='asinh' or name='atanh']">
            <admst:if test="[arguments/math/dependency!='constant' or ($globalCurrentScope='sensitivity' and exists(arguments[1]/#Pdependent))]">
              <admst:choose>
                <admst:when test="[name='exp']">
                  <admst:text format="%($varType) deriv_exp_%($functionIndex)_d0 = value_exp_%($functionIndex);\n"/>
                </admst:when>
                <admst:otherwise>
                  <admst:apply-templates select="arguments[1]" match="processTerm">
                    <admst:value-of select="returned('returnedExpression')/value"/>
                    <admst:variable name="a1" select="%s"/>
                  </admst:apply-templates>
                  <admst:choose>
                    <admst:when test="[name='ln']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (1.0/$a1);\n"/>
                    </admst:when>
                    <admst:when test="[name='log']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (1.0/(log(10.0)*$a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='sqrt']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (0.5/value_sqrt_%($functionIndex));\n"/>
                    </admst:when>
                    <admst:when test="[name='abs']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = ((($a1)&gt;=0)?(+1.0):(-1.0));\n"/>
                    </admst:when>
                    <admst:when test="[name='cos']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (-sin($a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='sin']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (cos($a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='tan']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (1.0/cos($a1)/cos($a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='acos']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (-1.0/sqrt(1.0-$a1*$a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='asin']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (+1.0/sqrt(1.0-$a1*$a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='atan']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (+1.0/(1+$a1*$a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='cosh']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (sinh($a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='sinh']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (cosh($a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='tanh']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (1.0/cosh($a1)/cosh($a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='acosh']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (1.0/(sqrt($a1-1.0)*sqrt($a1+1.0)));\n"/>
                    </admst:when>
                    <admst:when test="[name='asinh']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (1.0/(sqrt($a1*$a1+1.0)));\n"/>
                    </admst:when>
                    <admst:when test="[name='atanh']">
                      <admst:text format="%($varType) deriv_%($functionNameS)_%($functionIndex)_d0 = (1.0/(1-$a1*$a1));\n"/>
                    </admst:when>
                    <admst:when test="[name='limexp']">
                      <admst:text format="%($varType) deriv_limexp_%($functionIndex)_d0 = ((($a1)&lt;80)?(value_limexp_%($functionIndex)):exp(80.0));\n"/>
                </admst:when>
                  </admst:choose>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:when test="[name='pow' or name='min' or name='max' or name='hypot' or name='atan2']">
            <admst:apply-templates select="arguments[1]" match="processTerm">
              <admst:value-of select="returned('returnedExpression')/value"/>
              <admst:variable name="a1" select="%s"/>
            </admst:apply-templates>

            <admst:apply-templates select="arguments[2]" match="processTerm">
              <admst:value-of select="returned('returnedExpression')/value"/>
              <admst:variable name="a2" select="%s"/>
            </admst:apply-templates>
            <admst:if test="[arguments[1]/math/dependency!='constant' or ($globalCurrentScope='sensitivity' and exists(arguments[1]/#Pdependent))]">
              <admst:choose>
                <admst:when test="[name='pow']">
                  <admst:text format="%($varType) deriv_pow_%($functionIndex)_d0 = ((%($a1) == 0.0)?0.0:(value_pow_%($functionIndex)*%($a2)/%($a1)));\n"/>
                </admst:when>
                <admst:when test="[name='min']">
                  <admst:text format="%($varType) deriv_min_%($functionIndex)_d0 = ((%($a1)&lt;=%($a2))?1.0:0.0);\n"/>
                </admst:when>
                <admst:when test="[name='max']">
                  <admst:text format="%($varType) deriv_max_%($functionIndex)_d0 = ((%($a1)&gt;=%($a2))?1.0:0.0);\n"/>
                </admst:when>
                <admst:when test="[name='hypot']">
                  <admst:text format="%($varType) deriv_hypot_%($functionIndex)_d0 = %($a1)/value_hypot_%($functionIndex);\n"/>
                </admst:when>
                <admst:when test="[name='atan2']">
                  <admst:text format="%($varType) deriv_atan2_%($functionIndex)_d0 = %($a2)/(%($a2)*%($a2) + %($a1)*%($a1));\n"/>
                </admst:when>
              </admst:choose>
            </admst:if>
            <admst:if test="[arguments[2]/math/dependency!='constant' or ($globalCurrentScope='sensitivity' and exists(arguments[2]/#Pdependent))]">
              <admst:choose>
                <admst:when test="[name='pow']">
                  <admst:text format="%($varType) deriv_pow_%($functionIndex)_d1 = (%($a1) == 0.0)?0.0:(log($a1)*value_pow_%($functionIndex));\n"/>
                </admst:when>
                <admst:when test="[name='min']">
                  <admst:text format="%($varType) deriv_min_%($functionIndex)_d1 = ((%($a1)&lt;=%($a2))?0.0:1.0);\n"/>
                </admst:when>
                <admst:when test="[name='max']">
                  <admst:text format="%($varType) deriv_max_%($functionIndex)_d1 = ((%($a1)&gt;=%($a2))?0.0:1.0);\n"/>
                </admst:when>
                <admst:when test="[name='hypot']">
                  <admst:text format="%($varType) deriv_hypot_%($functionIndex)_d1 = %($a2)/value_hypot_%($functionIndex);\n"/>
                </admst:when>
                <admst:when test="[name='atan2']">
                  <admst:text format="%($varType) deriv_atan2_%($functionIndex)_d1 = -%($a1)/(%($a2)*%($a2) + %($a1)*%($a1));\n"/>
                </admst:when>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:if test="[class !='analog' and name != '\$simparam' and name != 'floor']">
              <admst:text format="//function deriv %(name) not implemented yet.\n"/>
              <admst:warning format="function derivative for %(name) not implemented yet.\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:if>
  </admst:template>
  <!--
   =================================================================-
   verilog2CXXtype
     given an admst data tree node, return the C++ datatype
     corresponding to its type
    The node passed in is usually a variable
   =================================================================-
  -->
  <admst:template match="verilog2CXXtype">
    <admst:choose>
      <admst:when test="[type='integer']">
        <admst:text format="int"/>
      </admst:when>
      <admst:when test="[type='real']">
        <admst:text format="double"/>
      </admst:when>
      <admst:when test="[type='string']">
        <admst:text format="string"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="should not be reached\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   textUnit2XyceUnit
   given an admst data tree element with a "units" attribute,
   output the corresponding "U_" string
   =================================================================-
  -->
  <admst:template match="textUnit2XyceUnit">
    <admst:choose>
      <!-- Simple units -->
      <admst:when test="[attribute/[name='units']/value = 'm']">
        <admst:text format="U_METER"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm^2']">
        <admst:text format="U_METER2"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm^-3']">
        <admst:text format="U_METERM3"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'F']">
        <admst:text format="U_FARAD"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm']">
        <admst:text format="U_OHM"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'V']">
        <admst:text format="U_VOLT"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '/V' or attribute/[name='units']/value = 'V^-1']">
        <admst:text format="U_VOLTM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'V^-0.5']">
        <admst:text format="U_VOLTMH"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'A']">
        <admst:text format="U_AMP"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'S' or attribute/[name='units']/value = '1/Ohm']">
        <admst:text format="U_OHMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 's']">
        <admst:text format="U_SECOND"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'K']">
        <admst:text format="U_DEGK"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'K^-1' or attribute/[name='units']/value = '1/K']">
        <admst:text format="U_DEGKM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'degC']">
        <admst:text format="U_DEGC"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '/C' or attribute/[name='units']/value = '1/C' or attribute/[name='units']/value = 'degC^-1']">
        <admst:text format="U_DEGCM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'C']">
        <admst:text format="U_COULOMB"/>
      </admst:when>
      <!-- Complex units -->
      <admst:when test="[attribute/[name='units']/value = 'V/K']">
        <admst:text format="U_VKM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm^2/V/s']">
        <admst:text format="U_M2VM1SM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm/V']">
        <admst:text format="U_MVM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Vm']">
        <admst:text format="U_VM"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Vm^-1']">
        <admst:text format="U_VMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'A/V^3' or attribute/[name='units']/value = 'AV^-3' ]">
        <admst:text format="U_AMPVM3"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am/V^3' or attribute/[name='units']/value = 'AV^-3m' ]">
        <admst:text format="U_AMPVM3M"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-1']">
        <admst:text format="U_AMPMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-2']">
        <admst:text format="U_AMPMM2"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-3']">
        <admst:text format="U_AMPMM3"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm m^2']">
        <admst:text format="U_OHMM2"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm/sq']">
        <admst:text format="U_OSQM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Fm^-1']">
        <admst:text format="U_FARADMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Fm^-2']">
        <admst:text format="U_FARADMM2"/>
      </admst:when>

      <admst:otherwise>
        <admst:text format="U_UNKNOWN"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

    <!--
   =================================================================-
   textUnit2LaTeXUnit
   given an admst data tree element with a "units" attribute,
   output the corresponding LaTeX string
   =================================================================-
  -->
  <admst:template match="textUnit2LaTeXUnit">
    <admst:choose>
      <!-- Simple units -->
      <admst:when test="[attribute/[name='units']/value = 'm^-3']">
        <admst:text format="m\$^{-3}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm']">
        <admst:text format="Ohm"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '/V' or attribute/[name='units']/value = 'V^-1']">
        <admst:text format="V\$^{-1}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'V^-0.5']">
        <admst:text format="V\$^{-0.5}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'S' or attribute/[name='units']/value = '1/Ohm']">
        <admst:text format="\$\\mathsf{\\Omega}^{-1}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'K^-1' or attribute/[name='units']/value = '1/K']">
        <admst:text format="K\$^{-1}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '/C' or attribute/[name='units']/value = '1/C' or attribute/[name='units']/value = 'degC^-1']">
        <admst:text format="\$^\\circ\$C\$^{-1}\$"/>
      </admst:when>
      <!-- Complex units -->
      <admst:when test="[attribute/[name='units']/value = 'm^2/V/s']">
        <admst:text format="m\$^{2}\$/(Vs)"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Vm^-1']">
        <admst:text format="Vm\$^{-1}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'A/V^3' or attribute/[name='units']/value = 'AV^-3' ]">
        <admst:text format="A/V\$^{3}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'A/V^2' or attribute/[name='units']/value = 'AV^-2' ]">
        <admst:text format="A/V\$^{2}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am/V^3' or attribute/[name='units']/value = 'AV^-3m' ]">
        <admst:text format="Am/V\$^{3}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-1']">
        <admst:text format="A/m"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-2']">
        <admst:text format="A/m\$^{2}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-3']">
        <admst:text format="A/m\$^{3}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm m^2']">
        <admst:text format="\$\\mathsf{\\Omega}\$ m\$^{2}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm/sq']">
        <admst:text format="\$\\mathsf{\\Omega}/\\Box\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Fm^-1']">
        <admst:text format="F/m"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Fm^-2']">
        <admst:text format="F/m\$^{2}\$"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'A^2/Hz']">
        <admst:text format="A\$^{2}\$/Hz"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm^2/(V s)']">
        <admst:text format="m\$^2\$/(V s)"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '1/(V m^2)']">
        <admst:text format="1/(V m\$^2\$)"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '1/(V m^4)']">
        <admst:text format="1/(V m\$^4\$)"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="%(attribute/[name='units']/value)"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   processTerm
   given any node, run the associated template over it
   =================================================================-
  -->
  <admst:template match="processTerm" >
    <admst:apply-templates select="." match="%(adms/datatypename)">
      <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
      <admst:variable name="expressionDeriv" select="%(returned('returnedExpressionDeriv')/value)"/>
      <admst:variable name="expressionDeriv2" select="%(returned('returnedExpressionDeriv2')/value)"/>
      <admst:variable name="expressionDeriv12" select="%(returned('returnedExpressionDeriv12')/value)"/>
      <admst:variable name="expressionDerivX" select="%(returned('returnedExpressionDerivX')/value)"/>
    </admst:apply-templates>
    <admst:return name="returnedExpression" value="$expression"/>
    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>
  </admst:template>

  <!--
   =================================================================-
   printTerm
   given any node, run the associated template over it and print
   =================================================================-
  -->
  <admst:template match="printTerm" >
    <admst:apply-templates select="." match="%(adms/datatypename)">
      <admst:text format="%(returned('returnedExpression')/value)"/>
    </admst:apply-templates>
  </admst:template>

  <!--
   =================================================================-
   handling of expression
   expression
   This template returns the expression passed to it in the select
   field
   It processes each element of the tree using a template of the
   same name as the datatype name.

   To understand what it's doing, be aware that the datatypenames
   that typically end up in the tree  are things like number,
   mapply_binary, mapply_unary, expression (implying recursion back
   into this template), ... (fill in, it would be good for this
   comment to document all the templates we can call)

   Each of the templates called does little more than return the C++
   representation of that type of data, and when we return the entire
   expression will be printed in C++
   =================================================================-
  -->
  <admst:template match="expression">
    <admst:apply-templates select="tree" match="%(adms/datatypename)" required="yes">
      <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
      <admst:variable name="expressionDeriv" select="%(returned('returnedExpressionDeriv')/value)"/>
      <admst:variable name="expressionDeriv2" select="%(returned('returnedExpressionDeriv2')/value)"/>
      <admst:variable name="expressionDeriv12" select="%(returned('returnedExpressionDeriv12')/value)"/>
      <admst:variable name="expressionDerivX" select="%(returned('returnedExpressionDerivX')/value)"/>
    </admst:apply-templates>
    <admst:return name="returnedExpression" value="$expression"/>
    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>
  </admst:template>

  <!--
   =================================================================-
   number
   Print out a number, properly accounting for scaling unit suffixes
   =================================================================-
  -->
  <admst:template match="number">
    <admst:value-of select="value"/>
    <admst:choose>
      <admst:when test="[scalingunit='1']"><admst:return name="returnedExpression" value="%s"/></admst:when>
      <admst:when test="[scalingunit='E']"><admst:return name="returnedExpression" value="(%s*1.0e+18)"/></admst:when>
      <admst:when test="[scalingunit='P']"><admst:return name="returnedExpression" value="%s*1.0e+15"/></admst:when>
      <admst:when test="[scalingunit='T']"><admst:return name="returnedExpression" value="%s*1.0e+12"/></admst:when>
      <admst:when test="[scalingunit='G']"><admst:return name="returnedExpression" value="%s*1.0e+9"/></admst:when>
      <admst:when test="[scalingunit='M']"><admst:return name="returnedExpression" value="%s*1.0e+6"/></admst:when>
      <admst:when test="[scalingunit='k']"><admst:return name="returnedExpression" value="%s*1.0e+3"/></admst:when>
      <admst:when test="[scalingunit='h']"><admst:return name="returnedExpression" value="%s*1.0e+2"/></admst:when>
      <admst:when test="[scalingunit='D']"><admst:return name="returnedExpression" value="%s*1.0e+1"/></admst:when>
      <admst:when test="[scalingunit='d']"><admst:return name="returnedExpression" value="%s*1.0e-1"/></admst:when>
      <admst:when test="[scalingunit='c']"><admst:return name="returnedExpression" value="%s*1.0e-2"/></admst:when>
      <admst:when test="[scalingunit='m']"><admst:return name="returnedExpression" value="%s*1.0e-3"/></admst:when>
      <admst:when test="[scalingunit='u']"><admst:return name="returnedExpression" value="%s*1.0e-6"/></admst:when>
      <admst:when test="[scalingunit='n']"><admst:return name="returnedExpression" value="%s*1.0e-9"/></admst:when>
      <admst:when test="[scalingunit='A']"><admst:return name="returnedExpression" value="%s*1.0e-10"/></admst:when>
      <admst:when test="[scalingunit='p']"><admst:return name="returnedExpression" value="%s*1.0e-12"/></admst:when>
      <admst:when test="[scalingunit='f']"><admst:return name="returnedExpression" value="%s*1.0e-15"/></admst:when>
      <admst:when test="[scalingunit='a']"><admst:return name="returnedExpression" value="%s*1.0e-18"/></admst:when>
      <admst:otherwise>
        <admst:value-of select="scalingunit"/>
        <admst:fatal format="%s%s: scaling unit not supported\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpressionDeriv" value="0.0"/>
    <admst:return name="returnedExpressionDeriv2" value="0.0"/>
    <admst:return name="returnedExpressionDeriv12" value="0.0"/>
    <admst:return name="returnedExpressionDerivX" value="0.0"/>
  </admst:template>

  <!--
   =================================================================-
   mapply_unary
   This template handles unary operators, printing out the result
   surrounded by parentheses
   =================================================================-
  -->
  <admst:template match="mapply_unary">
    <admst:if test="[name='plus']"> <admst:variable name="op" select="+"/> </admst:if>
    <admst:if test="[name='minus']"> <admst:variable name="op" select="-"/> </admst:if>
    <admst:if test="[name='not']"> <admst:variable name="op" select="!"/> </admst:if>
    <admst:if test="[name='bw_not']"> <admst:variable name="op" select="~"/> </admst:if>
    <admst:variable name="expressionDeriv2" select="0.0"/>
    <admst:variable name="expressionDeriv12" select="0.0"/>
    <admst:variable name="expressionDerivX" select="0.0"/>
    <admst:choose>
      <admst:when test="[arg1/math/value=0.0]">
        <admst:variable name="expression" select="0.0"/>
        <admst:variable name="expressionDeriv" select="0.0"/>
        <admst:variable name="expressionDeriv2" select="0.0"/>
        <admst:variable name="expressionDeriv12" select="0.0"/>
        <admst:variable name="expressionDerivX" select="0.0"/>
      </admst:when>
      <admst:otherwise>
        <admst:value-of select="arg1/adms/datatypename"/>
        <admst:apply-templates select="arg1" match="%s" required="yes">
          <admst:value-of select="returned('returnedExpression')/value"/>
          <admst:variable name="expression" select="($op%s)"/>
          <admst:value-of select="returned('returnedExpressionDeriv')/value"/>
          <admst:variable name="a1Deriv" select="%s"/>
          <admst:if test="$derivProbe2">
            <admst:value-of select="returned('returnedExpressionDeriv2')/value"/>
            <admst:variable name="a1Deriv2" select="%s"/>
            <admst:value-of select="returned('returnedExpressionDeriv12')/value"/>
            <admst:variable name="a1Deriv12" select="%s"/>
          </admst:if>
          <admst:if test="[$globalCurrentScope='sensitivity' and exists(#Pdependent)]">
            <admst:value-of  select="returned('returnedExpressionDerivX')/value"/>
            <admst:variable name="a1DerivX" select="%s"/>
          </admst:if>
          <admst:choose>
            <admst:when test="[$a1Deriv='0.0']">
              <admst:variable name="expressionDeriv" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expressionDeriv" select="($op$a1Deriv)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:if test="$derivProbe2">
            <admst:choose>
              <admst:when test="[$a1Deriv2='0.0']">
                <admst:variable name="expressionDeriv2" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv2" select="($op$a1Deriv2)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$a1Deriv12='0.0']">
                <admst:variable name="expressionDeriv12" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv12" select="($op$a1Deriv12)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:if>
          <admst:if test="[$globalCurrentScope='sensitivity' and exists(#Pdependent)]">
            <admst:choose>
              <admst:when test="[$a1DerivX='0.0']">
                <admst:variable name="expressionDerivX" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDerivX" select="($op$a1DerivX)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:if>
        </admst:apply-templates>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>

  </admst:template>

  <!--
   =================================================================-
   mapply_binary
   This template handles binary operators, printing out the C++
   version surrounded by parentheses
   =================================================================-
  -->
  <admst:template match="mapply_binary">
    <admst:apply-templates select="arg1" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a1" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv')/value"/>
      <admst:variable name="a1Deriv" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv2')/value"/>
      <admst:variable name="a1Deriv2" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv12')/value"/>
      <admst:variable name="a1Deriv12" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDerivX')/value"/>
      <admst:variable name="a1DerivX" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg2" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a2" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv')/value"/>
      <admst:variable name="a2Deriv" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv2')/value"/>
      <admst:variable name="a2Deriv2" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv12')/value"/>
      <admst:variable name="a2Deriv12" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDerivX')/value"/>
      <admst:variable name="a2DerivX" select="%s"/>
    </admst:apply-templates>
    <admst:variable name="expressionDeriv2" select="0.0"/>
    <admst:variable name="expressionDeriv12" select="0.0"/>
    <admst:variable name="expressionDerivX" select="0.0"/>
    <admst:choose>
      <!-- addition -->
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
            <admst:variable name="expression" select="0.0"/>
            <admst:variable name="expressionDeriv" select="0.0"/>
            <admst:variable name="expressionDeriv2" select="0.0"/>
            <admst:variable name="expressionDeriv12" select="0.0"/>
            <admst:variable name="expressionDerivX" select="0.0"/>
          </admst:when>
          <admst:when test="[arg1/math/value=0.0 or $a1='0.0']">
            <admst:variable name="expression" select="%($a2)"/>
            <admst:choose>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="%($a2Deriv)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a2Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="%($a2Deriv2)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a2Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="%($a2Deriv12)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent)  or exists(arg2/#Pdependent))]">
              <admst:choose>
                <admst:when test="[$a2DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="%($a2DerivX)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:when test="[arg2/math/value=0.0 or $a2='0.0']">
            <admst:variable name="expression" select="%($a1)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="%($a1Deriv)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="%($a1Deriv2)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a1Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="%($a1Deriv12)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent) or exists(arg2/#Pdependent))]">
              <admst:choose>
                <admst:when test="[$a1DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="%($a1DerivX)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1+$a2)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv ='0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="$a2Deriv"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="$a1Deriv"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="($a1Deriv+$a2Deriv)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2 = '0.0' and $a2Deriv2 ='0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="$a2Deriv2"/>
                </admst:when>
                <admst:when test="[$a2Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="$a1Deriv2"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="($a1Deriv2+$a2Deriv2)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a1Deriv12 = '0.0' and $a2Deriv12 ='0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="$a2Deriv12"/>
                </admst:when>
                <admst:when test="[$a2Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="$a1Deriv12"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="($a1Deriv12+$a2Deriv12)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent) or exists(arg2/#Pdependent)) ]">
              <admst:choose>
                <admst:when test="[$a1DerivX = '0.0' and $a2DerivX ='0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="$a2DerivX"/>
                </admst:when>
                <admst:when test="[$a2DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="$a1DerivX"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="($a1DerivX+$a2DerivX)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <!-- subtraction -->
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0) or ($a1='0.0' and $a2='0.0')]">
            <admst:variable name="expression" select="0.0"/>
            <admst:variable name="expressionDeriv" select="0.0"/>
            <admst:variable name="expressionDeriv2" select="0.0"/>
            <admst:variable name="expressionDeriv12" select="0.0"/>
            <admst:variable name="expressionDerivX" select="0.0"/>
          </admst:when>
          <admst:when test="[arg1/math/value=0.0 or $a1='0.0']">
            <admst:variable name="expression" select="(-%($a2))"/>
            <admst:choose>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="(-%($a2Deriv))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a2Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="(-%($a2Deriv2))"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a2Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="(-%($a2Deriv12))"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent) or exists(arg2/#Pdependent)) ]">
              <admst:choose>
                <admst:when test="[$a2DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="(-%($a2DerivX))"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:when test="[arg2/math/value=0.0 or $a2='0.0']">
            <admst:variable name="expression" select="(%($a1))"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="%($a1Deriv)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="%($a1Deriv2)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a1Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="%($a1Deriv12)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent) or exists(arg2/#Pdependent)) ]">
              <admst:choose>
                <admst:when test="[$a1DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="%($a1DerivX)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1-$a2)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv ='0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="(-$a2Deriv)"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="$a1Deriv"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="($a1Deriv-$a2Deriv)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2 = '0.0' and $a2Deriv2 ='0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="(-$a2Deriv2)"/>
                </admst:when>
                <admst:when test="[$a2Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="$a1Deriv2"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="($a1Deriv2-$a2Deriv2)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a1Deriv12 = '0.0' and $a2Deriv12 ='0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="(-$a2Deriv12)"/>
                </admst:when>
                <admst:when test="[$a2Deriv12 = '0.0']">
                  <admst:variable name="expressionDeriv12" select="$a1Deriv12"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="($a1Deriv12-$a2Deriv12)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent) or exists(arg2/#Pdependent)) ]">
              <admst:choose>
                <admst:when test="[$a1DerivX = '0.0' and $a2DerivX ='0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="(-$a2DerivX)"/>
                </admst:when>
                <admst:when test="[$a2DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="$a1DerivX"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="($a1DerivX-$a2DerivX)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0) or $a1='0.0' or $a2='0.0']">
            <admst:variable name="expression" select="0.0"/>
            <admst:variable name="expressionDeriv" select="0.0"/>
            <admst:variable name="expressionDeriv2" select="0.0"/>
            <admst:variable name="expressionDeriv12" select="0.0"/>
            <admst:variable name="expressionDerivX" select="0.0"/>
          </admst:when>
          <admst:when test="[((arg1/math/value=1.0) and (arg2/math/value=1.0)) or ($a1='1.0' and $a2='1.0')]">
            <admst:variable name="expression" select="1.0"/>
            <admst:variable name="expressionDeriv" select="0.0"/>
            <admst:variable name="expressionDeriv2" select="0.0"/>
            <admst:variable name="expressionDeriv12" select="0.0"/>
            <admst:variable name="expressionDerivX" select="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1*$a2)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="$a1"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0' and $a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="$a2"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0' and $a2Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1+$a2)"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="$a1*$a2Deriv"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="$a1Deriv*$a2"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1*$a2Deriv+$a2)"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1+$a2*$a1Deriv)"/>
              </admst:when>
              <admst:when test="[$a1 = '1.0']">
                <admst:variable name="expressionDeriv" select="$a2Deriv"/>
              </admst:when>
              <admst:when test="[$a2 = '1.0']">
                <admst:variable name="expressionDeriv" select="$a1Deriv"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="($a1*$a2Deriv+$a1Deriv*$a2)"/>
              </admst:otherwise>
            </admst:choose>
            <!-- now do derivative with respect to second probe, if it exists -->
            <!-- and second derivs w.r.t. both probes -->
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2 = '0.0' and $a2Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '0.0' and $a2Deriv2 = '1.0']">
                  <admst:variable name="expressionDeriv2" select="$a1"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0' and $a2Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="$a2"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0' and $a2Deriv2 = '1.0']">
                  <admst:variable name="expressionDeriv2" select="($a1+$a2)"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="$a1*$a2Deriv2"/>
                </admst:when>
                <admst:when test="[$a2Deriv2 = '0.0']">
                  <admst:variable name="expressionDeriv2" select="$a1Deriv2*$a2"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0']">
                  <admst:variable name="expressionDeriv2" select="($a1*$a2Deriv2+$a2)"/>
                </admst:when>
                <admst:when test="[$a2Deriv2 = '1.0']">
                  <admst:variable name="expressionDeriv2" select="($a1+$a2*$a1Deriv2)"/>
                </admst:when>
                <admst:when test="[$a1 = '1.0']">
                  <admst:variable name="expressionDeriv2" select="$a2Deriv2"/>
                </admst:when>
                <admst:when test="[$a2 = '1.0']">
                  <admst:variable name="expressionDeriv2" select="($a1Deriv2)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="($a1*$a2Deriv2+$a1Deriv2*$a2)"/>
                </admst:otherwise>
              </admst:choose>
              <!-- Now we must do derivative w.r.t. 1 and 2, and all the special cases -->
              <!-- first term is d2a1/dp2dp1*a2 -->
              <admst:variable name="term1" select=""/>
              <admst:variable name="term2" select=""/>
              <admst:variable name="term3" select=""/>
              <admst:variable name="term4" select=""/>
              <admst:choose>
                <admst:when test="[$a1Deriv12 = '0.0' or $a2 = '0.0']">
                  <admst:variable name="term1" select=""/>
                </admst:when>
                <admst:when test="[$a1Deriv12 = '1.0' and $a2 = '1.0']">
                  <admst:variable name="term1" select="1.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv12 = '1.0']">
                  <admst:variable name="term1" select="$a2"/>
                </admst:when>
                <admst:when test="[$a2 = '1.0']">
                  <admst:variable name="term1" select="$a1Deriv12"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term1" select="$a1Deriv12*$a2"/>
                </admst:otherwise>
              </admst:choose>
              <!-- second term, da1/dp1*da2/dp2 -->
              <admst:choose>
                <admst:when test="[$a1Deriv = '0.0' or $a2Deriv2 = '0.0']">
                  <admst:variable name="term2" select=""/>
                </admst:when>
                <admst:when test="[$a1Deriv = '1.0' and $a2Deriv2 ='1.0']">
                  <admst:variable name="term2" select="1.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv = '1.0']">
                  <admst:variable name="term2" select="$a2Deriv2"/>
                </admst:when>
                <admst:when test="[$a2Deriv2 = '1.0']">
                  <admst:variable name="term2" select="$a1Deriv"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term2" select="$a1Deriv*$a2Deriv2"/>
                </admst:otherwise>
              </admst:choose>
              <!-- third term, da1/dp2*da2/dp1 -->
              <admst:choose>
                <admst:when test="[$a1Deriv2 = '0.0' or $a2Deriv = '0.0']">
                  <admst:variable name="term3" select=""/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0' and $a2Deriv ='1.0']">
                  <admst:variable name="term3" select="1.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0']">
                  <admst:variable name="term3" select="$a2Deriv"/>
                </admst:when>
                <admst:when test="[$a2Deriv = '1.0']">
                  <admst:variable name="term3" select="$a1Deriv2"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term3" select="$a1Deriv2*$a2Deriv"/>
                </admst:otherwise>
              </admst:choose>
              <!-- final term, a1*d2a2/dp2dp1 -->
              <admst:choose>
                <admst:when test="[$a2Deriv12 = '0.0' or $a1 = '0.0']">
                  <admst:variable name="term4" select=""/>
                </admst:when>
                <admst:when test="[$a2Deriv12 = '1.0' and $a1 = '1.0']">
                  <admst:variable name="term4" select="1.0"/>
                </admst:when>
                <admst:when test="[$a2Deriv12 = '1.0']">
                  <admst:variable name="term4" select="$a1"/>
                </admst:when>
                <admst:when test="[$a1 = '1.0']">
                  <admst:variable name="term4" select="$a2Deriv12"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term4" select="$a1*$a2Deriv12"/>
                </admst:otherwise>
              </admst:choose>
              <!-- now assemble the smallest possible expression we can make of this -->
              <admst:variable name="expressionDeriv12" select="$term1"/>
              <admst:if test="[not($expressionDeriv12='') and not($term2='')]">
                <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
              </admst:if>
              <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term2"/>
              <admst:if test="[not($expressionDeriv12='') and not($term3='')]">
                <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
              </admst:if>
              <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term3"/>
              <admst:if test="[not($expressionDeriv12='') and not($term4='')]">
                <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
              </admst:if>
              <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term4"/>
              <admst:choose>
                <admst:when test="[$expressionDeriv12='']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="($expressionDeriv12)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <!-- now sensitivity deriv if needed -->
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent) or exists(arg2/#Pdependent)) ]">
              <admst:choose>
                <admst:when test="[$a1DerivX = '0.0' and $a2DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1DerivX = '0.0' and $a2DerivX = '1.0']">
                  <admst:variable name="expressionDerivX" select="$a1"/>
                </admst:when>
                <admst:when test="[$a1DerivX = '1.0' and $a2DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="$a2"/>
                </admst:when>
                <admst:when test="[$a1DerivX = '1.0' and $a2DerivX = '1.0']">
                  <admst:variable name="expressionDerivX" select="($a1+$a2)"/>
                </admst:when>
                <admst:when test="[$a1DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="$a1*$a2DerivX"/>
                </admst:when>
                <admst:when test="[$a2DerivX = '0.0']">
                  <admst:variable name="expressionDerivX" select="$a1DerivX*$a2"/>
                </admst:when>
                <admst:when test="[$a1DerivX = '1.0']">
                  <admst:variable name="expressionDerivX" select="($a1*$a2DerivX+$a2)"/>
                </admst:when>
                <admst:when test="[$a2DerivX = '1.0']">
                  <admst:variable name="expressionDerivX" select="($a1+$a2*$a1DerivX)"/>
                </admst:when>
                <admst:when test="[$a1 = '1.0']">
                  <admst:variable name="expressionDerivX" select="$a2DerivX"/>
                </admst:when>
                <admst:when test="[$a2 = '1.0']">
                  <admst:variable name="expressionDerivX" select="$a1DerivX"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="($a1*$a2DerivX+$a1DerivX*$a2)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:variable name="term1" select=""/>
        <admst:variable name="term2" select=""/>
        <admst:variable name="term2a" select=""/>
        <admst:variable name="term2b" select=""/>
        <admst:variable name="term2c" select=""/>
        <admst:variable name="term3" select=""/>
        <admst:choose>
          <admst:when test="[arg1/math/value=0.0 or $a1='0.0']">
            <admst:variable name="expression" select="0.0"/>
            <admst:variable name="expressionDeriv" select="0.0"/>
            <admst:variable name="expressionDeriv2" select="0.0"/>
            <admst:variable name="expressionDeriv12" select="0.0"/>
            <admst:variable name="expressionDerivX" select="0.0"/>
          </admst:when>
          <admst:when test="[((arg1/math/value=1.0)and(arg2/math/value=1.0)) or ($a1='1.0' and $a2='1.0')]">
            <admst:variable name="expression" select="1.0"/>
            <admst:variable name="expressionDeriv" select="0.0"/>
            <admst:variable name="expressionDeriv2" select="0.0"/>
            <admst:variable name="expressionDeriv12" select="0.0"/>
            <admst:variable name="expressionDerivX" select="0.0"/>
          </admst:when>
          <admst:when test="[$a2='1.0']">
            <admst:variable name="expression" select="$a1"/>
            <admst:variable name="expressionDeriv" select="$a1Deriv"/>
            <admst:variable name="expressionDeriv2" select="$a1Deriv2"/>
            <admst:variable name="expressionDeriv12" select="$a1Deriv12"/>
            <admst:variable name="expressionDerivX" select="$a1DerivX"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1/$a2)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv='0.0' and $a2Deriv='0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:when test="[$a1 = '1.0']">
                <admst:choose>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(-1.0/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(-$a2Deriv/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:choose>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(-$a1/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(-$a1*$a2Deriv/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0']">
                <admst:choose>
                  <admst:when test="[$a2Deriv = '0.0']">
                    <admst:variable name="expressionDeriv" select="(1.0/$a2)"/>
                  </admst:when>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(($a2-$a1)/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(($a2-($a1*$a2Deriv))/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$a2 = '1.0']">
                    <admst:variable name="expressionDeriv" select="$a1Deriv"/>
                  </admst:when>
                  <admst:when test="[$a2Deriv = '0.0']">
                    <admst:variable name="expressionDeriv" select="($a1Deriv/$a2)"/>
                  </admst:when>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(($a2*$a1Deriv-$a1)/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(($a2*$a1Deriv-$a1*$a2Deriv)/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
            <!-- derivative with respect to second probe if there is one -->
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2='0.0' and $a2Deriv2='0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1 = '1.0']">
                  <admst:choose>
                    <admst:when test="[$a2Deriv2 = '1.0']">
                      <admst:variable name="expressionDeriv2" select="(-1.0/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDeriv2" select="(-$a2Deriv2/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '0.0']">
                  <admst:choose>
                    <admst:when test="[$a2Deriv2 = '1.0']">
                      <admst:variable name="expressionDeriv2" select="(-$a1/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDeriv2" select="(-$a1*$a2Deriv2/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0']">
                  <admst:choose>
                    <admst:when test="[$a2Deriv2 = '0.0']">
                      <admst:variable name="expressionDeriv2" select="(1.0/$a2)"/>
                    </admst:when>
                    <admst:when test="[$a2Deriv2 = '1.0']">
                      <admst:variable name="expressionDeriv2" select="(($a2-$a1)/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDeriv2" select="(($a2-($a1*$a2Deriv2))/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:otherwise>
                  <admst:choose>
                    <admst:when test="[$a2 = '1.0']">
                      <admst:variable name="expressionDeriv2" select="$a1Deriv2"/>
                    </admst:when>
                    <admst:when test="[$a2Deriv2 = '0.0']">
                      <admst:variable name="expressionDeriv2" select="($a1Deriv2/$a2)"/>
                    </admst:when>
                    <admst:when test="[$a2Deriv2 = '1.0']">
                      <admst:variable name="expressionDeriv2" select="(($a2*$a1Deriv2-$a1)/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDeriv2" select="(($a2*$a1Deriv2-$a1*$a2Deriv2)/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:otherwise>
              </admst:choose>
              <!-- now second derivatives... yuck -->
              <!-- three big terms, second term has three sub-terms -->
              <!-- First term is just $a1Deriv12/$a2 -->
              <admst:choose>
                <admst:when test="[$a1Deriv12 = '0.0' ]">
                  <admst:variable name="term1" select=""/>
                </admst:when>
                <admst:when test="[$a1Deriv12 = '1.0' ]">
                  <admst:variable name="term1" select="1.0/$a2"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term1" select="$a1Deriv12/$a2"/>
                </admst:otherwise>
              </admst:choose>
              <!-- term2 has three terms in numerator: a1Deriv*a2Deriv2+a1Deriv2*a2Deriv+a1*a2Deriv12 and denominator is $a2*$a2 -->
              <!-- term2 is subtracted from term1 -->
              <admst:choose>
                <admst:when test="[$a1Deriv = '0.0' or $a2Deriv2 = '0.0']">
                  <admst:variable name="term2a" select=""/>
                </admst:when>
                <admst:when test="[$a1Deriv = '1.0' and $a2Deriv2 = '1.0']">
                  <admst:variable name="term2a" select="1.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv = '1.0']">
                  <admst:variable name="term2a" select="$a2Deriv2"/>
                </admst:when>
                <admst:when test="[$a2Deriv2 = '1.0']">
                  <admst:variable name="term2a" select="$a1Deriv"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term2a" select="$a1Deriv*$a2Deriv2"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a1Deriv2 = '0.0' or $a2Deriv = '0.0']">
                  <admst:variable name="term2b" select=""/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0' and $a2Deriv = '1.0']">
                  <admst:variable name="term2b" select="1.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv2 = '1.0']">
                  <admst:variable name="term2b" select="$a2Deriv"/>
                </admst:when>
                <admst:when test="[$a2Deriv = '1.0']">
                  <admst:variable name="term2b" select="$a1Deriv2"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term2b" select="$a1Deriv2*$a2Deriv"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$a1 = '0.0' or $a2Deriv12 = '0.0']">
                  <admst:variable name="term2c" select=""/>
                </admst:when>
                <admst:when test="[$a1 = '1.0' and $a2Deriv12 = '1.0']">
                  <admst:variable name="term2c" select="1.0"/>
                </admst:when>
                <admst:when test="[$a1 = '1.0']">
                  <admst:variable name="term2c" select="$a2Deriv12"/>
                </admst:when>
                <admst:when test="[$a2Deriv12 = '1.0']">
                  <admst:variable name="term2c" select="$a1"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="term2c" select="$a1*$a2Deriv12"/>
                </admst:otherwise>
              </admst:choose>
              <admst:variable name="term2" select="$term2a"/>
              <admst:if test="[not($term2='') and not($term2b='')]">
                <admst:variable name="term2" select="$term2+"/>
              </admst:if>
              <admst:variable name="term2" select="$term2$term2b"/>
              <admst:if test="[not($term2='') and not($term2c='')]">
                <admst:variable name="term2" select="$term2+"/>
              </admst:if>
              <admst:variable name="term2" select="$term2$term2c"/>
              <admst:if test="[not($term2='')]">
                <admst:variable name="term2" select="-($term2/$a2/$a2)"/>
              </admst:if>
              <!-- term3 is just 2*a1*a2Deriv*a2Deriv2/a2/a2/a2 -->
              <admst:choose>
                <admst:when test="[$a1 = '0.0' or $a2Deriv='0.0' or $a2Deriv2='0.0']">
                  <admst:variable name="term3" select=""/>
                </admst:when>
                <admst:when test="[$a1 = '1.0' and $a2Deriv='1.0' and $a2Deriv2='1.0']">
                  <admst:variable name="term3" select="2.0/$a2/$a2/$a2"/>
                </admst:when>
                <admst:otherwise>
                  <admst:choose>
                    <admst:when test="[$a1 = '1.0' and $a2Deriv='1.0']">
                      <admst:variable name="factor1" select="1.0"/>
                    </admst:when>
                    <admst:when test="[$a1 = '1.0']">
                      <admst:variable name="factor1" select="$a2Deriv"/>
                    </admst:when>
                    <admst:when test="[$a2Deriv='1.0']">
                      <admst:variable name="factor1" select="$a1"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="factor1" select="$a1*$a2Deriv"/>
                    </admst:otherwise>
                  </admst:choose>
                  <admst:choose>
                    <admst:when test="[$factor1 = '1.0']">
                      <admst:variable name="term3" select="2*$a2Deriv2/$a2/$a2/$a2"/>
                    </admst:when>
                    <admst:when test="[$a2Deriv2 = '1.0']">
                      <admst:variable name="term3" select="2*$factor1/$a2/$a2/$a2"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="term3" select="2*$factor1*$a2Deriv2/$a2/$a2/$a2"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:otherwise>
              </admst:choose>
              <admst:variable name="expressionDeriv12" select="$term1"/>
              <admst:if test="[not($expressionDeriv12='') and not($term2='')]">
                <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
              </admst:if>
              <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term2"/>
              <admst:if test="[not($expressionDeriv12='') and not($term3='')]">
                <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
              </admst:if>
              <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term3"/>
              <admst:choose>
                <admst:when test="[$expressionDeriv12='']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="($expressionDeriv12)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <!-- now sensitivity deriv if needed -->
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arg1/#Pdependent) or exists(arg2/#Pdependent)) ]">
              <admst:choose>
                <admst:when test="[$a1DerivX='0.0' and $a2DerivX='0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1 = '1.0']">
                  <admst:choose>
                    <admst:when test="[$a2DerivX = '1.0']">
                      <admst:variable name="expressionDerivX" select="(-1.0/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDerivX" select="(-$a2DerivX/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:when test="[$a1DerivX = '0.0']">
                  <admst:choose>
                    <admst:when test="[$a2DerivX = '1.0']">
                      <admst:variable name="expressionDerivX" select="(-$a1/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDerivX" select="(-$a1*$a2DerivX/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:when test="[$a1DerivX = '1.0']">
                  <admst:choose>
                    <admst:when test="[$a2DerivX = '0.0']">
                      <admst:variable name="expressionDerivX" select="(1.0/$a2)"/>
                    </admst:when>
                    <admst:when test="[$a2DerivX = '1.0']">
                      <admst:variable name="expressionDerivX" select="(($a2-$a1)/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDerivX" select="(($a2-($a1*$a2DerivX))/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:otherwise>
                  <admst:choose>
                    <admst:when test="[$a2 = '1.0']">
                      <admst:variable name="expressionDerivX" select="$a1DerivX"/>
                    </admst:when>
                    <admst:when test="[$a2DerivX = '0.0']">
                      <admst:variable name="expressionDerivX" select="($a1DerivX/$a2)"/>
                    </admst:when>
                    <admst:when test="[$a2DerivX = '1.0']">
                      <admst:variable name="expressionDerivX" select="(($a2*$a1DerivX-$a1)/$a2/$a2)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDerivX" select="(($a2*$a1DerivX-$a1*$a2DerivX)/$a2/$a2)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <!-- We are assuming that no other binary ops have meaningful derivatives.  Not exactly
           a safe assumption, but all the cool kids are doing it. -->
      <admst:otherwise>
        <admst:variable name="expression" select="($a1%(bname(.)/[name='bname']/value)$a2)"/>
        <admst:variable name="expressionDeriv" select="0.0"/>
        <admst:variable name="expressionDeriv2" select="0.0"/>
        <admst:variable name="expressionDeriv12" select="0.0"/>
        <admst:variable name="expressionDerivX" select="0.0"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>
  </admst:template>

  <!--
   =================================================================-
   mapply_ternary
   Given a ternary operator (cond)?yes:no
   format for C++
   =================================================================-
  -->
  <admst:template match="mapply_ternary">
    <admst:apply-templates select="arg1" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a1" select="%s"/>
    </admst:apply-templates>
    <admst:if test="[$globalCurrentScope='sensitivity']">
      <admst:apply-templates select="arg2" match="recursiveDetectParameterDependence">
        <admst:variable name="arg2Pdep" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="recursiveDetectParameterDependence">
        <admst:variable name="arg3Pdep" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
    </admst:if>
    <admst:apply-templates select="arg2" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a2" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv')/value"/>
      <admst:variable name="a2Deriv" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv2')/value"/>
      <admst:variable name="a2Deriv2" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv12')/value"/>
      <admst:variable name="a2Deriv12" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDerivX')/value"/>
      <admst:variable name="a2DerivX" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg3" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a3" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv')/value"/>
      <admst:variable name="a3Deriv" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv2')/value"/>
      <admst:variable name="a3Deriv2" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDeriv12')/value"/>
      <admst:variable name="a3Deriv12" select="%s"/>
      <admst:value-of select="returned('returnedExpressionDerivX')/value"/>
      <admst:variable name="a3DerivX" select="%s"/>
    </admst:apply-templates>
    <admst:variable name="expressionDeriv2" select="0.0"/>
    <admst:variable name="expressionDeriv12" select="0.0"/>
    <admst:variable name="expressionDerivX" select="0.0"/>
    <admst:choose>
      <admst:when test="[$globalCurrentScope='sensitivity']">
        <admst:variable name="expression" select="($a1?$a2:$a3)"/>
        <admst:choose>
          <admst:when test="[$arg2Pdep = 'yes' or $arg3Pdep='yes']">
            <admst:variable name="expressionDerivX" select="($a1?$a2DerivX:$a3DerivX)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expressionDerivX" select="0.0"/>
          </admst:otherwise>
        </admst:choose>
        <admst:variable name="expressionDeriv" select=""/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="expression" select="($a1?$a2:$a3)"/>
        <admst:variable name="expressionDeriv" select="($a1?$a2Deriv:$a3Deriv)"/>
        <admst:variable name="expressionDeriv2" select="($a1?$a2Deriv2:$a3Deriv2)"/>
        <admst:variable name="expressionDeriv12" select="($a1?$a2Deriv12:$a3Deriv12)"/>
        <admst:variable name="expressionDerivX" select="($a1?$a2DerivX:$a3DerivX)"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>
  </admst:template>

  <!--
   =================================================================-
   assignment
   Given an assignment, format it for C++

   Special Case:  If the assignment happens to be one that uses
   $limit, we don't emit anything.  Those special things are handled
   differently.
   =================================================================-
  -->
  <admst:template match="assignment">
    <admst:assert test="adms[datatypename='assignment']" format="assignment template called with something that is not an assignment\n"/>
    <!-- Try skipping assignments to output variables (only) in sensitivity context, and assignments where the RHS contains output variables -->
    <admst:if test="[$globalCurrentScope != 'sensitivity' or ($globalCurrentScope='sensitivity' and not((lhs/insource='no' and lhs/output='yes') or (lhs/insource='no' and exists(rhs/variable[output='yes' and insource='no' and input='no']))))]">
      <admst:choose>
        <admst:when test="[nilled(rhs/function/[name='\$limit'])]">
          <admst:variable name="saveTemplateUse" select="$globalMustUseTemplate"/>
          <admst:variable name="saveScalarForce" select="$globalMustForceScalar"/>
          <!-- if the lhs has any probe dependence recorded, then it's a Fad type -->
          <admst:if test="[exists(lhs/probe) and $globalCurrentScope!='sensitivity']">
            <admst:variable name="globalMustUseTemplate" select="yes"/>
          </admst:if>
          <!-- Make sure we check parameter dependence of rhs and lhs variables-->
          <admst:if test="[$globalCurrentScope='sensitivity']">
            <admst:apply-templates select="lhs" match="collectParamDependence"/>
            <admst:if test="[exists(lhs/#Pdependent)]">
              <admst:variable name="globalMustUseTemplate" select="yes"/>
            </admst:if>
          </admst:if>
          <admst:if test="[$globalCurrentScope='sensitivity']">
            <admst:apply-templates select="rhs" match="collectParamDependence"/>
          </admst:if>
          <!-- If RHS contains any function calls other than
               $simparam, ddt, and ddx, precompute them -->
          <admst:text test="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx' and $skipFunctionPrecomp='n']" format="{\n"/>
          <admst:apply-templates select="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx' and $skipFunctionPrecomp='n']" match="functionPrecomputation"/>
          <!-- Let's emit the derivatives of the assignment first -->
          <admst:if test="[lhs/type='real']">
            <admst:apply-templates select="rhs/[not(nilled(function[name!='\$simparam' and name!='ddt' and name!='ddx']))]" match="functionDerivativePrecomputation"/>
            <admst:if test="[$globalCurrentScope!='sensitivity' and not(nilled(lhs/probe)) and $skipFunctionPrecomp='n'  and (lhs/insource='yes' or not(nilled(lhs/ddxprobe)))]">
              <admst:text format="\n"/>
              <admst:variable name="needinitialize" select="no"/>
              <admst:for-each select="lhs/probe">
                <admst:variable name="myVar" path=".."/>
                <admst:variable name="myprobe" path="."/>
                <admst:if test="[not(exists(../../rhs/probe[branch/pnode=$myprobe/branch/pnode and branch/nnode=$myprobe/branch/nnode]))]">
                  <admst:text format="d_%($myVar/name)_d%(nature)_%($myprobe/branch/pnode)_%($myprobe/branch/nnode) = "/>
                  <admst:if test="[../insource='yes' and $doSecondDerivs='yes']">
                    <admst:if test="[exists(../ddxprobe/branch/pnode[.=$myprobe/branch/pnode or .=$myprobe/branch/nnode])]">
                      <admst:for-each select="$myVar/probe">
                        <admst:text format="d_%($myVar/name)_d%($myprobe/nature)_%($myprobe/branch/pnode)_%($myprobe/branch/nnode)_d%(nature)_%(branch/pnode)_%(branch/nnode) = "/>
                      </admst:for-each>
                    </admst:if>
                  </admst:if>
                  <admst:variable name="needinitialize" select="yes"/>
                </admst:if>
              </admst:for-each>
              <admst:if test="[$needinitialize = 'yes']">
                <admst:text format=" 0.0;\n"/>
              </admst:if>
            </admst:if>
            <admst:if test="[$globalCurrentScope!='sensitivity' and not(nilled(rhs/probe)) and (lhs/insource='yes' or not(nilled(lhs/ddxprobe)))]">
              <admst:variable name="theLHS" path="lhs"/>
              <admst:variable name="theRHS" path="rhs"/>
              <admst:for-each select="rhs/probe">
                <admst:variable name="derivProbe" select="%(.)"/>
                <admst:apply-templates select="$theRHS/tree" match="%(adms/datatypename)">
                  <admst:variable name="rhsDeriv" value="%(returned('returnedExpressionDeriv')/value)"/>
                </admst:apply-templates>
                <admst:variable name="lhsname" select="d_%($theLHS/name)_d%(nature)_%(branch/pnode)_%(branch/nnode)"/>
                <admst:if test="[$lhsname != $rhsDeriv]">
                  <admst:text format="$lhsname = $rhsDeriv;\n"/>
                </admst:if>
              </admst:for-each>
              <admst:if test="[lhs/insource='yes']">
                <!-- now handle the second derivatives as needed if there are ddxprobes in the lhs
                     It would probably be cleaner to do this in the loop above, but it is neither
                     necessary (I think) nor particularly readable.  So we redo loops -->
                <admst:if test="[$doSecondDerivs='yes']">
                  <admst:for-each select="$theLHS/probe">
                    <!-- skip any on which the RHS doesn't depend, because we've already
                         handled those with explicit 0.0 initialization -->
                    <admst:variable name="myprobe" path="."/>
                    <admst:if test="[exists(../../rhs/probe[branch/pnode=$myprobe/branch/pnode and branch/nnode=$myprobe/branch/nnode])]">
                      <admst:if test="$theLHS/ddxprobe/branch/pnode[.=$myprobe/branch/pnode or .=$myprobe/branch/nnode]">
                        <admst:variable name="derivProbe" select="%(.)"/>
                        <admst:for-each select="$theLHS/probe">
                          <admst:variable name="derivProbe2" select="%(.)"/>
                          <admst:apply-templates select="$theRHS/tree" match="%(adms/datatypename)">
                            <admst:variable name="rhsDeriv12" value="%(returned('returnedExpressionDeriv12')/value)"/>
                          </admst:apply-templates>
                          <admst:variable name="lhsname" select="d_%($theLHS/name)_d%($derivProbe/nature)_%($derivProbe/branch/pnode)_%($derivProbe/branch/nnode)_d%($derivProbe2/nature)_%($derivProbe2/branch/pnode)_%($derivProbe2/branch/nnode)"/>
                          <admst:if test="[$lhsname != $rhsDeriv12]">
                            <admst:text format="$lhsname = $rhsDeriv12;\n"/>
                          </admst:if>
                        </admst:for-each>
                      </admst:if>
                    </admst:if>
                  </admst:for-each>
                </admst:if>
              </admst:if>
            </admst:if>
            <!-- if we *ARE* in sensitivity context, emit the derivatives of the expression w.r.t. "X" -->
            <admst:if test="[$globalCurrentScope='sensitivity' and exists(lhs/#Pdependent)]">
              <admst:variable name="theLHS" path="lhs"/>
              <admst:variable name="theRHS" path="rhs"/>
              <admst:apply-templates select="$theLHS" match="%(adms/datatypename)">
                <admst:variable name="lhsname" select="%(returned('returnedExpressionDerivX')/value)"/>
              </admst:apply-templates>
              <admst:apply-templates select="$theRHS/tree" match="%(adms/datatypename)">
                <admst:variable name="rhsDerivX" value="%(returned('returnedExpressionDerivX')/value)"/>
              </admst:apply-templates>
              <admst:if test="[$lhsname != $rhsDerivX]">
                <admst:text format="$lhsname = $rhsDerivX;\n"/>
              </admst:if>
            </admst:if>
          </admst:if>
          <admst:apply-templates select="lhs" match="processTerm">
            <admst:variable name="lhsname" select="%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
          <admst:apply-templates select="rhs" match="processTerm">
            <admst:variable name="rhsexpr" select="%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
          <admst:if test="[$lhsname != $rhsexpr]">
            <admst:text format="$lhsname = $rhsexpr;\n"/>
          </admst:if>

          <admst:variable name="globalMustUseTemplate" select="$saveTemplateUse"/>
          <admst:variable name="globalMustForceScalar" select="$saveScalarForce"/>
          <admst:text test="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx' and $skipFunctionPrecomp='n']" format="}\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="." match="limiterAssignment"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
  </admst:template>

  <!--
   =================================================================-
   limiterAssignment
   Handle special case output for assignments that involve limiters
   These require lots of extra output, and it's only part of the deal.
   =================================================================-
  -->
  <admst:template match="limiterAssignment">
    <admst:choose>
      <admst:when test="[$globalCurrentScope='sensitivity']">
        <!-- The probeVars for "typed" limiters must be pre-multiplied by the
             type variable anyway, so for sensitivity (which doesn't do
             limiting) just do the assignment -->
        <admst:text format="%(printTerm(lhs)) = probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="\n\n//%(printTerm(lhs)) = %(rhs);\n"/>
        <admst:text format="if (getDeviceOptions().voltageLimiterFlag)\n"/>
        <admst:text format="{\n"/>
        <admst:text format="  int icheck=0;\n"/>
        <admst:choose>
          <admst:when test="[rhs/function[name='\$limit']/arguments[2]/datatypename='string']">
            <admst:choose>
              <!-- the string could be "pnjlim" or "fetlim" -->
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='pnjlim' or rhs/function[name='\$limit']/arguments[2]/value='typedpnjlim']">
                <!-- handle "pnjlim" -->
                <admst:text format="  %(printTerm(lhs))_limited = devSupport.pnjlim(%(printTerm(lhs))_limited,%(printTerm(lhs))_old,%(printTerm((rhs/function[name='\$limit']/arguments[3]))),%(printTerm((rhs/function[name='\$limit']/arguments[4]))),&amp;icheck);\n"/>
              </admst:when>
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='pnjlim_new' or rhs/function[name='\$limit']/arguments[2]/value='typedpnjlim_new']">
                <!-- handle "pnjlim_new" -->
                <admst:text format="  %(printTerm(lhs))_limited = devSupport.pnjlim_new(%(printTerm(lhs))_limited,%(printTerm(lhs))_old,%(printTerm((rhs/function[name='\$limit']/arguments[3]))),%(printTerm((rhs/function[name='\$limit']/arguments[4]))),&amp;icheck);\n"/>
              </admst:when>
              <!-- if "fetlim" we would do something else, but for now nothing... -->
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='fetlim' or rhs/function[name='\$limit']/arguments[2]/value='typedfetlim']">
                <admst:warning format="Warning: fetlim not implemented, ignoring."/>
              </admst:when>
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='dummy' or rhs/function[name='\$limit']/arguments[2]/value='typeddummy']">
                <admst:text format="  // dummy limiting for initialization purposes\n"/>
              </admst:when>
              <!-- KLUDGE ALERT!  ADMS has a bug.  It does not properly allow us to
                   pass the name of the analog function to the $limit function as it
                   should, and pukes an error saying "identifier never declared."
                   To get something usable, I am going to support passing a string
                   other than pnjlim or fetlim, and treat it as an analog function
                   name if so.  This is NOT standard verilog and needs fixing. -->

              <admst:otherwise>
                <admst:text format="  %(printTerm(lhs))_limited = AnalogFunctions::%(rhs/function[name='\$limit']/arguments[2]/value)(%(printTerm(lhs))_limited,%(printTerm(lhs))_old"/>
                <admst:if test="[count(rhs/function[name='\$limit']/arguments)>2]">
                  <admst:choose>
                    <admst:when test="[rhs/function[name='\$limit']/arguments[3]/value = 'typed']">
                      <admst:if test="[count(rhs/function[name='\$limit']/arguments)>4]">
                        <admst:text format=","/>
                        <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>4]" separator=",">
                          <admst:text format="%(printTerm(.))"/>
                        </admst:join>
                      </admst:if>
                    </admst:when>
                    <admst:otherwise>
                      <admst:text format=","/>
                      <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>2]" separator=",">
                        <admst:text format="%(printTerm(.))"/>
                      </admst:join>
                    </admst:otherwise>
                  </admst:choose>
                </admst:if>
                <admst:text format=");\n"/>
                <admst:text format="if (%(printTerm(lhs))_limited != %(printTerm(lhs))_orig)\n"/>
                <admst:text  format="{\n"/>
                <admst:text  format="icheck=1;\n"/>
                <admst:text  format="}\n"/>
              </admst:otherwise>

            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:text format="  %(printTerm(lhs))_limited = AnalogFunctions::%(rhs/function[name='\$limit']/arguments[2])((%(printTerm(lhs))_limited,%(printTerm(lhs))_old"/>
            <admst:if test="[count(rhs/function[name='\$limit']/arguments)>2]">
              <admst:text format=","/>
              <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>2]" separator=",">
                <admst:text format="%(printTerm(.))"/>
              </admst:join>
            </admst:if>
            <admst:text format=");\n"/>
          </admst:otherwise>
        </admst:choose>
        <admst:text format="  if (icheck == 1)\n"/>
        <admst:text format="     origFlag = false;\n"/>

        <admst:text format="  if (!origFlag)\n  {\n"/>
        <admst:text format="    probeDiffs[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)] = %(printTerm(lhs))_limited - %(printTerm(lhs))_orig;\n"/>
        <admst:text format="    probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)] += probeDiffs[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n"/>
        <admst:text format="  }\n"/>
        <admst:text format="}\n"/>
        <admst:text format="%(printTerm(lhs)) = probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n\n"/>
        <admst:variable name="rhsprobe" select="%(rhs/function[name='\$limit']/arguments[1])"/>
        <admst:text format="d_%(printTerm(lhs))_d%($rhsprobe/nature)_%($rhsprobe/branch/pnode)_%($rhsprobe/branch/nnode) = d_probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)][%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
<!--
   =================================================================-
   contribution
   Given a contribution, format it for xyce's updateIntermediateVars

   This template is complicated by the need to compute Jdxp terms
   when we are working with any RHS that involves limited probes.
   =================================================================-
  -->
  <admst:template match="contribution">
    <!-- Do sanity check to make sure we're actually processing a contribution
    -->
    <admst:assert test="adms[datatypename='contribution']" format="contribution template called with something that is not a contribution\n"/>

    <!-- force template functions used on rhs to be explicitly instantiated -->
    <admst:variable name="saveTemplateUse" select="$globalMustUseTemplate"/>
    <admst:variable name="globalMustUseTemplate" select="yes"/>

    <!-- actual contribution processing done here -->
    <admst:text format="// %(lhs) &lt;+ %(rhs)\n"/>

    <!-- static and dynamic go to different places (F vs. Q) -->
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:variable name="mode" select="dynamic"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="mode" select="static"/>
      </admst:otherwise>
    </admst:choose>

    <admst:if test="[$globalCurrentScope='sensitivity']">
      <admst:apply-templates select="rhs" match="collectParamDependence"/>
    </admst:if>

    <admst:choose>

      <!-- Contributions into potential sources with rhs 0 are only
           used for node collapse in set-up, so do nothing -->
      <admst:when test="[lhs/discipline/potential=lhs/nature and (rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">
        <admst:text format="// do nothing at all\n"/>
      </admst:when>

      <!-- Contributions into potential sources that are nonzero are
           really different.  In this case, we add/subtract the
           associated branch current from the pos and negative nodes,
           and also add to the branch equation -->
      <admst:when test="[lhs/discipline/potential=lhs/nature]">
        <!-- do nothing if a noise term -->
        <admst:if test="[whitenoise='no' and flickernoise='no']">
          <!-- Positive and negative nodes get +/- the branch variable value -->
          <!-- But this is not done once for every contribution to a source,
               just once for each source!  So these terms will be done
               in the same finish-up operation mentioned below -->
          <admst:variable name="branchConstant" select="%(xyceBranchConstantName(lhs/branch)/[name='branchConstant']/value)"/>

          <admst:choose>
            <admst:when test="[count(module/@limitedProbes)>0 and not(nilled(rhs/probe/[#limited='yes'])) and not ($globalCurrenScope='sensitivity')]">
              <!-- Special processing when RHS involves limited probes -->
              <admst:text format="{\n"/>
              <admst:text format="double contribTemp;\n"/>
              <admst:for-each select="rhs/probe">
                <admst:text format="double d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode);\n"/>
              </admst:for-each>
              <admst:text format="contribTemp = %(printTerm(rhs));\n"/>
              <admst:for-each select="rhs/probe">
                <admst:text format="d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode) = /*diff(%(printTerm(..)),%(nature)_%(branch/pnode)_%(branch/nnode))*/;\n"/>
                <admst:warning format="Model uses nonzero contributions into voltage branch and RHS is probe-dependent.  This is not correctly handled yet.\n"/>
              </admst:for-each>
              <admst:text format="%($mode)Contributions[%($branchConstant)] += contribTemp;\n"/>
              <admst:for-each select="rhs/probe">
                <admst:text format="d_%($mode)Contributions[%($branchConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)] += d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode);\n"/>
              </admst:for-each>
              <admst:text format="Jdxp_%($mode)[$branchConstant] += "/>
              <admst:join select="rhs/probe[#limited='yes']" separator="+">
                <admst:text format="d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode)*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*d_probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
              </admst:join>
              <admst:text format=";\n"/>

            </admst:when>

            <admst:otherwise>
              <!-- this is the simple case, no limiting needed -->
              <!-- Branch equation gets + the RHS -->
              <admst:text test="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx']" format="{\n"/>
              <admst:apply-templates select="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx']" match="functionPrecomputation"/>
              <admst:apply-templates select="rhs/[not(nilled(function))]" match="functionDerivativePrecomputation"/>
              <admst:if test="[not($globalCurrentScope='sensitivity')]">
                <admst:for-each select="rhs/probe">
                  <admst:variable name="derivProbe" select="%(.)"/>
                  <admst:apply-templates select="../tree" match="%(adms/datatypename)">
                    <admst:variable name="rhsDeriv" value="%(returned('returnedExpressionDeriv')/value)"/>
                  </admst:apply-templates>

                  <admst:text format="d_%($mode)Contributions[%($branchConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)] += %($rhsDeriv);\n"/>
                </admst:for-each>
              </admst:if>
              <admst:if test="[$globalCurrentScope='sensitivity']">
                <admst:apply-templates select="rhs/tree" match="%(adms/datatypename)">
                  <admst:variable name="rhsDerivX" value="%(returned('returnedExpressionDerivX')/value)"/>
                </admst:apply-templates>

                <admst:text format="d_%($mode)Contributions_dX[%($branchConstant)] += %($rhsDerivX);\n"/>
              </admst:if>
              <!-- sensitivity doesn't actually need to store the value of the contribution, just deriv -->
              <admst:if test="[$globalCurrentScope != 'sensitivity']">
                <admst:text format="%($mode)Contributions[%($branchConstant)] += %(printTerm(rhs));\n"/>
              </admst:if>
              <admst:text test="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx']" format="}\n"/>
            </admst:otherwise>
          </admst:choose>

          <!-- There is one last contribution necessary, but we don't do it here.
               The branch equation also needs to get - the potential
               from the solution, but it should only get this once, and there
               could be multiple contributions to this potential.  We'll
               have to do it in a finish-up loop later -->
        </admst:if>
      </admst:when>

      <!-- Otherwise it's a contribution into flow source, which is
           the most most straightforward case -->
      <admst:otherwise>
        <!-- do nothing if a noise term -->
        <admst:if test="[whitenoise='no' and flickernoise='no']">
          <admst:variable name="pnode" select="%(lhs/branch/pnode)"/>
          <admst:variable name="pnodeConstant" select="%(xyceNodeConstantName($pnode)/[name='nodeConstant']/value)"/>
          <admst:variable name="nnode" select="%(lhs/branch/nnode)"/>
          <admst:text test="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx']" format="{\n"/>
          <admst:apply-templates select="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx']" match="functionPrecomputation"/>
          <admst:apply-templates select="rhs/[not(nilled(function))]" match="functionDerivativePrecomputation"/>
          <!-- special processing when contribution RHS involves limited
               probes.  We must compute the rhs of the contribution,
               but also generate the Jdxp terms-->
          <admst:choose>
            <admst:when test="[count(module/@limitedProbes)>0 and not(nilled(rhs/probe/[#limited='yes'])) and not($globalCurrentScope='sensitivity')]">
              <admst:text format="{\n"/>
              <admst:text format="double contribTemp;\n"/>
              <admst:for-each select="rhs/probe">
                <admst:text format="double d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode);\n"/>
              </admst:for-each>
              <admst:text format="contribTemp= %(printTerm(rhs));\n"/>
              <admst:for-each select="rhs/probe">
                <admst:variable name="derivProbe" select="%(.)"/>
                <admst:apply-templates select="../tree" match="%(adms/datatypename)">
                  <admst:variable name="rhsDeriv" value="%(returned('returnedExpressionDeriv')/value)"/>
                </admst:apply-templates>
                <admst:text format="d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode) = %($rhsDeriv);\n"/>
              </admst:for-each>
              <admst:text format="%($mode)Contributions[$pnodeConstant] += contribTemp;\n"/>
              <admst:for-each select="rhs/probe">
                <admst:text format="d_%($mode)Contributions[%($pnodeConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)] += d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode);\n"/>
              </admst:for-each>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="%($mode)Contributions[$nnodeConstant] -= contribTemp;\n"/>
                <admst:for-each select="rhs/probe">
                  <admst:text format="d_%($mode)Contributions[%($nnodeConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)] -= d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode);\n"/>
                </admst:for-each>
              </admst:if>

              <admst:text format="\n"/>

              <!-- generate the Jdxp's:
                   Jdxp[pnode]+= d(rhs)/d(probe)*deltaprobe*dlimitedprobe/dprobe

                   The "dlimitedprobe/dprobe" thing is to handle cases
                   where there could be a minus sign introduced by limiting,
                   which can happen with PNP/PMOS vs. NPN/NMOS limiting hacks.

                   Similar for Jdxp[nnode]
                   -->
              <admst:text format="Jdxp_%($mode)[$pnodeConstant] += "/>
              <admst:join select="rhs/probe[#limited='yes']" separator="+">
                <admst:text format="d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode)*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*d_probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
              </admst:join>
              <admst:text format=";\n"/>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="Jdxp_%($mode)[$nnodeConstant] -= "/>
                <admst:join select="rhs/probe[#limited='yes']" separator="+">
                <admst:text format="d_contribTemp_d%(nature)_%(branch/pnode)_%(branch/nnode)*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*d_probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
                </admst:join>
                <admst:text format=";\n"/>
              </admst:if>
              <admst:text format="}\n"/>
            </admst:when>

            <!-- When no limiting, this is much simpler: Just output RHS -->
            <admst:otherwise>
              <admst:if test="[$globalCurrentScope!='sensitivity']">
                <admst:text format="%($mode)Contributions[$pnodeConstant] += %(printTerm(rhs));\n"/>
              </admst:if>
              <admst:if test="[$globalCurrentScope='sensitivity']">
                <admst:apply-templates select="rhs/tree" match="%(adms/datatypename)">
                  <admst:variable name="rhsDerivX" value="%(returned('returnedExpressionDerivX')/value)"/>
                </admst:apply-templates>
                <admst:text format="d_%($mode)Contributions_dX[%($pnodeConstant)]+= %($rhsDerivX);\n"/>
              </admst:if>
              <admst:if test="[not($globalCurrentScope='sensitivity')]">
                <admst:for-each select="rhs/probe">
                <admst:variable name="derivProbe" select="%(.)"/>
                <admst:apply-templates select="../tree" match="%(adms/datatypename)">
                  <admst:variable name="rhsDeriv" value="%(returned('returnedExpressionDeriv')/value)"/>
                </admst:apply-templates>
                <admst:text format="d_%($mode)Contributions[%($pnodeConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)] += %($rhsDeriv);\n"/>
                </admst:for-each>
              </admst:if>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:if test="[$globalCurrentScope!='sensitivity']">
                  <admst:text format="%($mode)Contributions[$nnodeConstant] -= %(printTerm(rhs));\n"/>
                </admst:if>
                <admst:if test="[$globalCurrentScope='sensitivity']">
                  <admst:apply-templates select="rhs/tree" match="%(adms/datatypename)">
                    <admst:variable name="rhsDerivX" value="%(returned('returnedExpressionDerivX')/value)"/>
                  </admst:apply-templates>
                  <admst:text format="d_%($mode)Contributions_dX[($nnodeConstant)]-= %($rhsDerivX);\n"/>
                </admst:if>
                <admst:if test="[not($globalCurrentScope='sensitivity')]">
                  <admst:for-each select="rhs/probe">
                    <admst:variable name="derivProbe" select="%(.)"/>
                    <admst:apply-templates select="../tree" match="%(adms/datatypename)">
                      <admst:variable name="rhsDeriv" value="%(returned('returnedExpressionDeriv')/value)"/>
                    </admst:apply-templates>
                    <admst:text format="d_%($mode)Contributions[%($nnodeConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)] -= %($rhsDeriv);\n"/>
                  </admst:for-each>
                </admst:if>
              </admst:if>
            </admst:otherwise>
          </admst:choose>
          <admst:text test="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx']" format="}\n"/>
        </admst:if>
          <!-- we will handle only very specific types of  noise contributions,
               those whose RHS is strictly a single noise function.  This is
               enforced by the assertions in xyceNoiseContributionName.  Get
               its name -->
        <admst:if test="[(whitenoise='yes' or flickernoise='yes') and not($globalCurrentScope='sensitivity')]">
          <admst:variable name="theNoiseContributionName" select="%(xyceNoiseContributionName(.))"/>
          <admst:text format="if (getSolverState().noiseFlag)\n{\n"/>
          <!-- now force scalar, because we're assigning to a double value -->
          <admst:variable name="saveForceScalar" select="$globalMustForceScalar"/>
          <admst:variable name="globalMustForceScalar" select="yes"/>
          <admst:apply-templates select="rhs/function[name!='\$simparam' and name!='ddt' and name!='ddx']" match="functionPrecomputation"/>
          <admst:text format="  noiseContribsPower[%(#noiseContIndex)]="/>
          <!-- extract the power argument, the first one-->
          <admst:text format=" %(printTerm(rhs/tree/arguments[1]));\n"/>
          <!-- flicker noise has an extra argument -->
          <admst:if test="[rhs/tree/name='flicker_noise']">
            <admst:text format="  noiseContribsExponent[%(#noiseContIndex)]="/>
            <admst:text format=" %(printTerm(rhs/tree/arguments[2]));\n"/>
          </admst:if>
          <admst:text format="}\n"/>
          <admst:variable name="globalMustForceScalar" select="$saveForceScalar"/>
        </admst:if>

      </admst:otherwise>
    </admst:choose>
    <admst:variable name="globalMustUseTemplate" select="$saveTemplateUse"/>
  </admst:template>

  <!--
   =================================================================-
   probe
   Given a probe, format it for xyce's updateIntermediateVars
   =================================================================-
  -->
  <admst:template match="probe">
    <admst:variable name="expression" select="(probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)])"/>
    <admst:variable name="expressionDeriv2" select="0.0"/>
    <admst:variable name="expressionDeriv12" select="0.0"/>
    <admst:variable name="expressionDerivX" select="0.0"/>
    <admst:choose>
      <admst:when test="[.=$derivProbe]">
        <admst:variable name="expressionDeriv" select="d_probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="expressionDeriv" select="0.0"/>
      </admst:otherwise>
    </admst:choose>
    <admst:if test="$derivProbe2">
      <admst:choose>
        <admst:when test="[.=$derivProbe2]">
          <admst:variable name="expressionDeriv2" select="d_probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expressionDeriv2" select="0.0"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
    <admst:return name="returnedExpression" value="$expression"/>
    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>
  </admst:template>

  <!--
   =================================================================-
   variable
   given a variable, emit C++ reference thereto
   =================================================================-
  -->
  <admst:template match="variable">
    <admst:assert test="adms[datatypename='variable']" format="variable template called on non-variable\n"/>
    <admst:variable name="expressionDerivX" select="0.0"/>
    <admst:choose>
      <admst:when test="[scope='local']">
        <admst:variable name="expression" select="%(name)"/>
      </admst:when>
      <admst:when test="[scope='global_instance']">
        <admst:choose>
          <admst:when test="[($globalCurrentScope='instance' or exists(attribute[name='xyceAlsoModel'])) and not($globalCurrentScope='sensitivity')]">
            <admst:variable name="expression" select="%(name)"/>
          </admst:when>
          <admst:when test="[$globalCurrentScope='sensitivity']">
            <admst:choose>
              <admst:when test="[input='yes']">
                <admst:choose>
                  <admst:when test="[$globalSensitivityScope='model']">
                    <admst:if test="[not exists(attribute[name='xyceAlsoModel'])]">
                      <admst:fatal format="it is not legal to access instance variable %(name) in model context!  Our current scope is $globalCurrentScope, and we are generating $globalSensitivityScope code.\n"/>
                    </admst:if>
                    <admst:variable name="expression" select="modelStruct.modelPar_%(name)"/>
                    <admst:if test="[exists(#Pdependent)]">
                      <admst:variable name="expressionDerivX" select="modelStruct.d_modelPar_%(name)_dX"/>
                    </admst:if>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expression" select="instanceStruct.instancePar_%(name)"/>
                    <admst:if test="[exists(#Pdependent)]">
                      <admst:variable name="expressionDerivX" select="instanceStruct.d_instancePar_%(name)_dX"/>
                    </admst:if>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <!-- Ooof.  Sometimes one might put an output variable on the RHS of a local variable that is neither insource nor output -->
                <!-- But we are explicitly skipping assignments and declarations of those variables, so we better not try to use them! -->
                <admst:choose>
                  <admst:when test="[insource='no' and output='yes']">
                    <admst:variable name="expression" select="1.0"/>
                    <admst:variable name="expressionDerivX" select="0.0"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expression" select="instanceStruct.instanceVar_%(name)"/>
                    <admst:if test="[exists(#Pdependent)]">
                      <admst:variable name="expressionDerivX" select="instanceStruct.d_instanceVar_%(name)_dX"/>
                    </admst:if>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="it is not legal to access instance variable %(name) outside of the instance class!  Our current scope is $globalCurrentScope\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[scope='global_model']">
        <admst:choose>
          <admst:when test="[$globalCurrentScope='model']">
            <admst:variable name="expression" select="%(name)"/>
          </admst:when>
          <admst:when test="[$globalCurrentScope='sensitivity']">
            <admst:choose>
              <admst:when test="[input='yes']">
                <admst:variable name="expression" select="modelStruct.modelPar_%(name)"/>
                <admst:if test="[exists(#Pdependent)]">
                  <admst:variable name="expressionDerivX" select="modelStruct.d_modelPar_%(name)_dX"/>
                </admst:if>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="modelStruct.modelVar_%(name)"/>
                <admst:if test="[exists(#Pdependent)]">
                  <admst:variable name="expressionDerivX" select="modelStruct.d_modelVar_%(name)_dX"/>
                </admst:if>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="(model_.%(name))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="Unknown variable scope for %(name): %(scope)\n"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Now generate derivatives with respect to probes and "X" -->
    <admst:variable name="expressionDeriv" select="0.0"/>
    <admst:variable name="expressionDeriv2" select="0.0"/>
    <admst:variable name="expressionDeriv12" select="0.0"/>
    <!-- Only have derivatives if this variable is a real variable, not
         an int or string -->
    <admst:if test="[type='real']">
      <admst:if test="[$globalCurrentScope='sensitivity' and exists(#Pdependent) and $expressionDerivX='0.0' and not(insource='no' and output='yes')]">
        <admst:variable name="expressionDerivX" select="d_%($expression)_dX"/>
      </admst:if>
      <admst:if test="[insource='yes' or not(nilled(ddxprobe))]">
        <admst:if-inside select="$derivProbe" list="%(probe)">
          <admst:variable name="expressionDeriv" select="d_%(name)_d%($derivProbe/nature/access)_%($derivProbe/branch/pnode/name)_%($derivProbe/branch/nnode/name)"/>
        </admst:if-inside>
        <admst:if test="$derivProbe2">
          <admst:if-inside select="$derivProbe2" list="%(probe)">
            <admst:variable name="expressionDeriv2" select="d_%(name)_d%($derivProbe2/nature/access)_%($derivProbe2/branch/pnode/name)_%($derivProbe2/branch/nnode/name)"/>
          </admst:if-inside>
          <admst:if test="[insource='yes' and not(nilled(ddxprobe))]">
            <admst:if-inside select="$derivProbe" list="%(probe)">
              <!-- Note that if we are doing second derivatives, it's because
                   we are differentiating something that has been ddx()ed.
                   If so, derivProbe is supposed to be the ddx-related
                   probe, and derivProbe2 is the regular derivative.
                   If derivProbe is not associated with a ddxprobe in this
                   variable, we should be returning ZERO.
              -->
              <admst:choose>
                <admst:when test="[exists(ddxprobe/branch/pnode[.=$derivProbe/branch/pnode or .=$derivProbe/branch/nnode])]">
                  <admst:if-inside select="$derivProbe2" list="%(probe)">
                    <admst:variable name="expressionDeriv12" select="d_%(name)_d%($derivProbe/nature/access)_%($derivProbe/branch/pnode/name)_%($derivProbe/branch/nnode/name)_d%($derivProbe2/nature/access)_%($derivProbe2/branch/pnode/name)_%($derivProbe2/branch/nnode/name)"/>
                  </admst:if-inside>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if-inside>
          </admst:if>
        </admst:if>
      </admst:if>
    </admst:if>

    <admst:return name="returnedExpression" value="$expression"/>
    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>
  </admst:template>

  <!--
   =================================================================-
   function
     This template depends on there having been function precomputation
     performed, with functions calls already having been evaluated
     and stored into appropriately named variables.  We simply
     emit the name of the variable instead of the call here.
     The exception will be for ddt, which may only appear on the RHS of
     a contribution, and which simply returns the argument of ddt
     for stuffing into the Q vector.
   =================================================================-
  -->
  <admst:template match="function">
    <admst:variable name="expressionDeriv" select="0.0"/>
    <admst:variable name="expressionDeriv2" select="0.0"/>
    <admst:variable name="expressionDeriv12" select="0.0"/>
    <admst:variable name="expressionDerivX" select="0.0"/>
    <admst:choose>
      <admst:when test="[name='\$port_connected']">
        <admst:assert test="arguments[1]/adms[datatypename='node']" format="\$port_connected argument must be a node\n"/>
        <admst:variable name="expression" select="portsConnected_[%(xyceNodeConstantName(arguments[1])/[name='nodeConstant']/value)]"/>
      </admst:when>
      <admst:when test="[(name='min' or name='max') and $skipFunctionPrecomp='y']">
        <admst:variable name="expression" select="%(functionCall(.)/[name='returnedExpression']/value)"/>
      </admst:when>
      <admst:when test="[name='absdelay']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="FIXMEabsdelay(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <!-- DDT is a null function in Xyce we'll load such things into
           dynamic contributions, and those will be differentiated elsewhere -->
      <admst:when test="[name='ddt']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="(%(returned('returnedExpression')/value))"/>
          <admst:variable name="expressionDeriv" select="(%(returned('returnedExpressionDeriv')/value))"/>
          <admst:if test="$derivProbe2">
            <admst:variable name="expressionDeriv2" select="(%(returned('returnedExpressionDeriv2')/value))"/>
            <admst:variable name="expressionDeriv12" select="(%(returned('returnedExpressionDeriv12')/value))"/>
          </admst:if>
          <admst:if test="[$globalCurrentScope='sensitivity' and exists(#Pdependent)]">
            <admst:variable name="expressionDerivX" select="(%(returned('returnedExpressionDerivX')/value))"/>
          </admst:if>

        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$given' or name='\$param_given']">
        <admst:variable name="arg1" select="%(arguments[1])"/>
        <admst:assert test="$arg1[datatypename='variable' and input='yes']" format="%(name): argument is not a parameter\n"/>
        <admst:choose>
          <admst:when test="$arg1/[parametertype='model']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'model']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'instance']">
                <admst:variable name="expression" select="(model_.given(&quot;$arg1&quot;))"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'sensitivity']">
                <admst:variable name="expression" select="modelStruct.modelPar_given_$arg1"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="$arg1/[parametertype='instance']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'instance']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'sensitivity']">
                <admst:variable name="expression" select="instanceStruct.instancePar_given_$arg1"/>
              </admst:when>
              <admst:otherwise>
                <admst:fatal format="Attempt to use \$given() on an instance variable outside of instance scope\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="%(name): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$temperature']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:choose>
          <admst:when test="[$globalCurrentScope='instance' or $globalCurrentScope='sensitivity']">
            <admst:variable name="expression" select="admsTemperature"/>
          </admst:when>
          <!-- KLUDGE!!!!!! -->
          <!-- Assumes that when at model scope, $temperature is taken as
               the default temperature of the simulator. -->
          <!-- At instance scope, we use whatever Xyce passed in to
               updateTemperature for that instance. -->
          <admst:when test="[$globalCurrentScope='model']">
            <admst:variable name="expression" select="admsModTemp"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$mfactor']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_MFACTOR"/>
      </admst:when>
      <admst:when test="[name='\$vt']">
        <admst:choose>
          <admst:when test="[nilled(arguments)]">
            <admst:variable name="expression" select="adms_vt_nom"/>
          </admst:when>
          <admst:when test="arguments[count(.)=1]">
            <admst:apply-templates select="arguments[1]" match="processTerm">
              <admst:choose>
                <admst:when test="[$globalCurrentScope='AF']">
                  <admst:variable name="expression" select="adms_vt(%(returned('returnedExpression')/value))"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expression" select="adms_vt(%(returned('returnedExpression')/value))"/>
                </admst:otherwise>
              </admst:choose>
            </admst:apply-templates>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$scale']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_scale"/>
      </admst:when>
      <admst:when test="[name='\$abstime' or name='\$realtime']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
          <admst:choose>
            <admst:when test="[$globalCurrentScope='sensitivity']">
              <admst:variable name="expression" select="theInstance.getSolverState().currTime_"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="getSolverState().currTime_"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='ddx']">
        <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
        <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
        <admst:assert test="arguments[2]/branch/nnode[grounded='yes']" format="%(name): probe argument has non-ground negative node [Xyce/ADMS limitation]\n"/>
        <admst:choose>
          <admst:when test="[$globalCurrentScope='sensitivity']">
            <admst:variable name="expression" select="0.0 /*FIXME: ddx(%(arguments[1]),%(arguments[2])) not implemented in sensitivity context */"/>
          </admst:when>
          <admst:otherwise>
            <!-- save any "derivProbe" value because we're monkeying with it -->
            <admst:variable name="savedDerivProbe" path="$derivProbe" />
            <admst:variable name="savedDerivProbe2" path="$derivProbe2" />
            <admst:variable name="expressionToDDX" path="arguments[1]"/>
            <admst:variable name="theDDXProbe" path="arguments[2]"/>
            <admst:variable name="expression" select=""/>
            <admst:variable name="expressionDeriv" select=""/>
            <admst:reset select="$expressionToDDX/@probe"/>
            <admst:variable name="probeList" path="$expressionToDDX/@probe"/>
            <admst:apply-templates match="recursiveDetectProbeDependence" select="$expressionToDDX"/>
            <admst:for-each select="$probeList">
              <admst:variable name="derivProbe" path="."/>
              <admst:variable name="derivProbe2" path="$savedDerivProbe"/>
              <admst:choose>
                <admst:when test="$derivProbe/branch/pnode[.=$theDDXProbe/branch/pnode]">
                  <admst:apply-templates select="$expressionToDDX" match="processTerm">
                    <admst:variable name="exprPartialDeriv" select="%(returned('returnedExpressionDeriv')/value)"/>
                    <admst:variable name="exprPartialDeriv12" select="%(returned('returnedExpressionDeriv12')/value)"/>
                  </admst:apply-templates>
                  <admst:variable name="expression" select="$expression+$exprPartialDeriv"/>
                  <admst:variable name="expressionDeriv" select="$expressionDeriv+$exprPartialDeriv12"/>
                </admst:when>
                <admst:when test="$derivProbe/branch/nnode[.=$theDDXProbe/branch/pnode]">
                  <admst:apply-templates select="$expressionToDDX" match="processTerm">
                    <admst:variable name="exprPartialDeriv" select="%(returned('returnedExpressionDeriv')/value)"/>
                    <admst:variable name="exprPartialDeriv12" select="%(returned('returnedExpressionDeriv12')/value)"/>
                  </admst:apply-templates>
                  <admst:variable name="expression" select="$expression-$exprPartialDeriv"/>
                  <admst:variable name="expressionDeriv" select="$expressionDeriv-$exprPartialDeriv12"/>
                </admst:when>
              </admst:choose>
            </admst:for-each>
            <admst:choose>
              <admst:when test="[not($expression = '')]">
                <admst:variable name="expression" select="($expression)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="0.0"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[not($expressionDeriv = '')]">
                <admst:variable name="expressionDeriv" select="($expressionDeriv)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:otherwise>
            </admst:choose>
            <!-- restore original "derivProbe"  -->
            <admst:variable name="derivProbe" path="$savedDerivProbe" />
            <admst:variable name="derivProbe2" path="$savedDerivProbe2" />
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='floor']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
          <admst:variable name="expression" select="floor($expression)"/>
          <!-- floor has all zero derivs -->
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='ceil']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
          <admst:variable name="expression" select="ceil($expression)"/>
          <!-- floor has all zero derivs -->
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$simparam']">
        <admst:choose>
          <admst:when test="[arguments[1]/datatypename='string' and arguments[1]/value='gmin']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope='sensitivity']">
                <admst:variable name="expression" select="ADMSgmin_arg"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="getDeviceOptions().gmin"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:assert test="arguments[count(.)=2]" format="Unrecognized simparam %(arguments[1]) and no expression provided.\n"/>
            <admst:apply-templates select="arguments[2]" match="processTerm">
              <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
            </admst:apply-templates>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[$skipFunctionPrecomp='y']">
        <!-- if we aren't caught by anything above, and this is set,
             proceed as normal -->
        <admst:choose>
          <admst:when test="[name='ln' or name='log' or name='sqrt']">
            <admst:variable name="expression" select="%(funcname(.)/[name='fname']/value)"/>
            <admst:variable name="args" select=""/>
            <admst:for-each select="arguments">
              <admst:if test="[$args!='']">
                <admst:variable name="args" select="$args,"/>
              </admst:if>
              <admst:apply-templates select="." match="realArgument">
                <admst:variable name="args" select="$args%(returned('argval')/value)"/>
              </admst:apply-templates>
            </admst:for-each>
            <admst:variable name="expression" select="$expression($args)"/>
          </admst:when>
          <admst:when test="[name='hypot']">
            <admst:assert test="arguments[count(.)=2]" format="hypot function must take exactly two arguments.\n"/>
            <admst:variable name="expression" value="sqrt"/>
            <admst:variable name="args" select=""/>
            <admst:for-each select="arguments">
              <admst:if test="[$args!='']">
                <admst:variable name="args" select="$args+"/>
              </admst:if>
              <admst:apply-templates select="." match="processTerm">
                <admst:variable name="args" select="$args%(returned('returnedExpression')/value)*%(returned('returnedExpression')/value)"/>
              </admst:apply-templates>
            </admst:for-each>
            <admst:variable name="expression" select="$expression($args)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="%(funcname(.)/[name='fname']/value)"/>
            <admst:variable name="args" select=""/>
            <admst:for-each select="arguments">
              <admst:if test="[$args!='']">
                <admst:variable name="args" select="$args,"/>
              </admst:if>
              <admst:apply-templates select="." match="processTerm">
                <admst:variable name="args" select="$args%(returned('returnedExpression')/value)"/>
              </admst:apply-templates>
            </admst:for-each>
            <admst:variable name="expression" select="$expression($args)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[name='exp' or name='ln' or name='log' or name='sqrt' or name='abs' or name='limexp' or name='cos' or name='sin' or name='tan' or name='acos' or name='asin' or name='atan' or name='cosh' or name='sinh' or name='tanh' or name='acosh' or name='asinh' or name='atanh' or name='pow' or name='min' or name='max' or name='hypot' or name='atan2']">
            <!-- we must use precomputed function vars -->
            <admst:variable name="expression" select="value_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))"/>
          </admst:when>
          <admst:otherwise>
            <!-- <admst:message format="Falling back on direct function call instead of precomputation for function %(name) of class %(class).  May be a sign of incomplete back end.\n"/> -->
            <admst:variable name="expression" select="%(functionCall(.)/[name='returnedExpression']/value)"/>
          </admst:otherwise>
        </admst:choose>
        <!-- now try to deal with derivatives -->
        <admst:choose>
          <!-- Single-argument functions -->
          <admst:when test="[name='exp' or name='ln' or name='log' or name='sqrt' or name='abs' or name='limexp' or name='cos' or name='sin' or name='tan' or name='acos' or name='asin' or name='atan' or name='cosh' or name='sinh' or name='tanh' or name='acosh' or name='asinh' or name='atanh' ]">
            <admst:apply-templates select="arguments[1]" match="processTerm">
              <admst:variable name="a1Deriv" select="%(returned('returnedExpressionDeriv')/value)"/>
              <admst:variable name="a1Deriv2" select="%(returned('returnedExpressionDeriv2')/value)"/>
              <admst:variable name="a1Deriv12" select="%(returned('returnedExpressionDeriv12')/value)"/>
              <admst:variable name="a1DerivX" select="%(returned('returnedExpressionDerivX')/value)"/>
            </admst:apply-templates>
            <admst:choose>
              <admst:when test="[$a1Deriv='0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2='0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv2)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[($a1Deriv ='0.0' or $a1Deriv2='0.0') and $a1Deriv12='0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:when test="[$a1Deriv12='0.0']">
                  <admst:apply-templates select="." match="oneArgSecondDeriv">
                    <admst:variable name="d2fdx2" select="%(returned('d2fdx2')/value)"/>
                  </admst:apply-templates>
                  <admst:variable name="expressionDeriv12" select="$d2fdx2*$a1Deriv*$a1Deriv2"/>
                </admst:when>
                <admst:when test="[($a1Deriv='0.0' or $a1Deriv2='0.0')]">
                  <admst:variable name="expressionDeriv12" select="deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv12)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:apply-templates select="." match="oneArgSecondDeriv">
                    <admst:variable name="d2fdx2" select="%(returned('d2fdx2')/value)"/>
                  </admst:apply-templates>
                  <admst:choose>
                    <admst:when test="[$d2fdx2='0.0']">
                      <!-- pretty much only for abs()-->
                      <admst:variable name="expressionDeriv12" select="deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv12)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDeriv12" select="($d2fdx2*$a1Deriv*$a1Deriv2+(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv12)))"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and exists(arguments[1]/#Pdependent)]">
              <admst:choose>
                <admst:when test="[$a1DerivX='0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1DerivX)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <!-- two-argument functions -->
          <admst:when test="[name='pow' or name='min' or name='max' or name='hypot' or name='atan2']">
            <admst:apply-templates select="arguments[1]" match="processTerm">
              <admst:variable name="a1" select="%(returned('returnedExpression')/value)"/>
              <admst:variable name="a1Deriv" select="%(returned('returnedExpressionDeriv')/value)"/>
              <admst:variable name="a1Deriv2" select="%(returned('returnedExpressionDeriv2')/value)"/>
              <admst:variable name="a1Deriv12" select="%(returned('returnedExpressionDeriv12')/value)"/>
              <admst:variable name="a1DerivX" select="%(returned('returnedExpressionDerivX')/value)"/>
            </admst:apply-templates>
            <admst:apply-templates select="arguments[2]" match="processTerm">
              <admst:variable name="a2" select="%(returned('returnedExpression')/value)"/>
              <admst:variable name="a2Deriv" select="%(returned('returnedExpressionDeriv')/value)"/>
              <admst:variable name="a2Deriv2" select="%(returned('returnedExpressionDeriv2')/value)"/>
              <admst:variable name="a2Deriv12" select="%(returned('returnedExpressionDeriv12')/value)"/>
              <admst:variable name="a2DerivX" select="%(returned('returnedExpressionDerivX')/value)"/>
            </admst:apply-templates>
            <admst:choose>
              <admst:when test="[$a1Deriv='0.0' and $a2Deriv='0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:when test="[$a2Deriv='0.0']">
                <admst:variable name="expressionDeriv" select="(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv))"/>
              </admst:when>
              <admst:when test="[$a1Deriv='0.0']">
                <admst:variable name="expressionDeriv" select="(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d1*($a2Deriv))"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="((deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv))+(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d1*($a2Deriv)))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$a1Deriv2='0.0' and $a2Deriv2='0.0']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:when test="[$a2Deriv2='0.0']">
                  <admst:variable name="expressionDeriv2" select="(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv2))"/>
                </admst:when>
                <admst:when test="[$a1Deriv2='0.0']">
                  <admst:variable name="expressionDeriv2" select="(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d1*($a2Deriv2))"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="((deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1Deriv2))+(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d1*($a2Deriv2)))"/>
                </admst:otherwise>
              </admst:choose>
              <!-- general case:  second deriv=
                   (d2fdy2*a2Deriv + d2fdxdy*a1Deriv)*a2Deriv2
                  +(d2fdxdy*a2Deriv+  d2fdx2*a1Deriv)*a1Deriv2
                  +dfdy*a2Deriv12
                  +dfdx*a1Deriv12
                -->
              <admst:choose>
                <admst:when test="[$a1Deriv='0.0' and $a2Deriv='0.0' and $a1Deriv2='0.0' and $a2Deriv2='0.0' and $a1Deriv12='0.0' and $a2Deriv12='0.0']">
                  <admst:variable name="expressionDeriv12" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:apply-templates select="." match="twoArgSecondDerivs">
                    <admst:variable name="d2fdx2" select="%(returned('d2fdx2')/value)"/>
                    <admst:variable name="d2fdxdy" select="%(returned('d2fdxdy')/value)"/>
                    <admst:variable name="d2fdy2" select="%(returned('d2fdy2')/value)"/>
                  </admst:apply-templates>
                  <admst:variable name="term1" select=""/>
                  <admst:variable name="term2" select=""/>
                  <admst:variable name="term3" select=""/>
                  <admst:variable name="term4" select=""/>
                  <admst:if test="[not($a2Deriv2='0.0')]">
                    <admst:if test="[not($a1Deriv='0.0' and $a2Deriv='0.0')]">
                      <admst:choose>
                        <admst:when test="[$a1Deriv='0.0']">
                          <admst:variable name="term1" select="$d2fdy2*$a2Deriv*$a2Deriv2"/>
                        </admst:when>
                        <admst:when test="[$a2Deriv='0.0']">
                          <admst:variable name="term1" select="$d2fdxdy*$a1Deriv*$a2Deriv2"/>
                        </admst:when>
                        <admst:otherwise>
                          <admst:variable name="term1" select="($d2fdy2*$a2Deriv+$d2fdxdy*$a1Deriv)*$a2Deriv2"/>
                        </admst:otherwise>
                      </admst:choose>
                    </admst:if>
                  </admst:if>
                  <admst:if test="[not($a1Deriv2='0.0')]">
                    <admst:if test="[not($a1Deriv='0.0' and $a2Deriv='0.0')]">
                      <admst:choose>
                        <admst:when test="[$a1Deriv='0.0']">
                          <admst:variable name="term2" select="$d2fdxdy*$a2Deriv*$a1Deriv2"/>
                        </admst:when>
                        <admst:when test="[$a2Deriv='0.0']">
                          <admst:variable name="term2" select="$d2fdx2*$a1Deriv*$a1Deriv2"/>
                        </admst:when>
                        <admst:otherwise>
                          <admst:variable name="term2" select="($d2fdxdy*$a2Deriv+$d2fdx2*$a1Deriv)*$a1Deriv2"/>
                        </admst:otherwise>
                      </admst:choose>
                    </admst:if>
                  </admst:if>
                  <admst:if test="[not($a2Deriv12='0.0')]">
                    <admst:variable name="term3" select="$a2Deriv12*deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d1"/>
                  </admst:if>
                  <admst:if test="[not($a1Deriv12='0.0')]">
                    <admst:variable name="term4" select="$a1Deriv12*deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0"/>
                  </admst:if>
                  <admst:variable name="expressionDeriv12" select="$term1"/>
                  <admst:if test="[not($expressionDeriv12='') and not($term2='')]">
                    <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
                  </admst:if>
                  <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term2"/>
                  <admst:if test="[not($expressionDeriv12='') and not($term3='')]">
                    <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
                  </admst:if>
                  <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term3"/>
                  <admst:if test="[not($expressionDeriv12='') and not($term4='')]">
                    <admst:variable name="expressionDeriv12" select="$expressionDeriv12+"/>
                  </admst:if>
                  <admst:variable name="expressionDeriv12" select="$expressionDeriv12$term4"/>
                  <admst:choose>
                    <admst:when test="[$expressionDeriv12='']">
                      <admst:variable name="expressionDeriv12" select="0.0"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expressionDeriv12" select="($expressionDeriv12)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity' and (exists(arguments[1]/#Pdependent) or exists(arguments[2]/#Pdependent))]">
              <admst:choose>
                <admst:when test="[$a1DerivX='0.0' and $a2DerivX='0.0']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:when test="[$a2DerivX='0.0']">
                  <admst:variable name="expressionDerivX" select="(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1DerivX))"/>
                </admst:when>
                <admst:when test="[$a1DerivX='0.0']">
                  <admst:variable name="expressionDerivX" select="(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d1*($a2DerivX))"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="((deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d0*($a1DerivX))+(deriv_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.))_d1*($a2DerivX)))"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="thisFunctionCall" path="."/>
            <admst:if test="[class!='analog']">
              <admst:warning format="Do not know how to differentiate function %(name).  Code will be wrong!\n"/>
              <admst:variable name="expressionDeriv" select="FIXME/*derivatives for %(name) not implemented*/"/>
              <admst:variable name="expressionDeriv2" select="FIXME/*derivatives for %(name) not implemented*/"/>
              <admst:variable name="expressionDeriv12" select="FIXME/*derivatives for %(name) not implemented*/"/>
              <admst:variable name="expressionDerivX" select="FIXME/*derivatives for %(name) not implemented*/"/>
            </admst:if>
            <admst:variable name="argsDep" select="no"/>
            <admst:variable name="argsDep2" select="no"/>
            <admst:variable name="argsDepX" select="no"/>
            <admst:if test="[definition/datatypename='analogfunction']">
              <admst:if test="[exists(definition/variable[(output='yes') and (name!=$thisFunctionCall/name)])]">
                <!-- <admst:message format="Called analog function has output variables other than return value, pretending args have dependencies.\n"/> -->
                <admst:variable name="argsDep" value="yes"/>
              </admst:if>
            </admst:if>
            <admst:variable name="args" value=""/>
            <admst:variable name="dargs" value=""/>
            <admst:variable name="dargs2" value=""/>
            <admst:variable name="dargsX" value=""/>
            <admst:for-each select="arguments">
              <admst:if test="[not($args='')]">
                <admst:variable name="args" value="$(args),"/>
              </admst:if>
              <admst:if test="[not($dargs='')]">
                <admst:variable name="dargs" value="$(dargs),"/>
              </admst:if>
              <admst:if test="[not($dargs2='')]">
                <admst:variable name="dargs2" value="$(dargs2),"/>
              </admst:if>
              <admst:if test="[not($dargsX='')]">
                <admst:variable name="dargsX" value="$(dargsX),"/>
              </admst:if>
              <admst:apply-templates select="." match="processTerm">
                <admst:variable name="args" select="$(args)%(returned('returnedExpression')/value)"/>
                <admst:variable name="aDeriv" select="%(returned('returnedExpressionDeriv')/value)"/>
                <admst:variable name="aDeriv2" select="%(returned('returnedExpressionDeriv2')/value)"/>
                <admst:variable name="aDerivX" select="%(returned('returnedExpressionDerivX')/value)"/>
                <admst:if test="[$aDeriv != '0.0']">
                  <admst:variable name="argsDep" select="yes"/>
                </admst:if>
                <admst:if test="[$aDeriv2 != '0.0']">
                  <admst:variable name="argsDep2" select="yes"/>
                </admst:if>
                <admst:if test="[$aDerivX != '0.0']">
                  <admst:variable name="argsDepX" select="yes"/>
                </admst:if>
                <admst:variable name="dargs" select="$(dargs)$(aDeriv)"/>
                <admst:variable name="dargs2" select="$(dargs2)$(aDeriv2)"/>
                <admst:variable name="dargsX" select="$(dargsX)$(aDerivX)"/>
              </admst:apply-templates>
            </admst:for-each>
            <admst:choose>
              <admst:when test="[$argsDep = 'no']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="evaluator_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.)).getDerivs($args,$dargs)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:if test="$derivProbe2">
              <admst:choose>
                <admst:when test="[$argsDep2 = 'no']">
                  <admst:variable name="expressionDeriv2" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDeriv2" select="evaluator_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.)).getDerivs($args,$dargs2)"/>
                </admst:otherwise>
              </admst:choose>

              <!-- It is not necessarily an error that we can't do
                   these, it's only a problem if the derivatives are
                   actually needed, and we don't know this yet -->
              <admst:variable name="expressionDeriv12" select="0.0/*second derivatives of analog functions not implemented*/"/>
            </admst:if>
            <admst:if test="[$globalCurrentScope='sensitivity']">
              <admst:choose>
                <admst:when test="[$argsDepX = 'no']">
                  <admst:variable name="expressionDerivX" select="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expressionDerivX" select="evaluator_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.)).getDerivs($args,$dargsX)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>

    <admst:return name="returnedExpressionDeriv" value="$expressionDeriv"/>
    <admst:return name="returnedExpressionDeriv2" value="$expressionDeriv2"/>
    <admst:return name="returnedExpressionDeriv12" value="$expressionDeriv12"/>
    <admst:return name="returnedExpressionDerivX" value="$expressionDerivX"/>
  </admst:template>

  <!--
   =================================================================-
   functionCall
     This template was what our old back-end called when a function
     call was found, via the %(adms/datatype) template match.  Now
     that we're doing precomputation of function evaluation, we have
     do do something simpler in the "function" template, and
     have this one for the real work
   =================================================================-
  -->
  <admst:template match="functionCall">
    <admst:choose>
      <admst:when test="[name='min']">
        <admst:variable name="expression" select="std::min"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="realArgument">
            <admst:variable name="args" select="$args%(returned('argval')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:when test="[name='max']">
        <admst:variable name="expression" select="std::max"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="realArgument">
            <admst:variable name="args" select="$args%(returned('argval')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:when test="[name='absdelay']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="FIXMEabsdelay(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <!-- DDT is a null function in Xyce we'll load such things into
           dynamic contributions, and those will be differentiated elsewhere -->
      <admst:when test="[name='ddt']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$given' or name='\$param_given']">
        <admst:variable name="arg1" select="%(arguments[1])"/>
        <admst:assert test="$arg1[datatypename='variable' and input='yes']" format="%(name): argument is not a parameter\n"/>
        <admst:choose>
          <admst:when test="$arg1/[parametertype='model']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'model']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'instance']">
                <admst:variable name="expression" select="(model_.given(&quot;$arg1&quot;))"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'sensitivity']">
                <admst:variable name="expression" select="modelStruct.modelPar_given_$arg1"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="$arg1/[parametertype='instance']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'instance']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'sensitivity']">
                <admst:variable name="expression" select="instanceStruct.instancePar_given_$arg1"/>
              </admst:when>
              <admst:otherwise>
                <admst:fatal format="Attempt to use \$given() on an instance variable outside of instance scope\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="%(name): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$temperature']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:choose>
          <admst:when test="[$globalCurrentScope='instance' or $globalCurrentScope='sensitivity']">
            <admst:variable name="expression" select="admsTemperature"/>
          </admst:when>
          <!-- KLUDGE!!!!!! -->
          <!-- Assumes that when at model scope, $temperature is taken as
               the default temperature of the simulator. -->
          <!-- At instance scope, we use whatever Xyce passed in to
               updateTemperature for that instance. -->
          <admst:when test="[$globalCurrentScope='model']">
            <admst:variable name="expression" select="admsModTemp"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$mfactor']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_MFACTOR"/>
      </admst:when>
      <admst:when test="[name='\$vt']">
        <admst:choose>
          <admst:when test="[nilled(arguments)]">
            <admst:variable name="expression" select="adms_vt_nom"/>
          </admst:when>
          <admst:when test="arguments[count(.)=1]">
            <admst:apply-templates select="arguments[1]" match="processTerm">
              <admst:variable name="expression" select="adms_vt(%(returned('returnedExpression')/value))"/>
            </admst:apply-templates>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$scale']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_scale"/>
      </admst:when>
      <admst:when test="[name='\$abstime' or name='\$realtime']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
          <admst:choose>
            <admst:when test="[$globalCurrentScope='sensitivity']">
              <admst:variable name="expression" select="theInstance.getSolverState().currTime_"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="getSolverState().currTime_"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='ddx']">
        <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
        <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
        <admst:variable name="expression" select="FIXME: ddx(%(arguments[1]),%(arguments[2]))"/>
      </admst:when>
      <admst:when test="[name='floor']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
          <admst:variable name="expression" select="floor($expression)"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='ceil']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
          <admst:variable name="expression" select="ceil($expression)"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$simparam']">
        <admst:choose>
          <admst:when test="[arguments[1]/datatypename='string' and arguments[1]/value='gmin']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope='sensitivity']">
                <admst:variable name="expression" select="ADMSgmin_arg"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="getDeviceOptions().gmin"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:assert test="arguments[count(.)=2]" format="Unrecognized simparam %(arguments[1]) and no expression provided.\n"/>
            <admst:apply-templates select="arguments[2]" match="processTerm">
              <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
            </admst:apply-templates>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='hypot']">
        <admst:assert test="arguments[count(.)=2]" format="hypot function must take exactly two arguments.\n"/>
        <admst:variable name="expression" value="sqrt"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args+"/>
          </admst:if>
          <admst:apply-templates select="." match="processTerm">
            <admst:variable name="args" select="$args%(returned('returnedExpression')/value)*%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:when test="[name='ln' or name='log' or name='sqrt']">
        <admst:variable name="expression" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="realArgument">
            <admst:variable name="args" select="$args%(returned('argval')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="expression" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="processTerm">
            <admst:variable name="args" select="$args%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   analogFunctionEvaluatorConstruction
     This is very much like functionCall, but is only used when
     generating precomptation for analog functions, so it is simpler.
   =================================================================-
  -->
  <admst:template match="analogFunctionEvaluatorConstruction">
    <admst:variable name="expression" select="AnalogFunctions::%(funcnameSimple(.)/[name='fname']/value)Evaluator evaluator_%(funcnameSimple(.)/[name='fname']/value)_%(index(../function,.))"/>
    <admst:variable name="args" select=""/>
    <admst:for-each select="arguments">
      <admst:if test="[$args!='']">
        <admst:variable name="args" select="$args,"/>
      </admst:if>
      <admst:apply-templates select="." match="processTerm">
        <admst:variable name="args" select="$args%(returned('returnedExpression')/value)"/>
      </admst:apply-templates>
    </admst:for-each>
    <admst:variable name="expression" select="$expression($args)"/>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>
  <!--
   =================================================================-
   string
   format a string for output
   =================================================================-
  -->
  <admst:template match="string">
    <admst:return name="returnedExpression" value="&quot;%(value)&quot;"/>
    <admst:return name="returnedExpressionDeriv" value="0.0"/>
    <admst:return name="returnedExpressionDeriv2" value="0.0"/>
    <admst:return name="returnedExpressionDeriv12" value="0.0"/>
    <admst:return name="returnedExpressionDerivX" value="0.0"/>
  </admst:template>

  <!--
   =================================================================-
   conditional
   output if/then/else
   =================================================================-
  -->
  <admst:template match="conditional">
    <admst:assert test="adms[datatypename='conditional']" format="conditional template called on something other than conditional\n"/>

    <admst:variable name="saveSkipFunctionPrecomp" select="$skipFunctionPrecomp"/>
    <admst:variable name="skipFunctionPrecomp" select="y"/>
    <admst:text format="if (%(printTerm(if)))\n"/>
    <admst:variable name="skipFunctionPrecomp" select="$saveSkipFunctionPrecomp"/>
    <!-- blocks will print their own braces, but we always want them -->
    <admst:text select="then/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="then" match="%(adms/datatypename)"/>
    <!-- blocks will print their own braces, but we always want them -->
    <admst:text select="then/adms[datatypename!='block']"  format="}\n"/>
    <admst:if test="else">
      <admst:text format="else\n"/>
      <admst:text select="else/adms[datatypename!='block']" format="{\n"/>
      <admst:apply-templates select="else" match="%(adms/datatypename)"/>
      <admst:text select="else/adms[datatypename!='block']"  format="}\n"/>
    </admst:if>
  </admst:template>

  <!--
   =================================================================-
   block
   output block
   =================================================================-
  -->
  <admst:template match="block">
    <admst:assert test="adms[datatypename='block']" format="block template called on something other than block\n"/>
    <admst:text select="[name!='']" format="//Begin block %(name)\n"/>
    <admst:text format="{\n"/>
    <admst:apply-templates select="item" match="%(adms/datatypename)"/>
    <admst:text format="}\n"/>
    <admst:text select="[name!='']" format="// End block %(name)\n"/>
  </admst:template>


  <!--
   =================================================================-
   blockvariable
     declare block-local variables
   =================================================================-
  -->
  <admst:template match="blockvariable">
    <admst:text format="//Block-local variables for block %(block/name)\n"/>
    <admst:for-each select="variable">
      <admst:if test="[$globalCurrentScope='sensitivity']">
        <admst:apply-templates select="." match="collectParamDependence"/>
      </admst:if>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <admst:text format="//End of Block-local variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   nilled
   do nothing, when nothing is found
   =================================================================-
  -->
  <admst:template match="nilled">
  </admst:template>

  <!--
   =================================================================-
   whileloop
   output while loop
   =================================================================-
  -->
  <admst:template match="whileloop">
    <admst:variable name="saveSkipFunctionPrecomp" select="$skipFunctionPrecomp"/>
    <admst:variable name="skipFunctionPrecomp" select="y"/>
    <admst:text format="while (%(printTerm(while)))\n"/>
    <admst:variable name="skipFunctionPrecomp" select="$saveSkipFunctionPrecomp"/>
    <admst:text select="whileblock/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="whileblock" match="%(adms/datatypename)"/>
    <admst:text select="whileblock/adms[datatypename!='block']" format="}\n"/>
  </admst:template>

  <!--
   =================================================================-
   forloop
   output for   loop
   =================================================================-
  -->
  <admst:template match="forloop">
    <admst:text format="for ("/>
    <admst:text format="%(printTerm(initial/lhs))=%(printTerm(initial/rhs));"/>
    <admst:text format="%(printTerm(condition));"/>
    <admst:text format="%(printTerm(update/lhs))=%(printTerm(update/rhs)) )"/>
    <admst:text select="forblock/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="forblock" match="%(adms/datatypename)"/>
    <admst:text select="forblock/adms[datatypename!='block']" format="}\n"/>
  </admst:template>
  <!--
   =================================================================-
   case
   output "case" statement
   =================================================================-
  -->
  <admst:template match="case">
    <admst:variable name="casecondition" path="case/tree"/>
    <admst:variable name="havedefault" select="no"/>
    <admst:if test="[count(caseitem[defaultcase='yes']) >0]">
      <admst:variable name="havedefault" select="yes"/>
    </admst:if>

    <admst:for-each select="caseitem[defaultcase='no']">
      <admst:text format="if ( "/>
      <admst:join select="condition" separator="||">
	<admst:apply-templates select="." match="%(datatypename)">
	  <admst:text format="%(printTerm($casecondition)) == (%(returned('returnedExpression')/value))"/>
	</admst:apply-templates>
      </admst:join>
      <admst:text format=")\n"/>
      <admst:if test="[code/datatypename!='block']">
        <admst:text format="{\n"/>
      </admst:if>
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
      <admst:if test="[code/datatypename!='block']">
        <admst:text format="}\n"/>
      </admst:if>
      <admst:text format="else\n"/>
    </admst:for-each>
    <admst:text select="[$havedefault='no']" format="{\n // no default\n}\n"/>
    <admst:for-each select="caseitem[defaultcase='yes']">
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
    </admst:for-each>
  </admst:template>


  <!--
   =================================================================-
   formatted_range
   Given a variable node, print out its range in a nicely formatted
   way, with open or closed bounds indicated.
   This is for pretty printing such as for HTML, not code generation.
   =================================================================-
  -->
  <admst:template match="formatted_range">
    <admst:choose>
      <admst:when test="[nilled(range)]">
        <admst:text format="No Range Specified"/>
      </admst:when>
      <admst:when test="[name!='pnp' and name!='npn']">
        <admst:apply-templates select="range" match="formatted_range2"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="Positive range"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   formatted_range2
   the actual guts of formatted range, but this one takes a single
   range node of the tree, not a variable (which can have multiple
   ranges
   =================================================================-
  -->
<admst:template match="formatted_range2">
  <admst:choose>
    <admst:when test="infexpr[hasspecialnumber='YES']">
      <admst:text format=" ] %(infexpr) "/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[infboundtype='range_bound_include']">
          <admst:text format="[ "/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="] "/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="infexpr" match="printTerm"/>
      <admst:text format=", "/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="supexpr[hasspecialnumber='YES']">
      <admst:text format=" %(supexpr) ["/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="supexpr" match="printTerm"/>
      <admst:choose>
	<admst:when test="[supboundtype='range_bound_include']">
	  <admst:text format=" ]"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format=" ["/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

  <!--
   =================================================================-
   rangeCondition
   Given a range, generate the C++ condition that checks if it's
   exceeded/violated
   =================================================================-
  -->

<admst:template match="rangeCondition">
  <admst:choose>
    <admst:when test="[infexpr/hasspecialnumber='YES' and supexpr/hasspecialnumber='YES']">
      <admst:return name="doNothing" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="returnCondition" select="("/>
      <!-- Lower bound -->
      <admst:if test="infexpr[hasspecialnumber!='YES']">
        <admst:variable name="returnCondition" select="$returnCondition%(../name) &gt;"/>
        <admst:if test="[infboundtype='range_bound_include']">
          <admst:variable name="returnCondition" select="$returnCondition="/>
        </admst:if>
        <admst:variable name="returnCondition" select="$returnCondition%(processTerm(infexpr)/[name='returnedExpression']/value)"/>
        <admst:if test="supexpr[hasspecialnumber!='YES']">
          <admst:variable name="returnCondition" select="$returnCondition &amp;&amp; "/>
        </admst:if>
      </admst:if>

      <!-- upper bound -->
      <admst:if test="supexpr[hasspecialnumber!='YES']">
        <admst:variable name="returnCondition" select="$returnCondition%(../name) &lt;"/>
        <admst:if test="[supboundtype='range_bound_include']">
          <admst:variable name="returnCondition" select="$returnCondition="/>
        </admst:if>
        <admst:variable name="returnCondition" select="$returnCondition%(processTerm(supexpr)/[name='returnedExpression']/value) "/>
      </admst:if>
      <admst:variable name="returnCondition" select="$returnCondition)"/>

      <!-- now decide whether this is an include condition or exclude: -->
      <admst:if test="[type='include']">
        <admst:variable name="returnCondition" select="!($returnCondition)"/>
      </admst:if>
      <admst:return name="doNothing" value="no"/>
      <admst:return name="returnCondition" value="$returnCondition"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

  <!--
   =================================================================-
   check_range
   Given a variable node, generate code to check the variable against
   the range.

   The range of the variable is assumed non-nilled, so the caller
   must check first before calling this.
   =================================================================-
  -->

<admst:template match="check_range">
  <admst:choose>
    <!-- first special case: both upper and lower are special, meaning that
         there really is no range to bother checking -->
    <admst:when test="[range/infexpr/hasspecialnumber='YES' and range/supexpr/hasspecialnumber='YES']">
      <!-- do nothing -->
    </admst:when>
    <admst:otherwise>
      <!-- we have a range to check -->
      <admst:text format="  if ( "/>
      <admst:text format="("/>
      <!-- there may be several ranges specified, some included, some excluded.
           gotta be careful -->
      <admst:join select="range[infexpr/hasspecialnumber!='YES' or supexpr/hasspecialnumber!='YES']" separator=" || ">
        <admst:apply-templates select="." match="rangeCondition">
          <admst:text format="%(returned('returnCondition')/value)"/>
        </admst:apply-templates>
      </admst:join>
      <admst:text format=") )\n  {\n    UserWarning(*this) &lt;&lt; &quot;$nameSpace: Parameter %(name) value &quot; &lt;&lt; %(name) &lt;&lt; &quot; "/>
      <admst:join select="range" separator=" or ">
        <admst:text select="[type='include']" format="out of range"/>
        <admst:text select="[type='exclude']" format="in excluded range"/>
        <admst:text format=" %(formatted_range2(.))"/>
      </admst:join>
      <admst:text format="&quot;;\n  }\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- map binary operators onto C++ symbols -->
<admst:template match="bname">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" value="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" value="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" value="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" value="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" value="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" value="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" value="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" value="=="/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" value="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" value="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" value="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" value="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" value="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" value="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" value="&lt;&lt;"/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:return name="bname" value="%"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type %(name) unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="funcname">
  <admst:choose>
    <admst:when test="[name='abs']">
      <admst:variable name="expression" select="fabs"/>
    </admst:when>
    <admst:when test="[name='\$shrinkl']">
      <admst:variable name="expression" select="shrinkl"/>
    </admst:when>
    <admst:when test="[name='\$shrinka']">
      <admst:variable name="expression" select="shrinka"/>
    </admst:when>
    <admst:when test="[name='log']">
      <admst:variable name="expression" select="(1.0/log(10.0))*log"/>
    </admst:when>
    <admst:when test="[name='ln']">
      <admst:variable name="expression" select="log"/>
    </admst:when>
    <admst:when test="[name='limexp']">
      <admst:variable name="expression" select="limexp"/>
    </admst:when>
    <admst:when test="[name='\$limexp']">
      <admst:variable name="expression" select="limexp"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[$globalMustUseTemplate='no' or class!='analog']">
          <admst:choose>
            <admst:when test="[class='analog']">
              <admst:choose>
                <admst:when test="[$globalCurrentScope!='AF']">
                  <admst:choose>
                    <admst:when test="[$skipFunctionPrecomp != 'y']">
                      <admst:variable name="expression" select="evaluator_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.)).getValues"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:variable name="expression" select="AnalogFunctions::%(name)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:when test="[$globalCurrentScope='AF']">
                  <admst:variable name="expression" select="%(name)"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="%(name)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <!-- globalMustUseTemplate=yes, apparently -->
          <admst:choose>
            <admst:when test="[class='analog']">
              <!-- analog functions are in their own class, and the model
                   class has an instance of that. -->
              <admst:choose>
                <!-- if we're in the AF class, these functions are accessible
                     just by their names -->
                <admst:when test="[$globalCurrentScope='AF']">
                  <admst:variable name="expression" select="%(name)&lt;WRONG&gt;"/>
                </admst:when>
                <admst:when test="[$globalCurrentScope='model' or $globalCurrentScope='instance' or $globalCurrentScope='sensitivity']">
                  <admst:variable name="expression" select="evaluator_%(funcnameSimple(.)/[name='fname']/value)_%(index(subexpression/expression/function,.)).getValues"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="%(name)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="fname" value="$expression"/>
</admst:template>

<!-- This template returns the second derivative of one-argument
     builtin functions with respect to their argument -->
<admst:template match="oneArgSecondDeriv">
  <!-- set this to a complete bogon return value, so it becomes
       a compilation error if we ever emerge from this function
       without setting it properly -->
  <admst:variable name="d2fdx2" select="fixme"/>
  <admst:apply-templates select="arguments[1]" match="processTerm">
    <admst:variable name="a1" select="%(returned('returnedExpression')/value)"/>
  </admst:apply-templates>
  <admst:choose>
    <admst:when test="[name='exp']">
      <admst:variable name="d2fdx2" select="exp($a1)"/>
    </admst:when>
    <admst:when test="[name='ln']">
      <admst:variable name="d2fdx2" select="(-1.0/$a1/$a1)"/>
    </admst:when>
    <admst:when test="[name='log']">
      <admst:variable name="d2fdx2" select="(-1.0/$a1/$a1/log(10.0))"/>
    </admst:when>
    <admst:when test="[name='sqrt']">
      <admst:variable name="d2fdx2" select="(-0.25/$a1/sqrt($a1))"/>
    </admst:when>
    <admst:when test="[name='abs']">
      <admst:variable name="d2fdx2" select="0.0"/>
    </admst:when>
    <admst:when test="[name='limexp']">
      <admst:variable name="d2fdx2" select="((($a1)&lt;80)?exp($a1):0.0)"/>
    </admst:when>
    <admst:when test="[name='cos']">
      <admst:variable name="d2fdx2" select="(-cos($a1))"/>
    </admst:when>
    <admst:when test="[name='sin']">
      <admst:variable name="d2fdx2" select="(-sin($a1))"/>
    </admst:when>
    <admst:when test="[name='tan']">
      <admst:variable name="d2fdx2" select="2.0*tan($a1)/cos($a1)/cos($a1)"/>
    </admst:when>
    <admst:when test="[name='acos']">
      <admst:variable name="d2fdx2" select="(-$a1/(1-$a1*$a1)/sqrt(1-$a1*$a1))"/>
    </admst:when>
    <admst:when test="[name='asin']">
      <admst:variable name="d2fdx2" select="($a1/(1-$a1*$a1)/sqrt(1-$a1*$a1))"/>
    </admst:when>
    <admst:when test="[name='atan']">
      <admst:variable name="d2fdx2" select="(-2.0*$a1/($a1*$a1+1)/($a1*$a1+1))"/>
    </admst:when>
    <admst:when test="[name='cosh']">
      <admst:variable name="d2fdx2" select="cosh($a1)"/>
    </admst:when>
    <admst:when test="[name='sinh']">
      <admst:variable name="d2fdx2" select="sinh($a1)"/>
    </admst:when>
    <admst:when test="[name='tanh']">
      <admst:variable name="d2fdx2" select="(-2*tanh($a1)/cosh($a1)/cosh($a1))"/>
    </admst:when>
    <admst:when test="[name='acosh']">
      <admst:variable name="d2fdx2" select="(-$a1/($a1*$a1-1)/sqrt($a1*$a1-1))"/>
    </admst:when>
    <admst:when test="[name='asinh']">
      <admst:variable name="d2fdx2" select="(-$a1/($a1*$a1+1)/sqrt($a1*$a1+1))"/>
    </admst:when>
    <admst:when test="[name='atanh']">
      <admst:variable name="d2fdx2" select="2.0*$a1/(1-$a1*$a1)/(1-$a1*$a1)"/>
    </admst:when>
  </admst:choose>

  <admst:return name="d2fdx2" value="$d2fdx2"/>
</admst:template>

<!-- This template returns the second derivatives of two-argument
     builtin functions with respect to their arguments -->
<admst:template match="twoArgSecondDerivs">
  <admst:variable name="d2fdx2" select="0.0"/>
  <admst:variable name="d2fdxdy" select="0.0"/>
  <admst:variable name="d2fdy2" select="0.0"/>
  <admst:choose>
    <admst:when test="[name='pow']">
      <admst:apply-templates select="arguments[1]" match="processTerm">
        <admst:variable name="a1" select="%(returned('returnedExpression')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arguments[2]" match="processTerm">
        <admst:variable name="a2" select="%(returned('returnedExpression')/value)"/>
      </admst:apply-templates>
      <admst:variable name="d2fdx2" select="(($a1==0.0)?0.0:$a2*($a2-1)*pow($a1,$a2)/$a1/$a1)"/>
      <admst:variable name="d2fdxdy" select="(($a1==0.0)?0.0:(1+$a2*log($a1))*pow($a1,$a2)/$a1)"/>
      <admst:variable name="d2fdy2" select="(($a1==0.0)?0.0:log($a1)*log($a1)*pow($a1,$a2))"/>
    </admst:when>
    <admst:when test="[name='min' or name='max']">
      <admst:variable name="d2fdx2" select="0.0"/>
      <admst:variable name="d2fdxdy" select="0.0"/>
      <admst:variable name="d2fdy2" select="0.0"/>
    </admst:when>
    <admst:when test="[name='hypot']">
      <admst:variable name="functionIndex" select="%(index(../function,.))"/>
      <admst:variable name="hypotval" select="value_hypot_%($functionIndex)"/>
      <admst:variable name="d2fdx2" select="(1.0/$hypotval - $a1*$a1/($a1*$a1+$a2*$a2)/$hypotval)"/>
      <admst:variable name="d2fdxdy" select="( - $a1*$a2/($a1*$a1+$a2*$a2)/$hypotval)"/>
      <admst:variable name="d2fdy2" select="(1.0/$hypotval - $a2*$a2/($a1*$a1+$a2*$a2)/$hypotval)"/>
    </admst:when>
    <admst:when test="[name='atan2']">
      <admst:variable name="functionIndex" select="%(index(../function,.))"/>
      <admst:variable name="dfda1" select="deriv_atan2_%($functionIndex)_d0"/>
      <admst:variable name="dfda2" select="deriv_atan2_%($functionIndex)_d1"/>
      <admst:apply-templates select="arguments[1]" match="processTerm">
        <admst:variable name="a1" select="%(returned('returnedExpression')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arguments[2]" match="processTerm">
        <admst:variable name="a2" select="%(returned('returnedExpression')/value)"/>
      </admst:apply-templates>
      <!-- Note, here, "x" and "y" refer to arguments one and two,
           respectively, even though atan2() is usually called as "atan2(y,x)"
           -->
      <admst:variable name="dfdx2" select="2*$dfda1*$dfda2"/>
      <admst:variable name="dfdxdy" select="(1.0/($a1*$a1+$a2*$a2) - 2*$dfda1*$dfda1)"/>
      <admst:variable name="dfdy2" select="-2*$dfda1*$dfda2"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="d2fdx2" select="fixme/*second derivs of %(name) unimplemented*/"/>
      <admst:variable name="d2fdxdy" select="fixme/*second derivs of %(name) unimplemented*/"/>
      <admst:variable name="d2fdy2" select="fixme/*second derivs of %(name) unimplemented*/"/>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="d2fdx2" value="$d2fdx2"/>
  <admst:return name="d2fdy2" value="$d2fdy2"/>
  <admst:return name="d2fdxdy" value="$d2fdxdy"/>
</admst:template>

<!-- This variant doesn't try to return fancy names for functions in all
     contexts, just makes certain Verilog-A to C++ mappings.  Used for
     creation of variable names, not function calls -->
<admst:template match="funcnameSimple">
  <admst:choose>
    <admst:when test="[name='abs']">
      <admst:variable name="expression" select="fabs"/>
    </admst:when>
    <admst:when test="[name='\$shrinkl']">
      <admst:variable name="expression" select="shrinkl"/>
    </admst:when>
    <admst:when test="[name='\$shrinka']">
      <admst:variable name="expression" select="shrinka"/>
    </admst:when>
    <admst:when test="[name='log']">
      <admst:variable name="expression" select="log"/>
    </admst:when>
    <admst:when test="[name='ln']">
      <admst:variable name="expression" select="log"/>
    </admst:when>
    <admst:when test="[name='limexp']">
      <admst:variable name="expression" select="limexp"/>
    </admst:when>
    <admst:when test="[name='\$limexp']">
      <admst:variable name="expression" select="limexp"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="expression" select="%(name)"/>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="fname" value="$expression"/>
</admst:template>

<!-- callfunction: handle $strobe and $bound_step-->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="[$globalCurrentScope != 'AF']">
      <admst:choose>
        <admst:when test="function[name='\$strobe' or name='\$write'  or name='\$display']">
          <admst:variable name="saveSkipFunctionPrecomp" select="$skipFunctionPrecomp"/>
          <admst:variable name="skipFunctionPrecomp" select="y"/>
          <admst:choose>
            <admst:when test="[$globalCurrentScope ='sensitivity']">
              <admst:text format="UserInfo(theInstance) "/>
            </admst:when>
            <admst:otherwise>
              <admst:text format="UserInfo(*this) "/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="function/arguments">
            <admst:text format=" &lt;&lt; %(printTerm(.)) &lt;&lt; &quot; &quot;"/>
          </admst:for-each>
          <admst:if test="[function/name='\$strobe' or function/name='\$display']">
            <admst:text format=" &lt;&lt;  std::endl"/>
          </admst:if>
          <admst:text format="; \n"/>
          <admst:variable name="skipFunctionPrecomp" select="$saveSkipFunctionPrecomp"/>
        </admst:when>
        <admst:when test="function[name='\$finish']">
          <admst:choose>
            <admst:when test="[$globalCurrentScope ='sensitivity']">
              <admst:text format=" UserError(theInstance) &lt;&lt; &quot;%(function/name) called.&quot; &lt;&lt; std::endl; \n"/>
            </admst:when>
            <admst:otherwise>
              <admst:text format=" UserError(*this) &lt;&lt; &quot;%(function/name) called.&quot; &lt;&lt; std::endl; \n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="function[name='\$bound_step']">
          <admst:choose>
            <admst:when test="[$globalCurrentScope ='sensitivity']">
              <!-- do absolutely nothing -->
            </admst:when>
            <admst:otherwise>
              <admst:text format=" maxTimeStep_ = %(printTerm(function/arguments[1]));\n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:value-of select="function/name"/>
          <admst:text format="// %s: not supported by this interface\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:text format="// %(function/name): not supported in analog functions\n"/>
      <admst:warning format="%(function/name) not supported in analog functions, ignored.\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>



  <!--
   =================================================================-
   realArgument
   format a function argument to make sure that it is a real quantity
   when emitted.

   This is designed to be used such cases as
   real foo;
   integer bar;
   foo=ln(bar);
   which should wind up emitted as
   double foo;
   integer bar;
   foo=log(static_cast<double>(bar));

   This is especially important on systems like Windows.

   This may also be used to handle things like this:
   real foo;
   real bar;
   bar=max(foo,0);

   C++ hates having the integer constant as the second argument of max
   on most systems.

   What we do here is check that if the argument is a constant or
   integer variable.  If so, wrap the thing in a static cast first.
   Otherwise, just emit as is.

   When called, the current node is the argument.
   =================================================================-
  -->

  <admst:template match="realArgument">
    <admst:choose>
      <admst:when test="[datatypename='number' or (datatypename='variable' and type='integer')]">
        <admst:variable name="localArg" select="static_cast&lt;double&gt;(%(processTerm(.)/[name='returnedExpression']/value))" />
      </admst:when>
      <admst:otherwise>
        <admst:variable name="localArg" select="%(processTerm(.)/[name='returnedExpression']/value)" />
      </admst:otherwise>
    </admst:choose>
    <admst:return name="argval" value="$localArg"/>
  </admst:template>

 <!--
   =================================================================-
   generateEvaluateModelEquationsArgs

   to avoid doing all this mess over and over again, with possibility
   of mismatch, collect up in one place If global variable
   "globalDeclareEMEVars" is set, emit types with variable names (for
   function definition/declaration).  If not, just generate variable
   names (for function call)

   In this version, we're very specifically emitting declarations JUST
   for sensitivity, not for a general version.
   =================================================================-
 -->
 <admst:template match="generateEvaluateModelEquationsArgs">
   <!-- don't generate these if not declaring, because the caller
        might need to add things like "in." or "mod." to them. -->
   <admst:if test="[$globalDeclareVars='yes']">
     <admst:text format="std::vector &lt;double&gt; &amp; probeVars,\n"/>
     <admst:text format="// probe constants\n"/>

     <admst:if test="[count(probe)>0]">
       <admst:join select="probe" separator=",\n">
         <admst:text format="const int "/>
         <admst:text format="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
       </admst:join>
       <admst:text format=",\n"/>
     </admst:if>
     <admst:if test="[count(@extraProbeBranches)>0]">
       <admst:join select="@extraProbeBranches" separator=",\n">
         <admst:text format="const int "/>
         <admst:text format="%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)"/>
       </admst:join>
       <admst:text format=",\n"/>
     </admst:if>

     <admst:text format="// node constants\n"/>

     <admst:join select="node[grounded='no']" separator=",\n">
       <admst:text format="const int "/>
       <admst:text format="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
     </admst:join>
     <admst:if test="[count(@extraUnknowns)>0]">
       <admst:text format=",\n"/>
       <admst:join select="@extraUnknowns" separator=",\n">
         <admst:text format="const int "/>
         <admst:text format="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
       </admst:join>
     </admst:if>
   </admst:if>
   <admst:text format=",\n"/>

   <!-- now generate the instance and model parameters and variables -->
   <admst:if test="[$globalDeclareVars='yes']">
     <admst:text format="instanceSensStruct &amp; "/>
   </admst:if>
   <admst:text format="instanceStruct,\n"/>
   <admst:if test="[$globalDeclareVars='yes']">
     <admst:text format="modelSensStruct &amp; "/>
   </admst:if>
   <admst:text format="modelStruct,\n"/>

   <!-- don't generate these if not declaring, because the caller
        might need to add things like "in." or "mod." to them. -->
   <admst:if test="[$globalDeclareVars='yes']">
     <admst:if test="[exists(@optnodes)]">
       <admst:text format="const std::vector&lt;bool&gt; &amp; portsConnected_,\n"/>
     </admst:if>
     <admst:text format="// basic variables\n"/>
     <admst:text format=" double admsTemperature"/>
     <admst:text format=", double adms_vt_nom"/>
     <admst:text format=", double ADMSgmin_arg"/>
     <admst:text format=", std::vector &lt;double&gt; &amp; d_staticContributions_dX"/>
     <admst:text format=", std::vector &lt;double&gt; &amp; d_dynamicContributions_dX"/>
     <!-- YUCK!  Went through all that trouble to duplicate the instance vars
          and here we are passing an instance pointer!  Why?  Only because
          UserError takes an instance as argument.  DO NOT EVER USE ANYTHING
          FROM THE INSTANCE PASSED in evaluateModelEquations! -->
     <admst:text format=", const Instance &amp; theInstance"/>
   </admst:if>
</admst:template>


 <!--
   =================================================================-
   generateInstanceStruct

   Generate the declaration of a structure to hold instance pars and vars
   to consolidate and simplify passing them to functions

   In this version, we're very specifically emitting declarations JUST
   for sensitivity, not for a general version.
   =================================================================-
 -->
 <admst:template match="generateInstanceStruct">
   <admst:text format="class instanceSensStruct\n{\npublic:\n"/>

   <admst:if test="[exists( variable[parametertype='instance' and input='yes' and type='real']) or exists( variable[parametertype='instance' and input='no' and exists(attribute[name='hidden']) and type='real'] ) or exists( variable[parametertype='instance' and (input='yes' or input='no' and exists(attribute[name='hidden'])) and not(type='real')] )]">
     <admst:text format="// instance parameters\n"/>
   </admst:if>

   <admst:if test="[exists( variable[parametertype='instance' and input='yes' and type='real'])]">
     <admst:text format="// reals\n"/>
     <admst:for-each select="variable[parametertype='instance' and input='yes' and type='real']">
       <admst:text format="double instancePar_%(name);\n"/>
       <admst:text format="double d_instancePar_%(name)_dX;\n"/>
       <admst:text format="bool instancePar_given_%(name);\n"/>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[parametertype='instance' and input='no' and exists(attribute[name='hidden']) and type='real'] )]">
     <admst:text format="// real hiddens\n"/>
     <admst:for-each select="variable[parametertype='instance' and input='no' and exists(attribute[name='hidden']) and type='real']">
       <admst:text format="double instancePar_%(name);\n"/>
       <admst:text format="double d_instancePar_%(name)_dX;\n"/>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[parametertype='instance' and (input='yes' or input='no' and exists(attribute[name='hidden'])) and not(type='real')] )]">
     <admst:text format="// non-reals(including hidden)\n"/>
     <admst:for-each select="variable[parametertype='instance' and (input='yes' or input='no' and exists(attribute[name='hidden'])) and not(type='real')]">
       <admst:apply-templates select="." match="verilog2CXXtype"/>
       <admst:text format=" instancePar_%(name);\n"/>
       <admst:if test="[not(exists(attribute[name='hidden']))]">
         <admst:text format="bool instancePar_given_%(name);\n"/>
       </admst:if>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden']) and type='real')]) or exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden'])) and not (type='real')])]">
     <admst:text format="// instance variables\n"/>
   </admst:if>
   <admst:if test="[exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden']) and type='real' and not(insource='no' and output='yes'))])]">
     <admst:text format="// reals\n"/>
     <admst:for-each select="variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden'])) and type='real' and not(insource='no' and output='yes')]">
       <admst:apply-templates select="." match="collectParamDependence"/>
       <admst:text format="double instanceVar_%(name);\n"/>
       <admst:if test="[exists(#Pdependent)]">
         <admst:text format="double d_instanceVar_%(name)_dX;\n"/>
       </admst:if>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden'])) and not (type='real')])]">
     <admst:text format="// non-reals\n"/>
     <admst:for-each select="variable[(scope='global_instance') and input='no' and not (type='real')]">
       <admst:apply-templates select="." match="verilog2CXXtype"/>
       <admst:text format=" instanceVar_%(name);\n"/>
     </admst:for-each>
   </admst:if>

   <admst:text format="};\n\n"/>
 </admst:template>

 <!--
   =================================================================-
   generateModelStruct

   Generate the declaration of a structure to hold model pars and vars
   to consolidate and simplify passing them to functions
 
   In this version, we're very specifically emitting declarations JUST
   for sensitivity, not for a general version.
   =================================================================-
 -->
 <admst:template match="generateModelStruct">
   <admst:text format="class modelSensStruct\n{\npublic:\n"/>

   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real']) or exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real']) or exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')])]">
     <admst:text format="// model parameters\n"/>
   </admst:if>

   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real'])]">
     <admst:text format="// reals\n"/>
     <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real']">
       <admst:text format="double modelPar_%(name);\n"/>
       <admst:text format="double d_modelPar_%(name)_dX;\n"/>
       <admst:text format="bool modelPar_given_%(name);\n"/>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real'])]">
     <admst:text format="// real hiddens\n"/>
     <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real']">
       <admst:text format="double modelPar_%(name); \n"/>
       <admst:text format="double d_modelPar_%(name)_dX;\n"/>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')])]">
     <admst:text format="// non-reals (including hidden)\n"/>
     <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')]">
       <admst:apply-templates select="." match="verilog2CXXtype"/>
       <admst:text format=" modelPar_%(name);\n"/>
       <admst:if test="[not(exists(attribute[name='hidden']))]">
         <admst:text format="bool modelPar_given_%(name);\n"/>
       </admst:if>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_model') and input='no' and not (exists(attribute[name='hidden'])) and type='real']) or exists( variable[(scope='global_model') and input='no' and not (type='real')])]">
     <admst:text format="// model variables\n"/>
   </admst:if>
   <admst:if test="[exists( variable[(scope='global_model') and input='no' and not (exists(attribute[name='hidden'])) and type='real'])]">
     <admst:text format="// reals\n"/>
     <admst:for-each select="variable[(scope='global_model') and input='no' and not (exists(attribute[name='hidden'])) and type='real']">
       <admst:apply-templates select="." match="collectParamDependence"/>
       <admst:text format="double modelVar_%(name);\n"/>
       <admst:if test="[exists(#Pdependent)]">
         <admst:text format="double d_modelVar_%(name)_dX;"/>
       </admst:if>
     </admst:for-each>
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_model') and input='no' and not (type='real')])]">
     <admst:text format="// non-reals\n"/>
     <admst:for-each select="variable[(scope='global_model') and input='no' and not (type='real')]">
       <admst:apply-templates select="." match="verilog2CXXtype"/>
       <admst:text format=" modelVar_%(name);"/>
     </admst:for-each>
   </admst:if>
   <admst:text format="};\n\n"/>

</admst:template>

</admst>

<?escript name="/usr/local/stow/Xyce/7.8-adms/share/xml/xyceAnalogFunction_nosac.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst SYSTEM "/users/tvrusso/src/QucsADMS/ADMS/admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!--
  Purpose:  Provide a set of ADMST templates for
            producing analog function declarations and implementations that
            do not rely on Sacado.

            The primary need here is for functions that return the derivatives
            of analog functions, as the templated functions provided in all
            prior implementations of Xyce/ADMS are adequate for the
            implementations that return the function values themselves.

            At least in the current plan, these functions will only be
            used in the normal (DC, AC, Transient, HB) contexts where
            only derivatives with respect to probes are needed, not in
            sensitivity context.  Providing flexible derivative
            computation with respect to arbitrary model or instance
            parameters is beyond the scope of the current work.

      Creator:   Tom Russo, SNL, Electrical Models and Simulation
      Creation Date: 10 Aug 2019

     Copyright 2002-2023 National Technology & Engineering Solutions of
     Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
     NTESS, the U.S. Government retains certain rights in this software.

     This file is part of the Xyce(TM) Parallel Electrical Simulator.

     Xyce(TM) is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     Xyce(TM) is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Xyce(TM).
     If not, see <http://www.gnu.org/licenses/>.

-->

<!-- One will note that there are a lot of templates here that
       appear in xyceBasicTemplates in much more involved form.  We
       have simpler needs here, and therefore have pared down the
       basic templates to their minimum.  Further, there are some
       differences that make the templates in xyceBasicTemplates
       unsuitable, so we can't just use them.  To prevent conflict,
       all the templates here that have similar function to a template
       in xyceBasicTemplates will have the "xyceAnalogFunctions:"
       prefix in their names.
-->

<!-- This declares the variable global, but doesn't assign anything
     to it. -->
<admst:variable name="globalAnalogFunction"/>

<!--
    xyceAnalogFunctions:processTerm

given a node (which must be a part of the analog function currently
being processed, i.e. the one pointed to by $globalAnalogFunction,
and which must be an expression or subexpression element),
return the C++ representation of this node and its derivatives with
respect to all input variables of the function.

This template does little more than farm out the real work to
templates specific to the datatype of the node passed in.

See "xyceAnalogFunctions:expression", "xyceAnalogFunctions:variable",
"xyceAnalogFunctions:wmapply_unary", etc. for specifics of what's
getting done at lower level.  Each level returns the value of the
expression and its derivatives with respect to its input variables in
"returned" variables such as returnedExpression and 'd_exp_d_X' for
each X that is an input variable of the function.

This template returns the same set of return variables that the
subordinate template returned.
-->

<admst:template match="xyceAnalogFunctions:processTerm">
  <admst:apply-templates select="." match="xyceAnalogFunctions:%(adms/datatypename)">
    <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:value-of select="name"/>
      <admst:value-of select="returned('d_exp_d_%s')/value"/>
      <admst:value-of select="name"/>
      <admst:variable name="d_exp_d_%s" select="%s"/>
    </admst:for-each>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:apply-templates>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:return name="d_exp_d_%s" value="$(d_exp_d_%s)"/>
  </admst:for-each>
</admst:template>

<!--
    ======================================
    Templates called by "processTerm"
    ======================================
-->

<!-- top level expression -->
<admst:template match="xyceAnalogFunctions:expression">
  <admst:apply-templates select="tree" match="xyceAnalogFunctions:%(adms/datatypename)" required="yes">
    <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:value-of select="name"/>
      <admst:value-of select="returned('d_exp_d_%s')/value"/>
      <admst:value-of select="name"/>
      <admst:variable name="d_exp_d_%s" select="%s"/>
    </admst:for-each>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:apply-templates>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:return name="d_exp_d_%s" value="$(d_exp_d_%s)"/>
  </admst:for-each>
</admst:template>

<!-- numeric constant with possible scale factor following -->
<admst:template match="xyceAnalogFunctions:number">
  <admst:value-of select="value"/>
  <admst:choose>
    <admst:when test="[scalingunit='1']"><admst:return name="returnedExpression" value="%s"/></admst:when>
    <admst:when test="[scalingunit='E']"><admst:return name="returnedExpression" value="(%s*1.0e+18)"/></admst:when>
    <admst:when test="[scalingunit='P']"><admst:return name="returnedExpression" value="%s*1.0e+15"/></admst:when>
    <admst:when test="[scalingunit='T']"><admst:return name="returnedExpression" value="%s*1.0e+12"/></admst:when>
    <admst:when test="[scalingunit='G']"><admst:return name="returnedExpression" value="%s*1.0e+9"/></admst:when>
    <admst:when test="[scalingunit='M']"><admst:return name="returnedExpression" value="%s*1.0e+6"/></admst:when>
    <admst:when test="[scalingunit='k']"><admst:return name="returnedExpression" value="%s*1.0e+3"/></admst:when>
    <admst:when test="[scalingunit='h']"><admst:return name="returnedExpression" value="%s*1.0e+2"/></admst:when>
    <admst:when test="[scalingunit='D']"><admst:return name="returnedExpression" value="%s*1.0e+1"/></admst:when>
    <admst:when test="[scalingunit='d']"><admst:return name="returnedExpression" value="%s*1.0e-1"/></admst:when>
    <admst:when test="[scalingunit='c']"><admst:return name="returnedExpression" value="%s*1.0e-2"/></admst:when>
    <admst:when test="[scalingunit='m']"><admst:return name="returnedExpression" value="%s*1.0e-3"/></admst:when>
    <admst:when test="[scalingunit='u']"><admst:return name="returnedExpression" value="%s*1.0e-6"/></admst:when>
    <admst:when test="[scalingunit='n']"><admst:return name="returnedExpression" value="%s*1.0e-9"/></admst:when>
    <admst:when test="[scalingunit='A']"><admst:return name="returnedExpression" value="%s*1.0e-10"/></admst:when>
    <admst:when test="[scalingunit='p']"><admst:return name="returnedExpression" value="%s*1.0e-12"/></admst:when>
    <admst:when test="[scalingunit='f']"><admst:return name="returnedExpression" value="%s*1.0e-15"/></admst:when>
    <admst:when test="[scalingunit='a']"><admst:return name="returnedExpression" value="%s*1.0e-18"/></admst:when>
    <admst:otherwise>
      <admst:value-of select="scalingunit"/>
      <admst:fatal format="%s%s: scaling unit not supported\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:return name="d_exp_d_%s" value="0.0"/>
  </admst:for-each>
</admst:template>

<!-- string value -->
<admst:template match="xyceAnalogFunctions:string">
  <admst:return name="returnedExpression" value="&quot;%(value)&quot;"/>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:return name="d_exp_d_%s" value="0.0"/>
  </admst:for-each>
</admst:template>

<!-- variable -->
<admst:template match="xyceAnalogFunctions:variable">
  <admst:variable name="theVar" select="%(.)"/>
  <admst:variable name="variable" select="%(name)"/>
  <admst:return name="returnedExpression" value="$variable"/>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:variable name="wrt" select="%(name)"/>
    <admst:choose>
      <admst:when test="[$theVar/type != 'real']">
        <admst:return name="d_exp_d_$wrt" value="0.0"/>
      </admst:when>
      <admst:when test="[$variable='$wrt']">
        <admst:return name="d_exp_d_$wrt" value="1.0"/>
      </admst:when>
      <admst:when test="../..[input='yes']">
        <admst:return name="d_exp_d_$wrt" value="0.0"/>
      </admst:when>
      <admst:otherwise>
        <admst:return name="d_exp_d_$wrt" value="d_$(variable)_d_$wrt"/>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
</admst:template>

<!-- unary operators -->
<!-- Note: this operator has one operand, arg1, which must be processed first
     before returning value and derivatives. -->
<admst:template match="xyceAnalogFunctions:mapply_unary">
  <!-- First decide what type of operator we are -->
  <admst:if test="[name='plus']">
    <admst:variable name="op" value="+"/>
  </admst:if>
  <admst:if test="[name='minus']">
    <admst:variable name="op" value="-"/>
  </admst:if>
  <admst:if test="[name='not']">
    <admst:variable name="op" value="!"/>
  </admst:if>
  <admst:if test="[name='bw_not']">
    <admst:variable name="op" value="~"/>
  </admst:if>
  <admst:choose>
    <admst:when test="[arg1/math/value=0.0]">
      <admst:variable name="expression" value="0.0"/>
      <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:variable name="d_exp_d_%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="arg1/adms/datatypename"/>
      <admst:apply-templates select="arg1" match="xyceAnalogFunctions:%s" required="yes">
        <admst:value-of select="returned('returnedExpression')/value"/>
        <admst:variable name="expression" select="($op%s)"/>

        <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('d_exp_d_%s')/value"/>
          <admst:variable name="a1Deriv" select="%s"/>
          <admst:choose>
            <admst:when test="[$a1Deriv='0.0']">
              <admst:value-of select="name"/>
              <admst:variable name="d_exp_d_%s" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-of select="name"/>
              <admst:variable name="d_exp_d_%s" select="($op$a1Deriv)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
      </admst:apply-templates>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="returnedExpression" value="$expression"/>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:return name="d_exp_d_%s" value="$(d_exp_d_%s)"/>
  </admst:for-each>
</admst:template>

<!-- binary operators -->
<admst:template match="xyceAnalogFunctions:mapply_binary">
  <!-- process arguments and get their derivatives -->
  <admst:apply-templates select="arg1" match="xyceAnalogFunctions:processTerm">
    <admst:value-of select="returned('returnedExpression')/value"/>
    <admst:variable name="a1" select="%s"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:value-of select="name"/>
      <admst:value-of select="returned('d_exp_d_%s')/value"/>
      <admst:value-of select="name"/>
      <admst:variable name="d_a1_d_%s" select="%s"/>
    </admst:for-each>
  </admst:apply-templates>
  <admst:apply-templates select="arg2" match="xyceAnalogFunctions:processTerm">
    <admst:value-of select="returned('returnedExpression')/value"/>
    <admst:variable name="a2" select="%s"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:value-of select="name"/>
      <admst:value-of select="returned('d_exp_d_%s')/value"/>
      <admst:value-of select="name"/>
      <admst:variable name="d_a2_d_%s" select="%s"/>
    </admst:for-each>
  </admst:apply-templates>
  <admst:choose>
    <!-- addition -->
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="expression" select="0.0"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" value="0.0"/>
          </admst:for-each>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="expression" select="(+%($a2))"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a2Deriv" select="$(d_a2_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="(+%($a2Deriv))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[arg2/math/value=0.0]">
          <admst:variable name="expression" select="(%($a1))"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a1Deriv" select="$(d_a1_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="(%($a1Deriv))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expression" select="($a1+$a2)"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a1Deriv" select="$(d_a1_d_%s)"/>
            <admst:value-of select="name"/>
            <admst:variable name="a2Deriv" select="$(d_a2_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv ='0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="0.0"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="$a2Deriv"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="$a1Deriv"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="($a1Deriv+$a2Deriv)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <!-- subtraction -->
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="expression" select="0.0"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" value="0.0"/>
          </admst:for-each>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="expression" select="(-%($a2))"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a2Deriv" select="$(d_a2_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="(-%($a2Deriv))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[arg2/math/value=0.0]">
          <admst:variable name="expression" select="(%($a1))"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a1Deriv" select="$(d_a1_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" value="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="(%($a1Deriv))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expression" select="($a1-$a2)"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a1Deriv" select="$(d_a1_d_%s)"/>
            <admst:value-of select="name"/>
            <admst:variable name="a2Deriv" select="$(d_a2_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv ='0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" value="0.0"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="(-$a2Deriv)"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="$a1Deriv"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="name"/>
                <admst:variable name="d_exp_d_%s" select="($a1Deriv-$a2Deriv)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <!-- multiplication -->
    <admst:when test="[name='multtime']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
          <admst:variable name="expression" select="0.0"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" value="0.0"/>
          </admst:for-each>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="expression" select="1.0"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" value="0.0"/>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expression" select="($a1*$a2)"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a1Deriv" select="$(d_a1_d_%s)"/>
            <admst:value-of select="name"/>
            <admst:variable name="a2Deriv" select="$(d_a2_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0' and $a2Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1)"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0' and $a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="($a2)"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0' and $a2Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1+$a2)"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="($a1*$a2Deriv)"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '0.0']">
                <admst:variable name="expressionDeriv" select="($a1Deriv*$a2)"/>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1*$a2Deriv+$a2)"/>
              </admst:when>
              <admst:when test="[$a2Deriv = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1+$a2*$a1Deriv)"/>
              </admst:when>
              <admst:when test="[$a1 = '1.0']">
                <admst:variable name="expressionDeriv" select="($a2Deriv)"/>
              </admst:when>
              <admst:when test="[$a2 = '1.0']">
                <admst:variable name="expressionDeriv" select="($a1Deriv)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expressionDeriv" select="(($a1*$a2Deriv)+($a1Deriv*$a2))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" select="$expressionDeriv"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="expression" select="0.0"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" value="0.0"/>
          </admst:for-each>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="expression" select="1.0"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" value="0.0"/>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expression" select="($a1/$a2)"/>
          <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="a1Deriv" select="$(d_a1_d_%s)"/>
            <admst:value-of select="name"/>
            <admst:variable name="a2Deriv" select="$(d_a2_d_%s)"/>
            <admst:choose>
              <admst:when test="[$a1Deriv='0.0' and $a2Deriv='0.0']">
                <admst:variable name="expressionDeriv" select="0.0"/>
              </admst:when>
              <admst:when test="[$a1 = '1.0']">
                <admst:choose>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(-1.0/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(-$a2Deriv/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$a1Deriv = '0.0']">
                <admst:choose>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(-$a1/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(-$a1*$a2Deriv/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$a1Deriv = '1.0']">
                <admst:choose>
                  <admst:when test="[$a2Deriv = '0.0']">
                    <admst:variable name="expressionDeriv" select="(1.0/$a2)"/>
                  </admst:when>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(($a2-$a1)/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(($a2-($a1*$a2Deriv))/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$a2 = '1.0']">
                    <admst:variable name="expressionDeriv" select="$a1Deriv"/>
                  </admst:when>
                  <admst:when test="[$a2Deriv = '0.0']">
                    <admst:variable name="expressionDeriv" select="($a1Deriv/$a2)"/>
                  </admst:when>
                  <admst:when test="[$a2Deriv = '1.0']">
                    <admst:variable name="expressionDeriv" select="(($a2*$a1Deriv-$a1)/$a2/$a2)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expressionDeriv" select="(($a2*$a1Deriv-$a1*$a2Deriv)/$a2/$a2)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
            <admst:value-of select="name"/>
            <admst:variable name="d_exp_d_%s" select="$expressionDeriv"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="expression" select="($a1%(bname(.)/[name='bname']/value)$a2)"/>
      <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:variable name="d_exp_d_%s" value="0.0"/>
      </admst:for-each>
    </admst:otherwise>
  </admst:choose>

  <admst:return name="returnedExpression" value="$expression"/>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:return name="d_exp_d_%s" value="$(d_exp_d_%s)"/>
  </admst:for-each>

</admst:template>

<!-- Ternary operator (condition)?iftrue:iffalse -->

<admst:template match="xyceAnalogFunctions:mapply_ternary">
  <!-- derivatives of conditional are not needed -->
  <admst:apply-templates select="arg1" match="xyceAnalogFunctions:processTerm">
    <admst:value-of select="returned('returnedExpression')/value"/>
    <admst:variable name="a1" select="%s"/>
  </admst:apply-templates>
  <admst:apply-templates select="arg2" match="xyceAnalogFunctions:processTerm">
    <admst:value-of select="returned('returnedExpression')/value"/>
    <admst:variable name="a2" select="%s"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:value-of select="name"/>
      <admst:value-of select="returned('d_exp_d_%s')/value"/>
      <admst:value-of select="name"/>
      <admst:variable name="d_a2_d_%s" select="%s"/>
    </admst:for-each>
  </admst:apply-templates>
  <admst:apply-templates select="arg3" match="xyceAnalogFunctions:processTerm">
    <admst:value-of select="returned('returnedExpression')/value"/>
    <admst:variable name="a3" select="%s"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:value-of select="name"/>
      <admst:value-of select="returned('d_exp_d_%s')/value"/>
      <admst:value-of select="name"/>
      <admst:variable name="d_a3_d_%s" select="%s"/>
    </admst:for-each>
  </admst:apply-templates>
  <admst:variable name="expression" select="($a1?$a2:$a3)"/>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:variable name="a2Deriv" select="$(d_a2_d_%s)"/>
    <admst:value-of select="name"/>
    <admst:variable name="a3Deriv" select="$(d_a3_d_%s)"/>
    <admst:value-of select="name"/>
    <admst:variable name="d_exp_d_%s" select="($a1?$a2Deriv:$a3Deriv)"/>
  </admst:for-each>
  <admst:return name="returnedExpression" value="$expression"/>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:return name="d_exp_d_%s" value="$(d_exp_d_%s)"/>
  </admst:for-each>
</admst:template>

<!-- Function call -->
<admst:template match="xyceAnalogFunctions:function">
  <admst:variable name="doingAnalogFunctionCall" value="no"/>
  <admst:variable name="funcname" select="%(xyceAnalogFunctions:funcname(.)/[name='fname']/value)"/>
  <admst:variable name="args" select=""/>
  <admst:variable name="thisFunctionCall" path="."/>
  <admst:if test="[$funcname='hypot']">
    <admst:assert test="arguments[count(.)=2]" format="hypot function must take exactly two arguments.\n"/>
  </admst:if>
  <admst:for-each select="arguments">
    <admst:if test="[not($args='')]">
      <admst:variable name="args" select="$args,"/>
    </admst:if>
    <admst:value-of select="index(../arguments,.)"/>
    <admst:variable name="index" select="%s"/>

    <admst:apply-templates select="." match="xyceAnalogFunctions:processTerm">
      <admst:variable name="arg$(index)" select="%(returned('returnedExpression')/value)"/>
      <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:value-of select="returned('d_exp_d_%s')/value"/>
        <admst:value-of select="name"/>
        <admst:variable name="d_arg$(index)_d_%s" select="%s"/>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[../name='min' or ../name='max']">
          <!-- this is ridiculously over-conservative, and may be better done
               by calling xyceAnalogFunctions:realArgument, but right now
               I'm just going with the over-conservative -->
          <admst:variable name="args" select="$args static_cast&lt;double&gt;($(arg$index))"/>
        </admst:when>
        <admst:when test="[(../definition/datatypename='analogfunction') and ((datatypename='number') or (datatypename='variable' and type='integer'))]">
          <admst:variable name="argtype" select="huh?" />
          <admst:for-each select="../definition/variable[input='yes' or (output='yes' and name !=$thisFunctionCall/name)]">
            <admst:if test="[position(.)-1=$index]">
              <admst:variable name="argtype" select="%(type)"/>
            </admst:if>
          </admst:for-each>
          <admst:choose>
            <admst:when test="[$argtype='real']">
              <admst:variable name="args" select="$args static_cast&lt;double&gt;($(arg$index))"/>
            </admst:when>
            <admst:otherwise>
                <admst:variable name="args" select="$args$(arg$index)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="args" select="$args$(arg$index)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:apply-templates>
  </admst:for-each>

  <!-- We now have all our arguments collected up in "$args", each
       individual argument in $arg#, and each argument's derivatives
       in the $d_arg#_d_name variables.  Form the actual function call
       and its derivatives.  Note:  "index" returns zero-based indices -->
  <admst:choose>
    <admst:when test="[$funcname='\$vt']">
      <admst:choose>
        <admst:when test="[$args='']">
          <admst:fatal format="Illegal to use \$vt with no argument in analog function\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expression" value="adms_vt($args)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <!-- this special case doesn't follow the same pattern as other
         simple function calls.  We have also already handled misuse
         of the call above, so just assume we have two args here -->
    <admst:when test="[$funcname='hypot']">
      <admst:variable name="expression" select="sqrt(%($arg0)*%($arg0)+%($arg1)*%($arg1))"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="expression" select="$funcname($args)"/>
    </admst:otherwise>
  </admst:choose>

  <!-- Now let us construct expressions for the derivative of the function
       with respect to its arguments. These will be stored in d_f_d#, where
       # is the index (zero-based) of the argument -->
  <admst:choose>
    <admst:when test="[name='\$vt']">
      <admst:variable name="d_f_d0" value="CONSTKoverQ"/>
    </admst:when>
    <admst:when test="[name='exp' or name='ln' or name='log' or name='sqrt' or name='abs' or name='limexp' or name='cos' or name='sin' or name='tan' or name='acos' or name='asin' or name='atan' or name='cosh' or name='sinh' or name='tanh' or name='acosh' or name='asinh' or name='atanh' or name='ceil' or name='floor']">
      <!-- functions of one argument, set "d_f_d0" to the expression for
           the derivative of f(x)/dx where x is the argument -->
      <admst:choose>
        <admst:when test="[name='exp']">
          <admst:variable name="d_f_d0" select="exp(%($arg0))"/>
        </admst:when>
        <admst:when test="[name='ln']">
          <admst:variable name="d_f_d0" select="(1.0/%($arg0))"/>
        </admst:when>
        <admst:when test="[name='log']">
          <admst:variable name="d_f_d0" select="(1.0/(log(10.0)*%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='sqrt']">
          <admst:variable name="d_f_d0" select="(0.5/sqrt(%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='abs']">
          <admst:variable name="d_f_d0" select="(((%($arg0)&gt;=0)?(+1.0):(-1.0)))"/>
        </admst:when>
        <admst:when test="[name='cos']">
          <admst:variable name="d_f_d0" select="(-sin(%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='sin']">
          <admst:variable name="d_f_d0" select="(cos(%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='tan']">
          <admst:variable name="d_f_d0" select="(1.0/cos(%($arg0))/cos(%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='acos']">
          <admst:variable name="d_f_d0" select="(-1.0/sqrt(1.0-%($arg0)*%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='asin']">
          <admst:variable name="d_f_d0" select="(+1.0/sqrt(1.0-%($arg0)*%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='atan']">
          <admst:variable name="d_f_d0" select="(+1.0/sqrt(1.0+%($arg0)*%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='cosh']">
          <admst:variable name="d_f_d0" select="(sinh(%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='sinh']">
          <admst:variable name="d_f_d0" select="(cosh(%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='tanh']">
          <admst:variable name="d_f_d0" select="(1.0/cosh(%($arg0))/cosh(%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='acosh']">
          <admst:variable name="d_f_d0" select="(1.0/(sqrt(%($arg0)-1)*sqrt(%($arg0)+1)))"/>
        </admst:when>
        <admst:when test="[name='asinh']">
          <admst:variable name="d_f_d0" select="(1.0/(sqrt(%($arg0)*%($arg0)+1.0)))"/>
        </admst:when>
        <admst:when test="[name='atanh']">
          <admst:variable name="d_f_d0" select="(1.0/(1.0-%($arg0)*%($arg0)))"/>
        </admst:when>
        <admst:when test="[name='limexp']">
          <admst:variable name="d_f_d0" select="(((%($arg0))&lt;80)?(limexp(%($arg0))):exp(80.0))"/>
        </admst:when>
        <admst:when  test="[name='ceil' or name='floor']">
          <admst:variable name="d_f_d0" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="d_f_d0" select="0.0"/>
          <admst:warning format="function derivative for %(name) not implemented yet!\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='pow' or name='min' or name='max' or name='hypot' or name='atan2']">
      <!-- two-argument functions -->
      <admst:choose>
        <admst:when test="[name='pow']">
          <admst:variable name="d_f_d0" select="((%($arg0)==0.0)?0.0:(pow(%($arg0),%($arg1))*%($arg1)/%($arg0)))"/>
          <admst:variable name="d_f_d1" select="((%($arg0)==0.0)?0.0:(log(%($arg0)*pow(%($arg0),%($arg1)))))"/>
        </admst:when>
        <admst:when test="[name='min']">
          <admst:variable name="d_f_d0" select="((%($arg0)&lt;=%($arg1))?1.0:0.0)"/>
          <admst:variable name="d_f_d1" select="((%($arg0)&lt;=%($arg1))?0.0:1.0)"/>
        </admst:when>
        <admst:when test="[name='max']">
          <admst:variable name="d_f_d0" select="((%($arg0)&gt;=%($arg1))?1.0:0.0)"/>
          <admst:variable name="d_f_d1" select="((%($arg0)&gt;=%($arg1))?0.0:1.0)"/>
        </admst:when>
        <admst:when test="[name='hypot']">
          <admst:variable name="d_f_d0" select="(%($arg0)/sqrt(%($arg0)*%($arg0)+%($arg1)*%($arg1)))"/>
          <admst:variable name="d_f_d1" select="(%($arg1)/sqrt(%($arg0)*%($arg0)+%($arg1)*%($arg1)))"/>
        </admst:when>
        <admst:when test="[name='atan2']">
          <admst:variable name="d_f_d0" select="%($arg1)/(%($arg0)*%($arg0)+%($arg1)*%($arg1))"/>
          <admst:variable name="d_f_d1" select="-%($arg0)/(%($arg0)*%($arg0)+%($arg1)*%($arg1))"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="d_f_d0" select="0.0"/>
          <admst:variable name="d_f_d1" select="0.0"/>
          <admst:warning format="function derivative for %(name) not implemented yet!\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:if test="[class!='analog']">
        <admst:fatal format="Unable to handle function %(name) of class %(class) at this time.  Bye."/>
      </admst:if>
      <!-- we are an analog function, and this is very different than everything
           else -->
      <admst:variable name="doingAnalogFunctionCall" value="yes"/>
      <admst:variable name="defaultdontbother" value="yes"/>
      <admst:variable name="expression" value="%(name)(%($args))"/>
      <admst:return name="returnedExpression" value="$expression"/>
      <admst:if test="[definition/datatypename='analogfunction']">
        <!-- <admst:message format="Processing analog function call within analog function definition\n"/> -->
        <admst:if test="[exists(definition/variable[(output='yes') and (name!=$thisFunctionCall/name)])]">
          <!-- <admst:message format="Called analog function has output variables other than return value.\n"/>-->
          <admst:variable name="defaultdontbother" value="no"/>
        </admst:if>
      </admst:if>
      <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
        <admst:variable name="dontbother" value="$(defaultdontbother)"/>
        <admst:variable name="dargs" value=""/>
        <admst:variable name="wrt" value="%(name)"/>
        <admst:for-each select="$thisFunctionCall/arguments">
          <admst:value-of select="index($thisFunctionCall/arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:if test="[($(d_arg$(index)_d_$(wrt)) != '0.0')]">
            <admst:variable name="dontbother" value="no"/>
          </admst:if>
          <admst:if test="[not($dargs='')]">
            <admst:variable name="dargs" select="$dargs,"/>
          </admst:if>
          <admst:variable name="dargs" select="$(dargs)$(d_arg$(index)_d_$(wrt))"/>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[$dontbother='yes']">
            <admst:variable name="expressionDeriv" value="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expressionDeriv" value="d_%($thisFunctionCall/name)($args,$dargs)"/>
          </admst:otherwise>
        </admst:choose>
        <admst:return name="d_exp_d_$(wrt)" value="$expressionDeriv"/>
      </admst:for-each>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="[$doingAnalogFunctionCall = 'no']">
    <!-- we now have the function value and its derivatives with respect to
         its arguments, and the derivatives of the arguments with respect to
         all analog function dummy arguments.  Emit the total derivatives. -->

    <admst:return name="returnedExpression" value="$expression"/>

    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:variable name="expressionDeriv" select=""/>
      <admst:variable name="wrt" value="%(name)"/>
      <admst:for-each select="$thisFunctionCall/arguments">
        <admst:value-of select="index($thisFunctionCall/arguments,.)"/>
        <admst:variable name="index" select="%s"/>
        <admst:if test="[($(d_arg$(index)_d_$(wrt)) != '0.0') and ($(d_f_d$(index)) != '0.0')]">
          <admst:if test="[not($expressionDeriv='')]">
            <admst:variable name="expressionDeriv" select="$(expressionDeriv)+"/>
          </admst:if>
          <admst:choose>
            <admst:when test="[$(d_arg$(index)_d_$(wrt)) = '1.0']">
              <admst:variable name="expressionDeriv" select="$(expressionDeriv)$(d_f_d$(index))"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expressionDeriv" select="$(expressionDeriv)$(d_f_d$(index))*$(d_arg$(index)_d_$(wrt))"/>
            </admst:otherwise>
          </admst:choose>
        </admst:if>
      </admst:for-each>
      <!-- handle the case where it turned out that all the derivs were zero -->
      <admst:if test="[$expressionDeriv='']">
        <admst:variable name="expressionDeriv" value="0.0"/>
      </admst:if>
      <admst:value-of select="name"/>
      <admst:return name="d_exp_d_%s" value="$expressionDeriv"/>
    </admst:for-each>
  </admst:if>
</admst:template>


<!-- template to force an argument into a real (used only for min and max) -->
<admst:template match="xyceAnalogFunctions:realArgument">
  <admst:choose>
    <admst:when test="[datatypename='number' or (datatypename='variable' and type='integer')]">
        <admst:variable name="localArg" select="static_cast&lt;double&gt;(%(xyceAnalogFunctions:processTerm(.)/[name='returnedExpression']/value))" />
      </admst:when>
      <admst:otherwise>
        <admst:variable name="localArg" select="%(xyceAnalogFunctions:processTerm(.)/[name='returnedExpression']/value)" />
      </admst:otherwise>
    </admst:choose>
    <admst:return name="argval" value="$localArg"/>
</admst:template>

<!-- template to return the C++ name of a function given the Verilog name -->
<!-- Very much like the one in xyceBasicTemplates, but stripped of all
     context-dependent conditionals -->

<admst:template match="xyceAnalogFunctions:funcname">
  <admst:choose>
    <admst:when test="[name='min']">
      <admst:variable name="expression" select="std::min"/>
    </admst:when>
    <admst:when test="[name='max']">
      <admst:variable name="expression" select="std::max"/>
    </admst:when>
    <admst:when test="[name='abs']">
      <admst:variable name="expression" select="fabs"/>
    </admst:when>
    <admst:when test="[name='\$shrinkl']">
      <admst:fatal format="\$shrinkl not supported in Xyce"/>
    </admst:when>
    <admst:when test="[name='\$shrinka']">
      <admst:fatal format="\$shrinka not supported in Xyce"/>
    </admst:when>
    <admst:when test="[name='log']">
      <admst:variable name="expression" select="(1.0/log(10.0))*log"/>
    </admst:when>
    <admst:when test="[name='ln']">
      <admst:variable name="expression" select="log"/>
    </admst:when>
    <admst:when test="[name='limexp']">
      <admst:variable name="expression" select="limexp"/>
    </admst:when>
    <admst:when test="[name='\$limexp']">
      <admst:variable name="expression" select="limexp"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="expression" select="%(name)"/>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="fname" value="$expression"/>
</admst:template>

<!-- These templates are used in actual code generation -->
<!-- each one returns a string that should simply be emitted in the
     "returnedString" return slot. -->
<!-- At the moment, we're ONLY emitting derivative functions, so we are
     only providing templates that do differentiation.  That's because
     we're already emitting a templated analog function, and it works just
     fine when everything's "double", and does Sacado differentiation when
     everything's a Sacado type.  Therefore we are not bothering to produce
     a second set of templates that do no differentiation for analog functions,
     as some other ADMS back-ends do.
     If at some point in the future we need to do that, we can create a
     second set of templates with a suffix in their names and use those
     for that purpose. -->

<!-- assignment -->
<admst:template match="xyceAnalogFunctions:assignment">
  <admst:variable name="lhsname" value="%(lhs/name)"/>
  <admst:variable name="lhstype" value="%(lhs/type)"/>
  <admst:apply-templates select="rhs" match="xyceAnalogFunctions:processTerm">
    <admst:variable name="returnedString" select="" />

    <admst:if test="[$lhstype = 'real']">
      <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:value-of select="returned('d_exp_d_%s')/value"/>
        <admst:value-of select="name"/>
        <admst:variable name="returnedString" select="$(returnedString)d_$(lhsname)_d_%s=%s;\n"/>
      </admst:for-each>
    </admst:if>
    <admst:value-of select="returned('returnedExpression')/value"/>
    <admst:variable name="returnedString" select="$(returnedString)$(lhsname)=%s;\n"/>
  </admst:apply-templates>
  <admst:return name="returnedString" value="$returnedString"/>
</admst:template>

<!-- if/then/else -->
<admst:template match="xyceAnalogFunctions:conditional">
  <admst:variable name="condition"/>
  <admst:variable name="thenblock"/>
  <admst:variable name="elseblock"/>
  <admst:variable name="condition" select="%(xyceAnalogFunctions:processTerm(if)/[name='returnedExpression']/value)"/>
  <admst:variable name="thenblock" value=""/>
  <admst:apply-templates select="then" match="xyceAnalogFunctions:%(adms/datatypename)">
    <admst:if test="[adms/datatypename != 'block']">
      <admst:variable name="thenblock" value="{\n"/>
    </admst:if>
    <admst:value-of select="returned('returnedString')/value"/>
    <admst:variable name="thenblock" select="$(thenblock)%s"/>
    <admst:if test="[adms/datatypename != 'block']">
      <admst:variable name="thenblock" value="$(thenblock)}\n"/>
    </admst:if>
  </admst:apply-templates>
  <admst:variable name="returnedString" value="if($condition)\n$thenblock"/>
  <admst:if test="else">
    <admst:variable name="elseblock" value=""/>
    <admst:apply-templates select="else" match="xyceAnalogFunctions:%(adms/datatypename)">
      <admst:if test="[adms/datatypename != 'block']">
        <admst:variable name="elseblock" value="{\n"/>
      </admst:if>
      <admst:value-of select="returned('returnedString')/value"/>
      <admst:variable name="elseblock" select="$(elseblock)%s"/>
      <admst:if test="[adms/datatypename != 'block']">
        <admst:variable name="elseblock" value="$(elseblock)}\n"/>
      </admst:if>
    </admst:apply-templates>
    <admst:variable name="returnedString" value="$(returnedString)else\n$elseblock"/>
  </admst:if>
  <admst:return name="returnedString" value="$returnedString"/>
</admst:template>

<!-- for loop -->
<admst:template match="xyceAnalogFunctions:forloop">
  <admst:variable name="returnedString" value="for ("/>
  <admst:variable name="returnedString" select="$(returnedString)%(xyceAnalogFunctions:processTerm(initial/lhs)/[name='returnedExpression']/value)=%(xyceAnalogFunctions:processTerm(initial/rhs)/[name='returnedExpression']/value);"/>
  <admst:variable name="returnedString" select="$(returnedString)%(xyceAnalogFunctions:processTerm(condition)/[name='returnedExpression']/value);"/>
  <admst:variable name="returnedString" select="$(returnedString)%(xyceAnalogFunctions:processTerm(update/lhs)/[name='returnedExpression']/value)=%(xyceAnalogFunctions:processTerm(update/rhs)/[name='returnedExpression']/value) )\n"/>

  <admst:if test="[forblock/adms[datatypename!='block']]">
    <admst:variable name="returnedString" select="$(returnedString){\n"/>
  </admst:if>
  <admst:apply-templates select="forblock" match="xyceAnalogFunctions:%(adms/datatypename)">
    <admst:value-of select="returned('returnedString')/value"/>
    <admst:variable name="returnedString" select="$(returnedString)%s"/>
  </admst:apply-templates>
  <admst:if test="[forblock/adms[datatypename!='block']]">
    <admst:variable name="returnedString" select="$(returnedString)}\n"/>
  </admst:if>

  <admst:return name="returnedString" value="$returnedString"/>
</admst:template>

<!-- while loop -->
<admst:template match="xyceAnalogFunctions:whileloop">
  <admst:variable name="returnedString" value="while (%(processTerm(while)[name='returnedExpression']/value))\n"/>
  <admst:if test="[whileblock/adms[datatypename!='block']]">
    <admst:variable name="returnedString" select="$(returnedString){\n"/>
  </admst:if>
  <admst:apply-templates select="whileblock" match="xyceAnalogFunctions:%(adms/datatypename)">
    <admst:value-of select="returned('returnedString')/value"/>
    <admst:variable name="returnedString" select="$(returnedString)%s"/>
  </admst:apply-templates>
  <admst:if test="[whileblock/adms[datatypename!='block']]">
    <admst:variable name="returnedString" select="$(returnedString)}\n"/>
  </admst:if>

  <admst:return name="returnedString" value="$returnedString"/>
</admst:template>

<!-- case statement -->
<admst:template match="xyceAnalogFunctions:case">
  <admst:variable name="casecondition" path="case/tree"/>
  <admst:variable name="havedefault" select="no"/>
  <admst:if test="[count(caseitem[defaultcase='yes']) > 0]">
    <admst:variable name="havedefault" select="yes"/>
  </admst:if>
  <admst:variable name="returnedString" value=""/>
  <admst:variable name="conditionString" value=""/>
  <admst:for-each select="caseitem[defaultcase='no']">
    <admst:variable name="returnedString" select="$(returnedString)if( "/>
    <admst:for-each select="condition">
      <admst:if test="[$conditionString!='']">
        <admst:variable name="conditionString" value="$(conditionString) || "/>
      </admst:if>
      <admst:apply-templates select="." match="xyceAnalogFunctions:%(datatypename)">
        <admst:variable name="conditionString" select="%(xyceAnalogFunctions:processTerm($casecondition)[name='returnedExpression']/value) == %(returned('returnedExpression')/value)"/>
      </admst:apply-templates>
    </admst:for-each>

    <admst:variable name="returnedString" select="$(returnedString)$(conditionString))\n"/>
    <admst:apply-templates select="code" match="xyceAnalogFunctions:%(datatypename)" required="yes">
      <admst:if test="[datatypename!='block']">
        <admst:variable name="returnedString" select="$(returnedString){\n"/>
      </admst:if>
      <admst:variable name="returnedString" select="$(returnedString)%(returned('returnedString')/value)"/>
      <admst:if test="[datatypename!='block']">
        <admst:variable name="returnedString" select="$(returnedString)}\n"/>
      </admst:if>
      <admst:variable name="returnedString" select="$(returnedString)else\n"/>
    </admst:apply-templates>
    <admst:if test="[$havedefault='no']">
      <admst:variable name="returnedString" select="$(returnedString){\n // no default\n}\n"/>
    </admst:if>
  </admst:for-each>
  <admst:for-each select="caseitem[defaultcase='yes']">
    <admst:apply-templates select="code" match="xyceAnalogFunctions:%(datatypename)" required="yes">
      <admst:variable name="returnedString" select="$(returnedString)%(returned('returnedString')/value)"/>
    </admst:apply-templates>
  </admst:for-each>
  <admst:return name="returnedString" value="$returnedString"/>
</admst:template>

<!-- block -->
<admst:template match="xyceAnalogFunctions:block">
  <admst:variable name="returnedString" value=""/>
  <admst:if test="[name!='']">
    <admst:variable name="returnedString" value="//Begin block %(name)\n"/>
  </admst:if>
  <admst:variable name="returnedString" value="$(returnedString){\n"/>
  <admst:apply-templates select="item" match="xyceAnalogFunctions:%(adms/datatypename)">
    <admst:value-of select="returned('returnedString')/value"/>
    <admst:variable name="returnedString" select="$(returnedString)%s"/>
  </admst:apply-templates>
  <admst:variable name="returnedString" value="$(returnedString)}\n"/>
  <admst:if test="[name!='']">
    <admst:variable name="returnedString" value="//End block %(name)\n"/>
  </admst:if>
  <admst:return name="returnedString" value="$returnedString"/>
</admst:template>

<!-- Declare block-local variables -->
<admst:template match="xyceAnalogFunctions:blockvariable">
  <admst:variable name="returnedString" value="//block-local variables for block %(block/name)\n"/>
  <admst:for-each select="variable">
    <admst:choose>
      <admst:when test="[type='real']">
        <admst:variable name="returnedString" select="$(returnedString) double %(name);\n"/>
        <admst:variable name="theName" select="%(name)"/>
        <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
          <admst:variable name="wrt" select="%(name)"/>
          <admst:variable name="returnedString" select="$(returnedString) double d_$(theName)_d_$(wrt);\n"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="[type='integer']">
        <admst:variable name="returnedString" select="$(returnedString) int %(name);\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="At the moment, Xyce/ADMS only supports real and integer block-local variables in analog functions\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
  <admst:return name="returnedString" value="$returnedString"/>
</admst:template>
<!-- these should never get called, and if they do, it's a warning -->
<admst:template match="xyceAnalogFunctions:callfunction">
  <admst:warning format="callfunctions cannot be accessed inside analog functions, ignoring %(function/name)\n"/>
  <admst:return name="returnedString" value=""/>
</admst:template>

<!-- these should never get called, and if they do, it's an error -->
<admst:template match="xyceAnalogFunctions:probe">
  <admst:fatal format="Probes cannot be accessed inside analog functions\n"/>
</admst:template>
<admst:template match="xyceAnalogFunctions:contribution">
  <admst:fatal format="contributions cannot be used inside analog functions\n"/>
</admst:template>
<!-- end error types -->

<!-- template to dump out the declaration/prototype of analog function
     derivative function -->

<admst:template match="xyceAnalogFunctions:Declaration">

    <admst:variable name="function" select="%(name)"/>
    <admst:variable name="globalAnalogFunction" path="."/>
    <admst:text format="// Derivative of Analog Function %(name)\n"/>
    <admst:text format="%(verilog2CXXtype(.)) d_%(name)("/>
    <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
      <admst:text format="%(verilog2CXXtype(.)) "/>
      <!-- irrespective of whether the argument is an output variable,
           we always pass by value.  We are NOT returning the function
           value and its output variable values, only the derivatives! -->
      <admst:text format="%(name) "/>
    </admst:join>
    <admst:text format=" , "/>
    <!-- now the derivatives of the args w.r.t. the desired variable -->
    <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
      <admst:text format="%(verilog2CXXtype(.)) "/>
      <admst:if test="[output='yes']">
        <admst:text format="&amp; "/>
      </admst:if>
      <admst:text format="d_%(name)  "/>
    </admst:join>
    <admst:text format=");\n"/>
</admst:template>

<!-- template to dump out the declaration of the class needed to handle
    analog functions in precomputation usage, i.e. outside of sensitivity
    context.  This will ultimately completely replace the simple "d_"
    derivative-calculating technique.
    -->
<admst:template match="xyceAnalogFunctions:ClassDeclaration">
  <admst:variable name="function" select="%(name)"/>
  <admst:variable name="globalAnalogFunction" path="."/>
  <admst:text format="// Evaluator class for Analog Function %(name)\n"/>
  <admst:text format="class $(function)Evaluator\n"/>
  <admst:text format="{\n"/>
  <admst:text format="  struct returnType\n"/>
  <admst:text format="  {\n"/>
  <admst:text format="     double value;\n"/>
  <admst:for-each select="variable[input='yes']">
    <admst:text format="     double deriv_WRT_%(name);\n"/>
  </admst:for-each>
  <admst:text format="  };\n"/>
  <admst:text format="public:\n"/>
  <admst:text format="  // constructor takes all same arguments as regular templated function,\n"/>
  <admst:text format="  // even though it doesn't USE the output args\n"/>
  <admst:text format="  $(function)Evaluator("/>
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$(function))]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) %(name)"/>
  </admst:join>
  <admst:text format=");\n"/>
  <admst:text format="  // function that returns the precomputed values.  This, too, takes\n"/>
  <admst:text format="  // all the same arguments as the regular function, though it ONLY\n"/>
  <admst:text format="  // uses the output arguments\n"/>
  <admst:text format="  %(verilog2CXXtype(.)) getValues("/>
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$(function))]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <admst:if test="[output='yes']">
      <admst:text format="&amp; "/>
    </admst:if>
    <admst:text format=" %(name)"/>
  </admst:join>
  <admst:text format=");\n"/>
  <admst:text format="  // function that returns the total derivative of the function and its\n"/>
  <admst:text format="  // output arguments with respect to some variable.  We pass in the\n"/>
  <admst:text format="  // normal arguments(none of which are used) and the derivatives of those\n"/>
  <admst:text format="  // arguments with respect to the desired variable.  We compute the\n"/>
  <admst:text format="  // derivatives using the chain rule and our precomputed derivatives\n"/>
  <admst:text format="  // with respect to input variables\n"/>
  <admst:text format="%(verilog2CXXtype(.)) getDerivs("/>
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <!-- irrespective of whether the argument is an output variable,
         we always pass by value.  We are NOT returning the function
         value and its output variable values, only the derivatives! -->
    <admst:text format="%(name) "/>
  </admst:join>
  <admst:text format=" , "/>
  <!-- now the derivatives of the args w.r.t. the desired variable -->
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <admst:if test="[output='yes']">
      <admst:text format="&amp; "/>
    </admst:if>
    <admst:text format="d_%(name)"/>
  </admst:join>
  <admst:text format=");\n"/>

  <admst:text format="private:\n"/>
  <admst:text format="  returnType $(function)Return_;\n"/>
  <admst:for-each select="variable[output='yes' and name != $(function)]">
    <admst:text format="  returnType %(name)Return_;\n"/>
  </admst:for-each>
  <!-- "evaluator_" is the actual function that evaluates the function,
       but all outputs are actually of returnType -->
  <admst:text format="  returnType evaluator_("/>
  <admst:join
      select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]"
      separator=", ">
    <admst:choose>
      <admst:when test="[output='yes']">
        <admst:text format="returnType &amp;"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="%(verilog2CXXtype(.))"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format=" %(name)"/>
  </admst:join>
  <admst:text format=");\n"/>
  <admst:text format="};\n"/>
</admst:template>

<!-- Top level template to dump out an analog function implementation
     These functions only return the TOTAL DERIVATIVE of the function
     with respect to some (general) variable,
     computed via the chain rule given the partial derivatives of its
     arguments with respect to that variable (passed in to it) -->
<admst:template match="xyceAnalogFunctions:Implementation">

  <admst:variable name="function" select="%(name)"/>
  <admst:variable name="globalAnalogFunction" path="."/>
  <admst:text format="// Derivative of Analog Function %(name)\n"/>
  <admst:text format="%(verilog2CXXtype(.)) d_%(name)("/>
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <!-- irrespective of whether the argument is an output variable,
         we always pass by value.  We are NOT returning the function
         value and its output variable values, only the derivatives! -->
    <admst:text format="%(name) "/>
  </admst:join>
  <admst:text format=" , "/>
  <!-- now the derivatives of the args w.r.t. the desired variable -->
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <admst:if test="[output='yes']">
      <admst:text format="&amp; "/>
    </admst:if>
    <admst:text format="d_%(name) "/>
  </admst:join>
  <admst:text format=")\n"/>
  <admst:text format="{\n"/>
  <admst:text format="// Function return variable and total deriv\n"/>
  <admst:text format="%(verilog2CXXtype(.)) %(name);\n"/>
  <admst:text format="%(verilog2CXXtype(.)) d_%(name);\n"/>
  <admst:text format="// Derivatives of return value w.r.t input vars\n"/>
  <!-- derivatives of the return value w.r.t. all input vars -->
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:text format="%(verilog2CXXtype($globalAnalogFunction)) d_%($function)_d_%(name)=0;\n"/>
  </admst:for-each>
  <admst:if test="[exists($globalAnalogFunction/variable[output='yes' and name!='$function'])]">
    <admst:text format="// Derivatives of additional output vars w.r.t input vars\n"/>
  </admst:if>
  <!-- derivatives of all output variables w.r.t. all input vars -->
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:variable name="wrt" select="%(name)"/>
    <admst:for-each select="$globalAnalogFunction/variable[output='yes' and name!='$function']">
      <admst:text format="%(verilog2CXXtype(.)) d_%(name)_d_$(wrt)=0;\n"/>
    </admst:for-each>
  </admst:for-each>
  <admst:for-each select="variable[input='no' and output='no']">
    <admst:variable name="theVar" path="."/>
    <admst:variable name="varname" select="%(name)"/>
    <admst:text format="%(verilog2CXXtype($theVar)) $varname;\n"/>
    <admst:if test="[$theVar/type='real']">
      <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
        <admst:text format="%(verilog2CXXtype($theVar)) d_$(varname)_d_%(name);\n"/>
      </admst:for-each>
    </admst:if>
  </admst:for-each>

  <admst:apply-templates select="tree" match="xyceAnalogFunctions:%(adms/datatypename)">
    <admst:value-of select="returned('returnedString')/value"/>
    <admst:variable name="returnedString" select="%s"/>
    <admst:text format="$returnedString"/>
  </admst:apply-templates>

  <admst:for-each select="$globalAnalogFunction/variable[output='yes']">
    <admst:variable name="outvar" value="%(name)"/>
    <admst:variable name="expression" value=""/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:variable name="wrt" value="%(name)"/>
      <admst:if test="[$expression != '']">
        <admst:variable name="expression" value="$expression+"/>
      </admst:if>
      <admst:variable name="expression" value="$(expression)d_$(outvar)_d_$(wrt)*d_$(wrt)"/>
    </admst:for-each>
    <admst:text format="d_$(outvar) = $expression;\n"/>
  </admst:for-each>
  <admst:text format="return(d_%(name));\n"/>
  <admst:text format="}\n\n"/>
  <admst:variable name="globalAnalogFunction"/>
</admst:template>

<!-- Generate implementations of functions declared in the function evaluator
     classes above
     TODO:  eliminate unnecessary arguments.  Didn't do that at first
     because it will simplify the problem of swapping these things into
     where the functions are used (they all take the same arguments that
     the old technique required).
     -->
<admst:template match="xyceAnalogFunctions:ClassImplementations">
  <admst:variable name="function" select="%(name)"/>
  <admst:variable name="globalAnalogFunction" path="."/>
  <admst:text format="// Evaluator class implementations for Analog Function %(name)\n"/>
  <admst:text format="  // Constructor\n"/>
  <admst:text format="  $(function)Evaluator::$(function)Evaluator("/>
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$(function))]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) %(name)"/>
  </admst:join>
  <admst:text format=")\n"/>
  <admst:text format="  {\n"/>

  <admst:text format="    %(name)Return_ = evaluator_("/>
  <admst:join
      select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]"
      separator=", ">
    <admst:choose>
      <admst:when test="[output='yes']">
        <admst:text format="%(name)Return_"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="%(name)"/>
      </admst:otherwise>
    </admst:choose>

  </admst:join>
  <admst:text format=");\n"/>
  <admst:text format="  }\n"/>

  <admst:text format="  // method to get precomputed values into double vars \n"/>
  <admst:text format="  %(verilog2CXXtype(.)) %(name)Evaluator::getValues("/>
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$(function))]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <admst:if test="[output='yes']">
      <admst:text format="&amp; "/>
    </admst:if>
    <admst:text format=" %(name)"/>
  </admst:join>
  <admst:text format=")\n"/>
  <admst:text format="  {\n"/>
  <admst:text format="    // Silence unused argument warnings\n"/>
  <admst:for-each select="variable[input='yes' and output='no']">
    <admst:text format="    (void) %(name);\n"/>
  </admst:for-each>
  <admst:text format="    // Copy all precomputed values into corresponding output\n"/>
  <admst:for-each select="variable[output='yes' and name!=$function]">
    <admst:text format="    %(name) = %(name)Return_.value;\n"/>
  </admst:for-each>
  <admst:text format="    return(%(name)Return_.value);\n"/>
  <admst:text format="  }\n"/>

  <admst:text format="  // method to get total deriv w.r.t some variable via chain rule \n"/>
  <admst:text format="  // given precomputed derivs of function w.r.t. args and derivs of args\n"/>
  <admst:text format="  // w.r.t desired vars\n"/>
  <admst:text format="  %(verilog2CXXtype(.)) %(name)Evaluator::getDerivs("/>
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <!-- irrespective of whether the argument is an output variable,
         we always pass by value.  We are NOT returning the function
         value and its output variable values, only the derivatives! -->
    <admst:text format="%(name) "/>
  </admst:join>
  <admst:text format=" , "/>
  <!-- now the derivatives of the args w.r.t. the desired variable -->
  <admst:join select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]" separator=", ">
    <admst:text format="%(verilog2CXXtype(.)) "/>
    <admst:if test="[output='yes']">
      <admst:text format="&amp; "/>
    </admst:if>
    <admst:text format="d_%(name)"/>
  </admst:join>
  <admst:text format=")\n"/>
  <admst:text format="  {\n"/>
  <admst:text format="    // Function total deriv\n"/>
  <admst:text format="    %(verilog2CXXtype(.)) d_%(name);\n"/>
  <admst:text format="    // Silence unused argument warnings\n"/>
  <admst:for-each select="variable[input='yes']">
    <admst:text format="    (void) %(name);\n"/>
  </admst:for-each>

  <admst:for-each select="$globalAnalogFunction/variable[output='yes']">
    <admst:variable name="outvar" value="%(name)"/>
    <admst:variable name="expression" value=""/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:variable name="wrt" value="%(name)"/>
      <admst:if test="[$expression != '']">
        <admst:variable name="expression" value="$expression+"/>
      </admst:if>
      <admst:variable name="expression" value="$(expression)$(outvar)Return_.deriv_WRT_$(wrt)*d_$(wrt)"/>
    </admst:for-each>
    <admst:text format="    d_$(outvar) = $expression;\n"/>
  </admst:for-each>
  <admst:text format="    return(d_%(name));\n"/>
  <admst:text format="  }\n"/>

  <admst:text format="  // method that actually performs our computations.\n"/>
  <admst:text format="  %(name)Evaluator::returnType %(name)Evaluator::evaluator_("/>
  <admst:join
      select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]"
      separator=", ">
    <admst:choose>
      <admst:when test="[output='yes']">
        <admst:text format="$(function)Evaluator::returnType &amp; %(name)Return"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="%(verilog2CXXtype(.)) %(name)"/>
      </admst:otherwise>
    </admst:choose>
  </admst:join>
  <admst:text format=")\n"/>
  <admst:text format="  {\n"/>
  <!-- This is almost the same as the contents of the d_(function) function,
       modulo the chain rule thing at the end, and the storage of derivatives
       in a returnType variable -->
  <admst:text format="  // Function value and derivs variables, and a returnType to store everything\n"/>
  <admst:text format="  %(verilog2CXXtype(.)) %(name);\n"/>
  <admst:text format="  %(name)Evaluator::returnType %(name)Return;\n"/>
  <admst:text format="  // Derivatives of return value w.r.t input vars\n"/>
  <!-- derivatives of the return value w.r.t. all input vars -->
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:text format="  %(verilog2CXXtype($globalAnalogFunction)) d_%($function)_d_%(name)=0;\n"/>
  </admst:for-each>
  <admst:if test="[exists($globalAnalogFunction/variable[output='yes' and name!='$function'])]">
    <admst:text format="  // additional output vars  and derivs w.r.t input vars\n"/>
  </admst:if>
  <!-- derivatives of all output variables w.r.t. all input vars -->
  <admst:for-each select="$globalAnalogFunction/variable[output='yes' and name!='$function']">
    <admst:variable name="ovar" select="%(name)"/>
    <admst:text format="  %(verilog2CXXtype(.)) $(ovar);\n"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:text format="  %(verilog2CXXtype(.)) d_$(ovar)_d_%(name)=0;\n"/>
    </admst:for-each>
  </admst:for-each>
  <!-- and now the remaining local variables -->
  <admst:text format="  // declared local variables\n"/>
  <admst:for-each select="variable[input='no' and output='no']">
    <admst:variable name="theVar" path="."/>
    <admst:variable name="varname" select="%(name)"/>
    <admst:text format="  %(verilog2CXXtype($theVar)) $varname;\n"/>
    <admst:if test="[$theVar/type='real']">
      <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
        <admst:text format="  %(verilog2CXXtype($theVar)) d_$(varname)_d_%(name)=0;\n"/>
      </admst:for-each>
    </admst:if>
  </admst:for-each>

  <!-- Generate the actual code -->
  <admst:apply-templates select="tree" match="xyceAnalogFunctions:%(adms/datatypename)">
    <admst:value-of select="returned('returnedString')/value"/>
    <admst:variable name="returnedString" select="%s"/>
    <admst:text format="$returnedString"/>
  </admst:apply-templates>

  <admst:text format="  // now save outputs and derivs into appropriate return vars\n"/>
  <admst:text format="  %(name)Return.value=%(name);\n"/>
  <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
    <admst:text format="  $(function)Return.deriv_WRT_%(name) = d_%($function)_d_%(name);\n"/>
  </admst:for-each>

  <admst:for-each select="$globalAnalogFunction/variable[output='yes' and name!='$function']">
    <admst:variable name="ovar" select="%(name)"/>
    <admst:text format="  $(ovar)Return.value = $(ovar);\n"/>
    <admst:for-each select="$globalAnalogFunction/variable[input='yes']">
      <admst:text format="  $(ovar)Return.deriv_WRT_%(name) = d_$(ovar)_d_%(name);\n"/>
    </admst:for-each>
  </admst:for-each>

  <admst:text format="  return(%(name)Return);\n"/>
  <admst:text format="  }\n\n"/>


</admst:template>
</admst>

<?escript name="/usr/local/stow/Xyce/7.8-adms/share/xml/xyceHeaderFile_nosac.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">


  <!--
      Purpose:       Generate the .h file for a Xyce implementation of a
                     verilog model.
      Special Notes: You must include "xyceBasicTemplates.xml" to use this
                     script
      Creator:       Tom Russo, SNL, Electrical and Microsystems Modeling
      Creation Date: 13 May 2008


     Copyright 2002-2023 National Technology & Engineering Solutions of
     Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
     NTESS, the U.S. Government retains certain rights in this software.

     This file is part of the Xyce(TM) Parallel Electrical Simulator.

     Xyce(TM) is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     Xyce(TM) is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Xyce(TM).
     If not, see <http://www.gnu.org/licenses/>.
  -->

<!-- this shouldn't really be needed, but makes sure this template can be
     used in any order, even with the non-sacado version of the basic
     templates, forcing it to fall back to the version that doesn't
     try to insert precomputed function variables -->
<admst:variable name="skipFunctionPrecomp" select="y"/>
<!-- C++98 hates initializers on non-const variables in class declarations -->
<admst:variable name="initializeOnDeclare" select="no"/>

<admst:for-each select="/module">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:if test="variable[insource='yes' and derivate='yes']">
    <admst:variable name="doSecondDerivatives" select="yes"/>
  </admst:if>
  <!-- Set up some useful variables: the N_DEV_(foo) class, and its
       related Instance and Model classes -->
  <admst:apply-templates select="." match="xyceClassBaseName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="classname" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceDeviceNamespace">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="nameSpace" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceModelClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="modelName" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceInstanceClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="instanceName" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="collectLimiters"/>
  <admst:apply-templates select="." match="collectCollapsibles"/>
  <admst:apply-templates select="." match="collectExtraUnknowns"/>

  <admst:open file="$classname.h">
// -*-c++-*-
//-------------------------------------------------------------------------
//   Copyright 2002-2023 National Technology &amp; Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see &lt;http://www.gnu.org/licenses/&gt;.
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file %(/filename) with ADMS
//                  interface for %(/simulator/package_string)
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : %(/simulator/fullname)
//
// Creation Date  : %(/simulator/currentdate)
//
//-----------------------------------------------------------------------------

  <admst:apply-templates select="." match="xyceGuardSymbol">
    <admst:value-of select="returned('symbolname')/value"/>
    <admst:variable name="guardSymbol" select="%s"/>
  </admst:apply-templates>
  <admst:text format="#ifndef $guardSymbol\n#define $guardSymbol\n"/>

#include &lt;N_DEV_Configuration.h&gt;
#include &lt;N_DEV_Const.h&gt;
#include &lt;N_DEV_DeviceBlock.h&gt;
#include &lt;N_DEV_DeviceInstance.h&gt;
#include &lt;N_DEV_DeviceModel.h&gt;

<admst:apply-templates select="." match="xyceIncludeModelBaseHeader"/>

// Xyce_config.h contains a VERSION macro from autoconf, and some
// Verilog-A models like to define a variable of that name.  This can be
// a serious problem, and we don't need the VERSION macro.  Get rid of it.
// This must happen *after* all the includes of Xyce headers, each of which
// includes Xyce_config.h.  The implementation file must do this all again
// because it includes more Xyce headers *after* including this one.
#ifdef VERSION
#undef VERSION
#endif

namespace Xyce {
namespace Device {
namespace <admst:text format="%($nameSpace)"/> {

class Model;
class Instance;
class InstanceSensitivity;

#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------

  <admst:text format="// Class         : InstanceSensitivity"/>
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

<admst:text format="class InstanceSensitivity : public baseSensitivity"/>
{
public:
InstanceSensitivity() :
baseSensitivity() {};

virtual ~InstanceSensitivity() {};

virtual void operator()(
const ParameterBase &amp;entity,
const std::string &amp;param,
std::vector&lt;double&gt; &amp; dfdp,
std::vector&lt;double&gt; &amp; dqdp,
std::vector&lt;double&gt; &amp; dbdp,
std::vector&lt;int&gt; &amp; Findices,
std::vector&lt;int&gt; &amp; Qindices,
std::vector&lt;int&gt; &amp; Bindices
) const ;
};

static InstanceSensitivity instSens;


//-----------------------------------------------------------------------------

  <admst:text format="// Class         : ModelSensitivity"/>
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

<admst:text format="class ModelSensitivity : public baseSensitivity"/>
{
public:
ModelSensitivity() :
baseSensitivity() {};

virtual ~ModelSensitivity() {};

virtual void operator()(
const ParameterBase &amp;entity,
const std::string &amp;param,
std::vector&lt;double&gt; &amp; dfdp,
std::vector&lt;double&gt; &amp; dqdp,
std::vector&lt;double&gt; &amp; dbdp,
std::vector&lt;int&gt; &amp; Findices,
std::vector&lt;int&gt; &amp; Qindices,
std::vector&lt;int&gt; &amp; Bindices
) const ;
};

static ModelSensitivity modSens;
#endif // Xyce_ADMS_SENSITIVITIES

// general purpose free functions
// thermal voltage at kelvin temperature temp)
static inline double adms_vt(const double temp) {return(CONSTKoverQ*temp);};


#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// "structs" to hold instance and model param/variable copies
//-----------------------------------------------------------------------------

<admst:apply-templates select="." match="generateInstanceStruct"/>

<admst:apply-templates select="." match="generateModelStruct"/>

//-----------------------------------------------------------------------------
// Free functions used by sensitivity
//
//-----------------------------------------------------------------------------

<admst:text format="void evaluateModelEquations(\n"/>
<admst:variable name="globalDeclareVars" select="yes"/>
<admst:apply-templates select="." match="generateEvaluateModelEquationsArgs"/>
<admst:text format=");\n\n"/>

<admst:text format="void evaluateInitialInstance(\n"/>
<admst:text format="instanceSensStruct &amp; instanceStruct,\n"/>
<admst:text format="modelSensStruct &amp; modelStruct,\n"/>
<admst:if test="[exists(@optnodes)]">
  <admst:join select="node[grounded='no']" separator=",\n">
    <admst:text format="const int "/>
    <admst:text format="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
  </admst:join>
  <admst:text format=",\n const std::vector&lt;bool&gt; &amp; portsConnected_,\n"/>
</admst:if>
<admst:text format=" double admsTemperature,double adms_vt_nom, double ADMSgmin_arg, const Instance &amp; theInstance);\n\n"/>

<admst:text format="void evaluateInitialModel(\n"/>
<admst:text format="modelSensStruct &amp; modelStruct,\n"/>
<admst:text format=" double admsTemperature, double ADMSgmin_arg, const Instance &amp; theInstance);\n"/>
#endif // Xyce_ADMS_SENSITIVITIES


// Limited exponential --- NOT what verilog LRM says, but what qucs,
// ng-spice, and zspice do.

template &lt;typename T&gt;
T limexp(const T &amp;x)
{
  if ((x) &lt; 80.0)
  return (exp(x));
  else
  return (exp(80.0)*(x-79.0));
}


  <admst:apply-templates select="." match="xyceDeclareTraits"/>

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="instance"/>

//-----------------------------------------------------------------------------

  <admst:text format="// Class         : Instance\n"/>
//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

  <admst:text format="class Instance : public DeviceInstance"/>
{
  friend class ParametricData&lt;Instance&gt;;
  friend class Model;
#ifdef Xyce_ADMS_SENSITIVITIES
  friend class InstanceSensitivity;
  friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
  friend struct Traits;

  public:
    Instance(
      const Configuration &amp;       configuration,
      const InstanceBlock &amp;       instance_block,
      Model &amp;                     model,
      const FactoryBlock &amp;        factory_block);

    ~Instance();

private:
    Instance(const Instance &amp;);
    Instance &amp;operator=(const Instance &amp;);

public:
    void registerLIDs( const LocalIdVector &amp; intLIDVecRef,
                       const LocalIdVector &amp; extLIDVecRef );
    void registerStoreLIDs( const LocalIdVector &amp; stoLIDVecRef );
    void setupPointers();

    void loadNodeSymbols(Util::SymbolTable &amp;symbol_table) const;

    const JacobianStamp &amp; jacobianStamp() const;
    void registerJacLIDs( const JacobianStamp &amp; jacLIDVec );

    void registerBranchDataLIDs(const std::vector&lt;int&gt; &amp; branchLIDVecRef);

    bool processParams();
    bool updateTemperature ( const double &amp; temp = -999.0 );
    bool updateIntermediateVars ();
    bool updatePrimaryState ();
    bool updateSecondaryState ();

    // load functions, residual:
    bool loadDAEQVector ();
    bool loadDAEFVector ();

    // load functions, Jacobian:
    bool loadDAEdQdx ();
    bool loadDAEdFdx ();

    <admst:if test="[count(callfunction[function/name='\$bound_step'])>0]">
      <admst:text format="double  getMaxTimeStepSize();\n"/>
      <admst:text format="virtual bool  maxTimeStepSupported() {return true;};\n"/>
    </admst:if>

    <admst:if test="[count(node[#collapsible='yes'])>0]">
      void collapseNodes();
    </admst:if>

    <admst:if test="[count(/module/contribution[whitenoise='yes' or flickernoise='yes'])>0]">
      int getNumNoiseSources () const;  // %(count(/module/contribution[whitenoise='yes' or flickernoise='yes']))
      void setupNoiseSources (Xyce::Analysis::NoiseData &amp; noiseData);
      void getNoiseSources (Xyce::Analysis::NoiseData &amp; noiseData);
    </admst:if>

  private:

  public:
    // iterator reference to the %(name) model which owns this instance.
    // Getters and setters
    Model &amp;getModel()
    {
      return model_;
    }

  private:

    Model &amp; model_;   //&lt; Owning Model

    <admst:apply-templates select="." match="xyceDeclareInstanceVariables"/>
    <admst:apply-templates select="." match="xyceDeclareNodeLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareBranchLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareLeadBranchLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareJacobianOffsets"/>
    <admst:apply-templates select="." match="xyceDeclareNodeConstants"/>
    <admst:apply-templates select="." match="xyceDeclareBranchConstants"/>
    <admst:apply-templates select="." match="xyceDeclareProbeConstants"/>
    <admst:apply-templates select="." match="xyceDeclareLimitedProbeStoreLIDs"/>
    <admst:apply-templates select="." match="xyceDeclareOutputStoreLIDs"/>
    <admst:apply-templates select="." match="declareCollapsibleBools"/>
    <admst:apply-templates select="." match="xyceDeclareFadArrays"/>

    <admst:if test="[count(contribution/[whitenoise='yes' or flickernoise='yes'])>0]">
      <admst:text format="//vectors to hold noise information for communication between methods\n"/>
      <admst:text format="std::vector&lt;double&gt; noiseContribsPower;\n"/>
      <admst:text format="std::vector&lt;double&gt; noiseContribsExponent;\n"/>
    </admst:if>

    <admst:if test="[count(@limitedProbes)>0]">
    // This array stores the differences between original and limited variables.
    std::vector&lt;double&gt; probeDiffs;
    // These store the Jdxp's for F and Q, respectively
    std::vector&lt;double&gt; Jdxp_static;
    std::vector&lt;double&gt; Jdxp_dynamic;
    </admst:if>

    <admst:if test="[count(callfunction[function/name='\$bound_step'])>0]">
      <admst:text format="double  maxTimeStep_;\n"/>
    </admst:if>

    // this is what we'll use when any model uses \$temperature.  We'll
    // set it in updateTemperature, and initialize it to whatever
    // is in devOptions when the instance is constructed.
    double admsTemperature;

    // vt at \$temperature;
    double adms_vt_nom;


    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" parameter to use
    double admsInstTemp;


    <admst:choose>
      <admst:when test="[count(node[#collapsible='yes'])=0]">
    static JacobianStamp jacStamp;
    static IdVector nodeMap;
    static PairMap pairToJacStampMap;
      </admst:when>
      <admst:otherwise>
    JacobianStamp jacStamp;
    IdVector nodeMap;
    PairMap pairToJacStampMap;
      </admst:otherwise>
    </admst:choose>

    // These instance-owned vectors are for storage of lead current data
    std::vector&lt;double&gt; leadCurrentF;
    std::vector&lt;double&gt; leadCurrentQ;

    <admst:if test="[exists(@optnodes)]">
      std::vector&lt;bool&gt; portsConnected_;
    </admst:if>

    };


<admst:if test="[exists(analogfunction)]">
  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="AF"/>

namespace AnalogFunctions
{
    <admst:variable name="globalMustUseTemplate" select="no"/>
    <admst:variable name="globalMustForceScalar" select="no"/>
    <admst:for-each select="analogfunction">

      // Analog Function %(name)

      <admst:variable name="skipFunctionPrecomp" select="y"/>
      <admst:apply-templates select="." match="xyceAnalogFunctionDeclaration"/>
      <admst:apply-templates select="." match="xyceAnalogFunctions:Declaration"/>
      <admst:apply-templates select="." match="xyceAnalogFunctions:ClassDeclaration"/>
    </admst:for-each>
}


</admst:if>

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="model"/>
//-----------------------------------------------------------------------------

    <admst:text format="// Class         : Model\n"/>
// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

    <admst:text format="class Model : public DeviceModel"/>
{
    typedef std::vector&lt;Instance *&gt; InstanceVector;

    friend class ParametricData&lt;Model&gt;;
    friend class Instance;
#ifdef Xyce_ADMS_SENSITIVITIES
    friend class InstanceSensitivity;
    friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
    friend struct Traits;

  public:
    Model(
      const Configuration &amp;       configuration,
      const ModelBlock &amp;          model_block,
      const FactoryBlock &amp;        factory_block);

    ~Model();

private:
    Model(const Model &amp;);
    Model &amp;operator=(const Model &amp;);

public:
    virtual void forEachInstance(DeviceInstanceOp &amp;op) const /* override */;
    virtual std::ostream &amp;printOutInstances(std::ostream &amp;os) const;
    bool processParams();
    bool processInstanceParams();

  private:

  public:
    void addInstance(Instance *instance)
    {
      instanceContainer.push_back(instance);
    }

    void setupBaseInstanceContainer()
    {
      std::vector&lt;Instance*&gt;::iterator iter = instanceContainer.begin();
      std::vector&lt;Instance*&gt;::iterator end   = instanceContainer.end();
      for ( ; iter!=end; ++iter)
      {
      Xyce::Device::DeviceModel::baseInstanceContainer.push_back( static_cast&lt;Xyce::Device::DeviceInstance *&gt;(*iter) );
    }
  }

  private:
    std::vector&lt;Instance*&gt; instanceContainer;

  private:

    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" model parameter to use
    double admsModTemp;

    <admst:apply-templates select="." match="xyceDeclareModelVariables"/>
};

void registerDevice(const DeviceCountMap&amp; deviceMap = DeviceCountMap(),
                    const std::set&lt;int&gt;&amp; levelSet = std::set&lt;int&gt;());


<admst:text format="} // namespace %($nameSpace)"/>
} // namespace Device
} // namespace Xyce

<admst:text format="#endif //$guardSymbol\n"/>
  </admst:open>


</admst:for-each>
<!-- now set this back so that this template file can be used in any order -->
<admst:variable name="initializeOnDeclare" select="yes"/>
</admst>

<?escript name="/usr/local/stow/Xyce/7.8-adms/share/xml/xyceImplementationFile_nosac.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst SYSTEM "/users/tvrusso/src/QucsADMS/ADMS/admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

  <!--
      Purpose:       Generate the .C file for a Xyce implementation of a
                     verilog model.
      Special Notes: You must include "xyceBasicTemplates.xml" to use this
                     script
      Creator:       Tom Russo, SNL, Electrical and Microsystems Modeling
      Creation Date: 13 May 2008


     Copyright 2002-2023 National Technology &amp; Engineering Solutions of
     Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
     NTESS, the U.S. Government retains certain rights in this software.

     This file is part of the Xyce(TM) Parallel Electrical Simulator.

     Xyce(TM) is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     Xyce(TM) is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Xyce(TM).
     If not, see <http://www.gnu.org/licenses/>.
  -->

<admst:for-each select="/module">

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="instance"/>

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out whether to
       force a template instantiation of a function
     -->
  <admst:variable name="globalMustUseTemplate" select="no"/>

  <!-- this GLOBAL VARIABLE (ugh!) used by the assignment template to flag
       to lower-level templates that it should force ".val()" onto
       Fad variables -->
  <admst:variable name="globalMustForceScalar" select="no"/>

  <!-- save the module so we can reference it later -->
  <admst:variable name="theModule" select="%(.)"/>


  <admst:variable name="skipFunctionPrecomp" select="y"/>

  <!-- Set up some useful variables: the N_DEV_(foo) class, and its
     related Instance and Model classes -->
  <admst:apply-templates select="." match="xyceClassBaseName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="classname" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceDeviceNamespace">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="nameSpace" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceModelClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="modelName" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceInstanceClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="instanceName" select="%s"/>
  </admst:apply-templates>

  <admst:variable name="numNodes" select="%(count(node[grounded='no']))"/>

  <!-- check for correctness of collapse constructions -->
  <admst:apply-templates   select="analog/code/item" match="recursiveFindContrib"/>
  <admst:if test="[$collapseFailure = 'yes']">
    <admst:fatal format="Aborting due to collapse-related errors.\n"/>
  </admst:if>

  <!-- First collect any voltage limiting information: -->
  <admst:apply-templates select="." match="collectLimiters"/>
  <!-- Now handle collapsible nodes -->
  <admst:apply-templates select="." match="collectCollapsibles"/>
  <!-- Now identify parameters that have defaults depending on others  -->
  <admst:apply-templates select="." match="collectInterdependentParams"/>

  <!-- label any noise contributions for later use -->
  <admst:apply-templates select="." match="xyceLabelNoiseContributions"/>

  <!-- Now identify branch equations needed: -->
  <admst:apply-templates select="." match="collectExtraUnknowns"/>
  <admst:variable name="numSolVars" select="$numNodes+%(count(/module/@extraUnknowns))"/>

  <!-- Now go through the special blocks and identify which variables they -->
  <!-- assign into                                                         -->
  <admst:for-each select="analog/code/item">
    <admst:if test="adms[datatypename='block']/..[name='initial_instance' or name='initial_model']">
      <admst:apply-templates select="." match="collectAssignedVariables"/>
      <admst:message format="Block %(name) assigns to %(count(@assignedVars)) variables.\n"/>
    </admst:if>
  </admst:for-each>

  <!-- the previous operation dumped all the variables set by those special -->
  <!-- blocks into the @assignedVars array of the analog/code block, which  -->
  <!-- we now need to clear out:                                            -->
  <admst:reset select="analog/code/@assignedVars"/>

  <!-- Now let's collect into analog/code/@assignedVars only those          -->
  <!-- variables that are assigned to in code EXCLUDING the special blocks  -->
  <admst:for-each select="analog/code/item">
    <!-- if a block and not special -->
    <admst:if test="adms[datatypename='block']/..[name!='initial_instance' and name!='initial_model' and name != 'initial_step']">
      <admst:apply-templates select="." match="collectAssignedVariables"/>
    </admst:if>
    <!-- if not a block -->
    <admst:if test="adms[datatypename!='block']">
      <admst:apply-templates select="." match="collectAssignedVariables"/>
    </admst:if>
  </admst:for-each>
  <admst:message format="Top-level analog/code assigns to %(count(analog/code/@assignedVars)) variables.\n"/>
  <admst:if test="variable[insource='yes' and exists(derivate) and derivate='yes']">
    <admst:variable name="doSecondDerivatives" select="yes"/>
  </admst:if>
  <admst:if test="[exists(@optnodes)]">
    <admst:message format="Module has %(count(@optnodes)) optional nodes:\n"/>
    <admst:for-each select="@optnodes">
      <admst:message format="   %(name)\n"/>
    </admst:for-each>
  </admst:if>
  <!-- The output proper -->
  <admst:open file="$classname.C">
//-------------------------------------------------------------------------
//   Copyright 2002-2023 National Technology &amp; Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see &lt;http://www.gnu.org/licenses/&gt;.
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file %(/filename) with ADMS
//                  interface for %(/simulator/package_string)
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : %(/simulator/fullname)
//
// Creation Date  : %(/simulator/currentdate)
//
//-------------------------------------------------------------------------
// Shut up clang&apos;s warnings about extraneous parentheses
#ifdef __clang__
#  pragma clang diagnostic ignored &quot;-Wparentheses-equality&quot;
#endif

#include &lt;Xyce_config.h&gt;

<admst:text format="#include &lt;%($classname).h&gt;\n"/>

#include &lt;N_DEV_Const.h&gt;
#include &lt;N_DEV_DeviceOptions.h&gt;
#include &lt;N_DEV_DeviceMaster.h&gt;
#include &lt;N_DEV_ExternData.h&gt;
#include &lt;N_DEV_SolverState.h&gt;
#include &lt;N_DEV_Message.h&gt;

#include &lt;N_LAS_Matrix.h&gt;
#include &lt;N_LAS_Vector.h&gt;

<admst:if test="[count(contribution[whitenoise='yes' or flickernoise='yes'])>0]">
  #include &lt;N_ANP_NoiseData.h&gt;
</admst:if>

#include &lt;N_UTL_FeatureTest.h&gt;
#include &lt;unordered_map&gt;
using std::unordered_map;

#include &lt;algorithm&gt;

// Xyce_config.h contains a VERSION macro from autoconf, and some
// Verilog-A models like to define a variable of that name.  This can be
// a serious problem, and we don't need the VERSION macro.  Get rid of it.
// This must happen *after* all includes of Xyce headers, each of which
// includes Xyce_config.h!
#ifdef VERSION
#undef VERSION
#endif

namespace Xyce {
namespace Device {
namespace %($nameSpace) {

<admst:if test="[exists(analogfunction)]">
<admst:text format="namespace AnalogFunctions {\n"/>
    <admst:for-each select="analogfunction">
      <admst:variable name="globalCurrentScope" select="AF"/>
      <admst:apply-templates select="." match="xyceAnalogFunctionDefinition"/>
      <admst:variable name="globalCurrentScope" select="instance"/>
      <admst:apply-templates select="." match="xyceAnalogFunctions:Implementation"/>
      <admst:apply-templates select="." match="xyceAnalogFunctions:ClassImplementations"/>
    </admst:for-each>
<admst:text format="} // namepace AnalogFunctions\n"/>
</admst:if>

<admst:if test="[count(node[#collapsible='yes'])=0]">
<admst:text format="JacobianStamp Instance::jacStamp;\n"/>

<admst:text format="IdVector Instance::nodeMap;\n"/>
<admst:text format="PairMap Instance::pairToJacStampMap;\n"/>
</admst:if>

//This is necessary because the IntPair usage can trip undefined references

<admst:for-each select="node[grounded='no']">
  <admst:text format="    const int Instance::%(xyceNodeConstantName(.)/[name='nodeConstant']/value);\n"/>
</admst:for-each>
<admst:text format="     const int Instance::admsNodeID_GND;\n"/>
<admst:text format="   // Additional IDs for branch equations\n"/>
<admst:for-each select="/module/@extraUnknowns">
  <admst:text format="    const int Instance::%(xyceBranchConstantName(.)/[name='branchConstant']/value);\n"/>
</admst:for-each>

void
Traits::loadInstanceParameters(ParametricData&lt;%($nameSpace)::Instance&gt; &amp;p)
{
  // Set up each parameter directly, using the up-cased variable name
  // as the tag.

  // This kludge is to force us always to have an instance parameter
  // that the device manager can set to the temperature, even if we have
  // no "TEMP".
  p.addPar(&quot;XYCEADMSINSTTEMP&quot;, 0.0, &amp;%($nameSpace)::Instance::admsInstTemp)
    .setExpressionAccess(NO_DOC)
    .setUnit(U_DEGK)
    .setCategory(CAT_TEMP)
    .setDescription(&quot;Internal-use parameter for setting device instance temperature&quot;);

    <admst:for-each select="variable[parametertype='instance' and input='yes']">
      <admst:text format="  p.addPar(&quot;%(upper-case(name))&quot;, "/>
      <admst:choose>
        <admst:when test="[exists(default) and not exists(#dependent)]">
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="static_cast&lt;double&gt;(%(printTerm(default)))"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="static_cast&lt;int&gt;(%(printTerm(default)))"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="%(printTerm(default))"/>
            </admst:when>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="0.0"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="0"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="&quot;&quot;"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:text format=", &amp;%($nameSpace)::Instance::%(name))"/>
      <admst:if test="[exists(attribute[name='dependence'])]">
          <admst:text format="\n    .setExpressionAccess(ParameterType::%(attribute[name='dependence']/value))"/>
      </admst:if>

      <admst:if test="[exists(attribute[name='xyceUnit'])]">
          <admst:text format="\n    .setUnit(%(attribute[name='xyceUnit']/value))"/>
      </admst:if>
      <admst:if test="[exists(attribute[name='units']) and not exists(attribute[name='xyceUnit'])]">
          <admst:text format="\n    .setUnit(%(textUnit2XyceUnit(.)))"/>
      </admst:if>
      <admst:if test="[exists(attribute[name='xyceCategory'])]">
          <admst:text format="\n    .setCategory(%(attribute[name='xyceCategory']/value))"/>
      </admst:if>
      <admst:choose>
        <admst:when test="[exists(attribute[name='info'])]">
          <admst:text format="\n    .setDescription(&quot;%(attribute[name='info']/value)&quot;)"/>
        </admst:when>
        <admst:when test="[exists(attribute[name='desc'])]">
          <admst:text format="\n    .setDescription(&quot;%(attribute[name='desc']/value)&quot;)"/>
        </admst:when>
      </admst:choose>
      <admst:if test="[upper-case(name)='TEMP' or upper-case(name)='TNOM']">
        <admst:text format="\n   .setAutoConvertTemperature(false)"/>
      </admst:if>
      <admst:if test="[type='real']">
        <admst:text format="\n#ifdef Xyce_ADMS_SENSITIVITIES"/>
        <admst:text format="\n    .setAnalyticSensitivityAvailable(true)"/>
        <admst:text format="\n    .setSensitivityFunctor(&amp;instSens)"/>
        <admst:text format="\n#endif // Xyce_ADMS_SENSITIVITIES\n"/>
      </admst:if>
      <admst:text format=";\n"/>


      <!-- Ick.  Have to duplicate all that for each alias!-->
      <admst:if test="[not(nilled(alias))]">
        <admst:variable name="theParam" select="%(.)"/>
        <admst:for-each select="alias">
          <admst:text format="  p.addPar(&quot;%(upper-case(.))&quot;, "/>
          <admst:choose>
            <admst:when test="[exists($theParam/default) and not exists($theParam/#dependent)]">
              <admst:choose>
                <admst:when test="[$theParam/type='real']">
                  <admst:text format="static_cast&lt;double&gt;(%(printTerm($theParam/default)))"/>
                </admst:when>
                <admst:when test="[$theParam/type='integer']">
                  <admst:text format="static_cast&lt;int&gt;(%(printTerm($theParam/default)))"/>
                </admst:when>
                <admst:when test="[$theParam/type='string']">
                  <admst:text format="%(printTerm($theParam/default))"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:choose>
                <admst:when test="[$theParam/type='real']">
                  <admst:text format="0.0"/>
                </admst:when>
                <admst:when test="[$theParam/type='integer']">
                  <admst:text format="0"/>
                </admst:when>
                <admst:when test="[$theParam/type='string']">
                  <admst:text format="&quot;&quot;"/>
                </admst:when>
              </admst:choose>
            </admst:otherwise>
          </admst:choose>
          <admst:text format=", &amp;%($nameSpace)::Instance::%($theParam/name))"/>
          <admst:if test="[exists($theParam/attribute[name='dependence'])]">
            <admst:text format="\n    .setExpressionAccess(ParameterType::%($theParam/attribute[name='dependence']/value))"/>
          </admst:if>

          <admst:if test="[exists($theParam/attribute[name='xyceUnit'])]">
            <admst:text format="\n    .setUnit(%($theParam/attribute[name='xyceUnit']/value))"/>
          </admst:if>
          <admst:if test="[exists($theParam/attribute[name='units'])  and not exists($theParam/attribute[name='xyceUnit'])]">
            <admst:text format="\n    .setUnit(%(textUnit2XyceUnit($theParam)))"/>
          </admst:if>
          <admst:if test="[exists($theParam/attribute[name='xyceCategory'])]">
            <admst:text format="\n    .setCategory(%($theParam/attribute[name='xyceCategory']/value))"/>
          </admst:if>
          <admst:text format="\n    .setDescription(&quot; Alias for %($theParam/name)&quot;)"/>
          <admst:if test="[$theParam/type='real']">
            <admst:text format="\n#ifdef Xyce_ADMS_SENSITIVITIES"/>
            <admst:text format="\n    .setAnalyticSensitivityAvailable(true)"/>
            <admst:text format="\n    .setSensitivityFunctor(&amp;instSens)"/>
            <admst:text format="\n#endif // Xyce_ADMS_SENSITIVITIES\n"/>
          </admst:if>
          <admst:text format=";\n"/>
        </admst:for-each>
      </admst:if>
    </admst:for-each>

}

void Traits::loadModelParameters(ParametricData&lt;%($nameSpace)::Model&gt; &amp;p)
{
  // Set up each parameter directly, using the up-cased variable name
  // as the tag.

  // This kludge is to force us always to have a model parameter
  // that the device manager can set to the temperature, even if we have
  // no "TEMP".
  p.addPar("XYCEADMSMODTEMP", 0.0, &amp;%($nameSpace)::Model::admsModTemp)
    .setExpressionAccess(NO_DOC)
    .setUnit(U_DEGK)
    .setCategory(CAT_TEMP)
    .setDescription("Internal-use parameter for setting device model temperature");

    <admst:for-each select="variable[(parametertype='model' and input='yes') or (parametertype='instance' and input='yes' and exists(attribute[name='xyceAlsoModel']))]">
      <admst:choose>
        <admst:when test="[exists(attribute[name='hidden']) and attribute[name='hidden']/value='yes']">
          <admst:text format="//Hidden parameter %(name)\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="  p.addPar(&quot;%(upper-case(name))&quot;, "/>
          <admst:choose>
            <admst:when test="[exists(default) and not exists(#dependent)]">
              <admst:choose>
                <admst:when test="[type='real']">
                  <admst:text format="static_cast&lt;double&gt;(%(printTerm(default)))"/>
                </admst:when>
                <admst:when test="[type='integer']">
                  <admst:text format="static_cast&lt;int&gt;(%(printTerm(default)))"/>
                </admst:when>
                <admst:when test="[type='string']">
                  <admst:text format="%(printTerm(default))"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:choose>
                <admst:when test="[type='real']">
                  <admst:text format="0.0"/>
                </admst:when>
                <admst:when test="[type='integer']">
                  <admst:text format="0"/>
                </admst:when>
                <admst:when test="[type='string']">
                  <admst:text format="&quot;&quot;"/>
                </admst:when>
              </admst:choose>
            </admst:otherwise>
          </admst:choose>
          <admst:text format=", &amp;%($nameSpace)::Model::%(name))"/>

          <admst:if test="[exists(attribute[name='dependence'])]">
              <admst:text format="\n    .setExpressionAccess(ParameterType::%(attribute[name='dependence']/value))"/>
          </admst:if>
          <admst:if test="[exists(attribute[name='xyceUnit'])]">
              <admst:text format="\n    .setUnit(%(attribute[name='xyceUnit']/value))"/>
          </admst:if>
          <admst:if test="[exists(attribute[name='units']) and not exists(attribute[name='xyceUnit'])]">
            <admst:text format="\n    .setUnit(%(textUnit2XyceUnit(.)))"/>
          </admst:if>
          <admst:if test="[exists(attribute[name='xyceCategory'])]">
              <admst:text format="\n    .setCategory(%(attribute[name='xyceCategory']/value))"/>
          </admst:if>
          <admst:choose>
            <admst:when test="[exists(attribute[name='info'])]">
              <admst:text format="\n    .setDescription(&quot;%(attribute[name='info']/value)&quot;)"/>
            </admst:when>
            <admst:when test="[exists(attribute[name='desc'])]">
              <admst:text format="\n    .setDescription(&quot;%(attribute[name='desc']/value)&quot;)"/>
            </admst:when>
          </admst:choose>
          <admst:if test="[upper-case(name)='TEMP' or upper-case(name)='TNOM']">
            <admst:text format="\n   .setAutoConvertTemperature(false)"/>
          </admst:if>
          <admst:if test="[type='real']">
            <admst:text format="\n#ifdef Xyce_ADMS_SENSITIVITIES"/>
            <admst:text format="\n    .setAnalyticSensitivityAvailable(true)"/>
            <admst:text format="\n    .setSensitivityFunctor(&amp;modSens)"/>
            <admst:text format="\n#endif // Xyce_ADMS_SENSITIVITIES\n"/>
          </admst:if>
          <admst:text format=";\n"/>
        </admst:otherwise>
      </admst:choose>

      <!-- Ick.  Have to duplicate for aliases -->
      <admst:if test="[not(nilled(alias))]">
        <admst:variable name="theParam" select="%(.)"/>
        <admst:for-each select="alias">
          <admst:text format="  p.addPar(&quot;%(upper-case(.))&quot;, "/>
          <admst:choose>
            <admst:when test="[exists($theParam/default) and not exists($theParam/#dependent)]">
              <admst:choose>
                <admst:when test="[$theParam/type='real']">
                  <admst:text format="static_cast&lt;double&gt;(%(printTerm($theParam/default)))"/>
                </admst:when>
                <admst:when test="[type='integer']">
                  <admst:text format="static_cast&lt;int&gt;(%(printTerm($theParam/default)))"/>
                </admst:when>
                <admst:when test="[$theParam/type='string']">
                  <admst:text format="%(printTerm($theParam/default))"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:choose>
                <admst:when test="[$theParam/type='real']">
                  <admst:text format="0.0"/>
                </admst:when>
                <admst:when test="[$theParam/type='integer']">
                  <admst:text format="0"/>
                </admst:when>
                <admst:when test="[$theParam/type='string']">
                  <admst:text format="&quot;&quot;"/>
                </admst:when>
              </admst:choose>
            </admst:otherwise>
          </admst:choose>
          <admst:text format=", &amp;%($nameSpace)::Model::%($theParam/name))"/>

          <admst:if test="[exists($theParam/attribute[name='dependence'])]">
              <admst:text format="\n    .setExpressionAccess(ParameterType::%($theParam/attribute[name='dependence']/value))"/>
          </admst:if>
          <admst:if test="[exists($theParam/attribute[name='xyceUnit'])]">
              <admst:text format="\n    .setUnit(%($theParam/attribute[name='xyceUnit']/value))"/>
          </admst:if>
          <admst:if test="[exists($theParam/attribute[name='units']) and not exists($theParam/attribute[name='xyceUnit'])]">
            <admst:text format="\n    .setUnit(%(textUnit2XyceUnit($theParam)))"/>
          </admst:if>
          <admst:if test="[exists($theParam/attribute[name='xyceCategory'])]">
              <admst:text format="\n    .setCategory(%($theParam/attribute[name='xyceCategory']/value))"/>
          </admst:if>
          <admst:text format="\n    .setDescription(&quot; Alias for %($theParam/name)&quot;)"/>
          <admst:if test="[$theParam/type='real']">
            <admst:text format="\n#ifdef Xyce_ADMS_SENSITIVITIES"/>
            <admst:text format="\n    .setAnalyticSensitivityAvailable(true)"/>
            <admst:text format="\n    .setSensitivityFunctor(&amp;modSens)"/>
            <admst:text format="\n#endif // Xyce_ADMS_SENSITIVITIES\n"/>
          </admst:if>
          <admst:text format=";\n"/>
        </admst:for-each>
      </admst:if>
    </admst:for-each>
}

<admst:variable name="skipFunctionPrecomp" select="n"/>
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::processParams()
{
  // set any non-constant parameter defaults

  // copy any model variables that have associated instance variables, but
  // are only given in the model card:

  <admst:apply-templates select="$theModule" match="xyceCopyModelVars"/>


  // Set any parameters that were not given and whose defaults depend on other
  // parameters:

  <admst:for-each select="variable[parametertype='instance' and input='yes']">
    <admst:if test="[exists(default) and exists(#dependent)]">
      <admst:text format="  if (!given(&quot;%(name)&quot;))\n  {\n"/>
      <admst:text format="  %(name) = %(printTerm(default));\n  }\n"/>
    </admst:if>
  </admst:for-each>

// Now we need to check that any parameters are within their ranges as
  // specified in the verilog:

  <admst:for-each select="variable[parametertype='instance' and input='yes' and not(nilled(range))]">
//    Parameter %(name) : %(formatted_range(.))

    <admst:apply-templates select="." match="check_range"/>
  </admst:for-each>

  // this seems a little stupid, but verilog models that use \$temperature
  // don't also use a defined parameter "Temp", and count on \$temperature
  // to be the one the simulator wants:

  updateTemperature(admsInstTemp);

  // and of course, this routine is where we should put the initial_instance
  // stuff

  <admst:for-each select="analog/code/item/adms[datatypename='block']/..[name='initial_instance']">
    <!-- first declare any variables local to the initial_instance block -->
    <admst:for-each select="@assignedVars/[scope='local']">
      <admst:text format="  "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <!-- then emit the code -->
    <admst:apply-templates select="." match="block"/>
  </admst:for-each>

  return true;
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::Instance
// Purpose       : "instance block" constructor
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>

Instance::Instance(
  const Configuration &amp; configuration,
  const InstanceBlock &amp; instance_block,
  Model &amp;               model,
  const FactoryBlock &amp;  factory_block)
  : DeviceInstance(instance_block, configuration.getInstanceParameters(), factory_block),
    model_(model)
<admst:apply-templates select="." match="xyceInstanceInitializers"/>
{

  <admst:text format="    numIntVars = %(xyceNumberInternalNodes(.)) + %(count(/module/@extraUnknowns));\n"/>
  <admst:text format="    numExtVars = %(xyceNumberExternalNodes(.));\n"/>


  <admst:if test="[exists(@optnodes)]">
    portsConnected_.resize(%(xyceNumberExternalNodes(.)),true);
    if (instance_block.numExtVars &lt; %(xyceNumberExternalNodes(.)))
    {
       // some of our optional nodes were not given...
       for (int i=instance_block.numExtVars ; i&lt;numExtVars; i++)
       {
         portsConnected_[i]=false;
       }
       numIntVars += (%(xyceNumberExternalNodes(.))-instance_block.numExtVars);
       numExtVars = instance_block.numExtVars;
     }
  </admst:if>
  // Right now, we only have store for limited probes and output vars...
  setNumStoreVars(%(count(@limitedProbes))+%(count(/module/variable[output='yes' and input!='yes'])));

  // Do not allocate "branch" (lead current) vectors by default
  setNumBranchDataVars(0);

  <admst:choose>
    <admst:when test="[exists(@optnodes)]">
      <admst:text format="  numBranchDataVarsIfAllocated = std::min(%(xyceNumberLeadCurrents(.)),numExtVars);\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  numBranchDataVarsIfAllocated = %(xyceNumberLeadCurrents(.));\n"/>
    </admst:otherwise>
  </admst:choose>


  <!-- We always allocate these arrays to be equal to the number of
       external nodes, even if we're only going to use one of them,
       as in the case of two-terminal devices, and even if some are
       optional nodes that aren't specified -->
  leadCurrentF.resize(%(count(node[grounded='no' and location='external'])));
  leadCurrentQ.resize(%(count(node[grounded='no' and location='external'])));

  // Set up jacobian stamp:
  // Create a vector of the non-zero elements of the stamp

  <admst:apply-templates select="." match="xyceGenerateJacStamp2"/>


  setDefaultParams();
  setParams(instance_block.params);

  // Real bogosity here...
  if (!given("XYCEADMSINSTTEMP"))
    admsInstTemp=getDeviceOptions().temp.getImmutableValue&lt;double&gt;();

  //calculate any parameters specified as expressions
  updateDependentParameters();

  // calculate dependent (i.e. computed params) and check for errors.
  processParams();

  PairVector collapsedNodes;
<admst:if test="[count(node[#collapsible='yes'])>0]">
  collapseNodes();

  <admst:for-each select="node/[#collapsible='yes']">
  if (collapseNode_%(name))
  {
  <admst:if test="[exists(#optional) and #collapsesTo/name='GND']">
  //this node is optional, we only *literally* collapse it if it's not
  // connected
  if(!portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])
  {
  </admst:if>
  collapsedNodes.push_back(IntPair(%(xyceNodeConstantName(.)/[name='nodeConstant']/value),%(xyceNodeConstantName(@collapsesTo)/[name='nodeConstant']/value)));
  <admst:choose>
    <admst:when test="[exists(#optional) and @collapsesTo/name='GND']">
  }
  else
  {
  UserWarning(*this) &lt;&lt; &quot;Collapsing optional external node %(.) (node &quot; &lt;&lt; %(xyceNodeConstantName(.)/[name='nodeConstant']/value)+1 &lt;&lt; &quot;) to ground.  This can lead to singular matrices and convergence problems.  Consider removing this optional node from the instance line if convergence problems result.&quot; &lt;&lt; std::endl;
  }
    </admst:when>
    <admst:when test="[exists(#optional)]">
  }
  else
  {
  UserWarning(*this) &lt;&lt; &quot;Collapsing optional external node %(.) (node &quot; &lt;&lt; %(xyceNodeConstantName(.)/[name='nodeConstant']/value)+1 &lt;&lt; &quot;) to %(@collapsesTo/name), but this is not possible, so we're not actually doing it.  This can lead to singular matrices and convergence problems.  Consider removing this optional node from the instance line if convergence problems result.&quot; &lt;&lt; std::endl;
  }
    </admst:when>
  </admst:choose>
  }
  </admst:for-each>
</admst:if>

// Now generate the jacstamp from what we already have.
// This jacstamp will have all the correct node mapping.  map will be the nodal mapping of original
// node IDs to row/column ids in the reduced (non-sparse) representation of the jacobian.
// (for devices that have no collapsibles, this will be static, so check that it hasn't already
// been filled in)
if (jacStamp.empty())
{
int originalSize = %(count(node[grounded='no']))+%(count(@extraUnknowns));
computeJacStampAndMaps(jacobianElements,collapsedNodes,jacStamp,nodeMap,pairToJacStampMap,originalSize);
}

}

<admst:if test="[count(node[#collapsible='yes'])>0]">
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::collapseNodes
// Purpose       : function to handle collapsing of nodes
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::collapseNodes()
{

  <admst:for-each select="node/[#collapsible='yes']">
    <admst:text format="collapseNode_%(name) = false;\n"/>
  </admst:for-each>


  <admst:for-each select="analog/code[datatypename='block']/item">
    <admst:if test="[(datatypename!='block') or (datatypename='block'
         and name!='initial_model' and name!='initializeModel' and name!='initial_instance' and name!='initializeInstance' and name != 'noise' and name != 'initial_step')]">
<!--      <admst:warning format="Processing item %(.) of type %(datatypename)\n"/> -->
      <admst:apply-templates select="." match="evaluateCollapse">
        <admst:value-of select="returned('outputSomething')/value"/>
        <admst:variable name="outputSomething" select="%s"/>
        <admst:value-of select="returned('output')/value"/>
        <admst:variable name="output" select="%s"/>
        <admst:if test="[$outputSomething='yes']">
          <admst:text format="%($output)\n"/>
        </admst:if>
      </admst:apply-templates>
    </admst:if>
  </admst:for-each>


  <admst:for-each select="node/[#collapsible='yes']">
  if (collapseNode_%(name))
  {
  <admst:if test="[exists(#optional) and #collapsesTo/name='GND']">
  //this node is optional, and is external if it's connected --- so don't
  // decrement the internal node count!
  if(!portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])
  {
  </admst:if>
    numIntVars--;
  <admst:if test="[exists(#optional) and #collapsesTo/name='GND']">
  }
  </admst:if>
  }
  </admst:for-each>
}

</admst:if>
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::~Instance
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
Instance::~Instance()
{
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::registerLIDs
// Purpose       : function for registering, and setting up, local IDs.
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::registerLIDs( const LocalIdVector &amp; intLIDVecRef,
                             const LocalIdVector &amp; extLIDVecRef)
{
  AssertLIDs(intLIDVecRef.size() == numIntVars);
  AssertLIDs(extLIDVecRef.size() == numExtVars);

  LocalIdVector localLIDVec;

  if (DEBUG_DEVICE &amp;&amp; isActive(Diag::DEVICE_PARAMETERS))
  {
    Xyce::dout() &lt;&lt; std::endl &lt;&lt; section_divider &lt;&lt; std::endl
                 &lt;&lt; &quot;In $nameSpace::Instance::register LIDs\\n\\n&quot;
                 &lt;&lt; &quot;name             = &quot; &lt;&lt; getName() &lt;&lt; std::endl
                 &lt;&lt; &quot;number of internal variables: &quot; &lt;&lt; numIntVars &lt;&lt; std::endl
                 &lt;&lt; &quot;number of external variables: &quot; &lt;&lt; numExtVars &lt;&lt; std::endl;
  }

  // copy over the global ID lists into a local array.
  // The end result of this is an array of LIDs corresponding to all the
  // nodes we actually have, in the order that topology thinks of them
  intLIDVec = intLIDVecRef;
  extLIDVec = extLIDVecRef;
  localLIDVec.resize(numExtVars+numIntVars);
  for (int localNodeIndex=0;localNodeIndex&lt;numExtVars;++localNodeIndex)
  {
    localLIDVec[localNodeIndex]=extLIDVec[localNodeIndex];
  }
  for (int localNodeIndex=numExtVars;localNodeIndex&lt;numExtVars+numIntVars;++localNodeIndex)
  {
    localLIDVec[localNodeIndex]=intLIDVec[localNodeIndex-numExtVars];
    }

  // Now pull the LIDs for each of our nodes out of the local array.
  // Use the node mapping created by createJacStampAndMaps to handle
  // all the node collapse complications.

  <!-- Note:  Here we don't care if the external node is optional.  We
       are taking care of that in the setting of the localLIDVec -->
  <!-- for the moment, we'll forbid collapsing external nodes to anything
       even if they're just optional nodes.  This might be a problem.  -->
  <admst:for-each select="node[grounded='no' and location='external']">
    <admst:if test="[exists(#collapsible) and #collapsible='yes' and exists(#optional)]">
      <admst:if test="[@collapsesTo/name='GND']">
          <!-- even though this node is external, its node has been mapped
               to ground *and* we never, ever use this LID.  So we don't 
               need to check portsConnected_ -->
          <admst:text format="  if (collapseNode_%(name))\n"/>
          <admst:text format="  {\n    %(xyceNodeLIDVariable(.)) = -1;\n  }\n"/>
          <admst:text format="  else\n  {\n"/>
      </admst:if>
    </admst:if>
    <admst:text format="  %(xyceNodeLIDVariable(.)) = localLIDVec[nodeMap[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)]];\n"/>
    <admst:if test="[exists(#collapsible) and #collapsible='yes' and exists(#optional)]">
      <admst:if test="[@collapsesTo/name='GND']">
        <admst:text format="  }\n"/>
      </admst:if>
    </admst:if>
  </admst:for-each>

  <admst:for-each select="node[grounded='no' and location='internal']">
    <admst:if test="[exists(#collapsible) and #collapsible='yes']">
      <admst:if test="[@collapsesTo/name='GND']">
          <admst:text format="  if (collapseNode_%(name))\n  "/>
          <admst:text format="    {\n    %(xyceNodeLIDVariable(.)) = -1;\n    }\n"/>
          <admst:text format="  else\n    {\n"/>
      </admst:if>
    </admst:if>
    <admst:text format="  %(xyceNodeLIDVariable(.)) = localLIDVec[nodeMap[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)]];\n"/>
    <admst:if test="[exists(#collapsible) and #collapsible='yes']">
      <admst:if test="[@collapsesTo/name='GND']">
        <admst:text format="    }\n"/>
      </admst:if>
    </admst:if>


  </admst:for-each>

  <!-- Make sure to generate LIDs for the branch equations, too -->
  <admst:for-each select="/module/@extraUnknowns">
    <admst:text format="  %(xyceBranchLIDVariable(.)) = localLIDVec[nodeMap[%(xyceBranchConstantName(.)/[name='branchConstant']/value)]];\n"/>
  </admst:for-each>

  if (DEBUG_DEVICE &amp;&amp; isActive(Diag::DEVICE_PARAMETERS))
  {
    Xyce::dout() &lt;&lt; &quot;\\nSolution and RHS variables:\\n&quot;;
    <admst:for-each select="node[grounded='no']">
      Xyce::dout() &lt;&lt; &quot;\\n%(xyceNodeLIDVariable(.)) = &quot; &lt;&lt; %(xyceNodeLIDVariable(.)) &lt;&lt; std::endl;
    </admst:for-each>
    <admst:for-each select="/module/@extraUnknowns">
      Xyce::dout() &lt;&lt; &quot;\\n%(xyceBranchLIDVariable(.)) = &quot; &lt;&lt; %(xyceBranchLIDVariable(.)) &lt;&lt; std::endl;
    </admst:for-each>

    Xyce::dout() &lt;&lt; &quot;\\nEnd of $nameSpace::Instance::register LIDs\\n&quot;;
    Xyce::dout() &lt;&lt; section_divider &lt;&lt; std::endl;
  }
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::loadNodeSymbols
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::loadNodeSymbols(Util::SymbolTable &amp;symbol_table) const
{
  <admst:for-each select="node[grounded='no' and location='external' and exists(#optional)]">
      <admst:text format="\n    if (!portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])\n    {"/>
    <admst:if test="[exists(#collapsible) and #collapsible='yes']">
      <admst:text format="\n    if (!collapseNode_%(name))\n    {"/>
    </admst:if>
    addInternalNode(symbol_table, %(xyceNodeLIDVariable(.)), getName(), &quot;%(name)&quot;);
    <admst:if test="[exists(#collapsible) and #collapsible='yes']">
      <admst:text format="\n    }"/>
    </admst:if>
    <admst:text format="\n    }"/>
  </admst:for-each>
  <admst:for-each select="node[grounded='no' and location='internal']">
    <admst:if test="[exists(#collapsible) and #collapsible='yes']">
      <admst:text format="\n    if (!collapseNode_%(name))\n    {"/>
    </admst:if>
    addInternalNode(symbol_table, %(xyceNodeLIDVariable(.)), getName(), &quot;%(name)&quot;);
    <admst:if test="[exists(#collapsible) and #collapsible='yes']">
      <admst:text format="\n    }"/>
    </admst:if>
  </admst:for-each>

  <admst:for-each select="$theModule/@extraUnknowns">
    addInternalNode(symbol_table, %(xyceBranchLIDVariable(.)), getName(), &quot;%(pnode)_%(nnode)_branch&quot;);
  </admst:for-each>

  <admst:for-each select="$theModule/variable[output='yes' and input!='yes']">
    addStoreNode(symbol_table, li_store_%(name), getName().getEncodedName() + &quot;:%(name)&quot;);
  </admst:for-each>

  if (loadLeadCurrent)
  {

  <admst:choose>
    <admst:when test="[count($theModule/node[grounded='no' and location='external']) = 2 ]">
      <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable($theModule/node[2])), getName(), &quot;BRANCH_D&quot;);\n"/>
    </admst:when>
    <admst:otherwise>
      <!-- and here we have to do special things for MOSFETS and BJTs. -->
      <admst:choose>
        <admst:when test="[exists($theModule/attribute[name='xyceModelGroup']) and ($theModule/attribute[name='xyceModelGroup']/value='MOSFET' or $theModule/attribute[name='xyceModelGroup']/value='JFET' or $theModule/attribute[name='xyceModelGroup']/value='BJT')]">
          <admst:choose>
            <admst:when test="[$theModule/attribute[name='xyceModelGroup']/value='MOSFET' or $theModule/attribute[name='xyceModelGroup']/value='JFET']">
              <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable($theModule/node[2])), getName(), &quot;BRANCH_DD&quot;);\n"/>
              <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable($theModule/node[3])), getName(), &quot;BRANCH_DG&quot;);\n"/>
              <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable($theModule/node[4])), getName(), &quot;BRANCH_DS&quot;);\n"/>
            </admst:when>
            <admst:when test="[$theModule/attribute[name='xyceModelGroup']/value='BJT']">
              <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable($theModule/node[2])), getName(), &quot;BRANCH_DC&quot;);\n"/>
              <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable($theModule/node[3])), getName(), &quot;BRANCH_DB&quot;);\n"/>
              <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable($theModule/node[4])), getName(), &quot;BRANCH_DE&quot;);\n"/>
            </admst:when>
          </admst:choose>
          <admst:for-each select="$theModule/node[grounded='no' and location='external']">
            <admst:if test="[position(.) > 3]">
              <admst:if test="[exists(#optional)]">
                <admst:text format="    if (portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])\n    {\n"/>
              </admst:if>
              <admst:choose>
                <admst:when test="[$theModule/attribute[name='xyceModelGroup']/value='MOSFET' and name='e']">
                  <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable(.)), getName(), &quot;BRANCH_DE&quot;);\n"/>
                </admst:when>
                <admst:when test="[$theModule/attribute[name='xyceModelGroup']/value='MOSFET' and name='b']">
                  <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable(.)), getName(), &quot;BRANCH_DB&quot;);\n"/>
                </admst:when>
                <admst:otherwise>
                  <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable(.)), getName(), &quot;BRANCH_D%(position(.))&quot;);\n"/>
                </admst:otherwise>
              </admst:choose>
              <admst:if test="[exists(#optional)]">
                <admst:text format="    }\n"/>
              </admst:if>
            </admst:if>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:for-each select="$theModule/node[grounded='no' and location='external']">
            <admst:if test="[exists(#optional)]">
              <admst:text format="    if (portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])\n    {\n"/>
            </admst:if>
            <admst:text format="    addBranchDataNode( symbol_table, %(xyceLeadBranchLIDVariable(.)), getName(), &quot;BRANCH_D%(position(.))&quot;);\n"/>
            <admst:if test="[exists(#optional)]">
              <admst:text format="    }\n"/>
            </admst:if>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  }
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::registerStoreLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::registerStoreLIDs( const LocalIdVector &amp; stoLIDVecRef)
{
  AssertLIDs(stoLIDVecRef.size() == getNumStoreVars());
<admst:if test="[count(@limitedProbes)>0 or count(variable[output='yes' and input!='yes'])>0]">

  int numSto = stoLIDVecRef.size();
  if (numSto &gt; 0)
  {
    int i=0;
    stoLIDVec = stoLIDVecRef;

    <admst:for-each select="@limitedProbes">
    %(xyceLimitedProbeStoreLIDVariable(.)) = stoLIDVec[i++];
    </admst:for-each>
    <admst:for-each select="variable[output='yes' and input!='yes']">
      li_store_%(name)= stoLIDVec[i++];
    </admst:for-each>
  }
</admst:if>
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::registerBranchDataLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/09/11
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::registerBranchDataLIDs(const std::vector&lt;int&gt; &amp; branchLIDVecRef)
{
  AssertLIDs(branchLIDVecRef.size() == getNumBranchDataVars());

  if (loadLeadCurrent)
  {

    <!-- two-terminal devices are special, we only use one of the
         two possible lead currents, the first one. -->
    <admst:choose>
      <admst:when test="[count($theModule/node[grounded='no' and location='external']) = 2 ]">
        <!-- The first node is always GND -->
        <admst:text format="    %(xyceLeadBranchLIDVariable($theModule/node[2])) = branchLIDVecRef[0];\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="    int i = 0;\n"/>
        <admst:for-each select="node[grounded='no' and location='external']">
          <admst:if test="[exists(#optional)]">
            <admst:text format="    if (portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])\n    {\n"/>
          </admst:if>
          <admst:text format="    %(xyceLeadBranchLIDVariable(.)) = branchLIDVecRef[i++];\n"/>
          <admst:if test="[exists(#optional)]">
            <admst:text format="    }\n"/>
          </admst:if>
        </admst:for-each>
      </admst:otherwise>
    </admst:choose>
  }
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::jacobianStamp
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
const JacobianStamp &amp; Instance::jacobianStamp() const
{
    return jacStamp;
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::registerJacLIDs
// Purpose       : Create Offset variables used for referencing jacobian
//                 elements
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::registerJacLIDs( const JacobianStamp &amp; jacLIDVec)
{
  DeviceInstance::registerJacLIDs(jacLIDVec);
<admst:apply-templates select="." match="xyceRegisterJacLIDs"/>

}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::setupPointers
// Purpose       : Create pointer variables used for referencing jacobian
//                 elements
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::setupPointers( )
{

  Linear::Matrix &amp; dFdx = *(extData.dFdxMatrixPtr);
  Linear::Matrix &amp; dQdx = *(extData.dQdxMatrixPtr);

  <admst:apply-templates select="." match="xyceSetupPointers"/>

}

// RHS load functions

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::loadDAEFVector
// Purpose       : load F vector (static contributions) for one instance for
//                 NEW DAE formulation
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::loadDAEFVector()
{

  bool bsuccess=true;

  <admst:for-each select="node[grounded='no']">
    <admst:variable name="nodeConstantName" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
      <admst:text format="if (!collapseNode_%(name))\n  "/>
    </admst:if>
    <admst:text format="(*extData.daeFVectorPtr)[%(xyceNodeLIDVariable(.))] += staticContributions[$nodeConstantName];\n"/>
  </admst:for-each>

  <!-- now handle branch equations -->
  <admst:for-each select="$theModule/@extraUnknowns">
    (*extData.daeFVectorPtr)[%(xyceBranchLIDVariable(.))] += staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)];
  </admst:for-each>

  <admst:if test="[count(@limitedProbes)>0]">
  if (getDeviceOptions().voltageLimiterFlag &amp;&amp; !origFlag)
  {
    double *dFdxdVp = extData.dFdxdVpVectorRawPtr;

  <admst:for-each select="node[grounded='no']">
    <admst:variable name="nodeConstantName" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
      <admst:text format="if (!collapseNode_%(name))\n  "/>
    </admst:if>
    <admst:text format="dFdxdVp[%(xyceNodeLIDVariable(.))] += Jdxp_static[$nodeConstantName];\n"/>
  </admst:for-each>
  <admst:for-each select="$theModule/@extraUnknowns">
    <admst:variable name="branchConstantName" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
    dFdxdVp[%(xyceBranchLIDVariable(.))] += Jdxp_static[$branchConstantName];
  </admst:for-each>

  }
  </admst:if>

  if (loadLeadCurrent)
  {
    double * leadF = extData.nextLeadCurrFCompRawPtr;

    <admst:choose>
      <admst:when test="[count($theModule/node[grounded='no' and location='external']) = 2 ]">
        <admst:text format="    leadF[%(xyceLeadBranchLIDVariable($theModule/node[2]))] = leadCurrentF[0];\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:for-each select="$theModule/node[grounded='no' and location='external']">
          <admst:if test="[exists(#optional)]">
            <admst:text format="    if (portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])\n    {\n"/>
          </admst:if>
          <admst:text format="    leadF[%(xyceLeadBranchLIDVariable(.))] = leadCurrentF[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)];\n"/>
          <admst:if test="[exists(#optional)]">
            <admst:text format="    }\n"/>
          </admst:if>
        </admst:for-each>
      </admst:otherwise>
    </admst:choose>


    // here we have to do special things for BJTs, MOSFETs and 2-terminal
    // devices for power computation.

    <admst:choose>
      <admst:when test="[exists($theModule/attribute[name='xyceModelGroup']) and($theModule/attribute[name='xyceModelGroup']/value='BJT' or $theModule/attribute[name='xyceModelGroup']/value='MOSFET' or $theModule/attribute[name='xyceModelGroup']/value='JFET')]">
        double * solVec = extData.nextSolVectorRawPtr;
        double * junctionV = extData.nextJunctionVCompRawPtr;
        junctionV[%(xyceLeadBranchLIDVariable($theModule/node[2]))] = solVec[%(xyceNodeLIDVariable($theModule/node[2]))] - solVec[%(xyceNodeLIDVariable($theModule/node[4]))];
        junctionV[%(xyceLeadBranchLIDVariable($theModule/node[3]))] = solVec[%(xyceNodeLIDVariable($theModule/node[3]))] - solVec[%(xyceNodeLIDVariable($theModule/node[4]))];
      </admst:when>
      <admst:when test="[count($theModule/node[grounded='no' and location='external']) = 2 ]">
        double * solVec = extData.nextSolVectorRawPtr;
        double * junctionV = extData.nextJunctionVCompRawPtr;
        junctionV[%(xyceLeadBranchLIDVariable($theModule/node[2]))] = solVec[%(xyceNodeLIDVariable($theModule/node[2]))] - solVec[%(xyceNodeLIDVariable($theModule/node[3]))];
      </admst:when>
      <admst:otherwise>
        <admst:text format="// power not supported for this device type, don't load junctionV\n"/>
      </admst:otherwise>
    </admst:choose>

  }
  return bsuccess;
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::loadDAEQVector
// Purpose       : load Q vector (dynamic contributions) for one instance for
//                 NEW DAE formulation
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::loadDAEQVector()
{

  <admst:for-each select="node[grounded='no']">
    <admst:variable name="nodeConstantName" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
      <admst:text format="if (!collapseNode_%(name))\n  "/>
    </admst:if>
    <admst:text format="(*extData.daeQVectorPtr)[%(xyceNodeLIDVariable(.))] += dynamicContributions[$nodeConstantName];\n"/>
  </admst:for-each>

  <!-- now handle branch equations -->
  <admst:for-each select="$theModule/@extraUnknowns">
    (*extData.daeQVectorPtr)[%(xyceBranchLIDVariable(.))] += dynamicContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)];
  </admst:for-each>
  <admst:if test="[count(@limitedProbes)>0]">
  if (getDeviceOptions().voltageLimiterFlag &amp;&amp; !origFlag)
  {
    double *dQdxdVp = extData.dQdxdVpVectorRawPtr;

  <admst:for-each select="node[grounded='no']">
    <admst:variable name="nodeConstantName" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
      <admst:text format="if (!collapseNode_%(name))\n  "/>
    </admst:if>
    <admst:text format="dQdxdVp[%(xyceNodeLIDVariable(.))] += Jdxp_dynamic[$nodeConstantName];\n"/>
  </admst:for-each>
  <admst:for-each select="$theModule/@extraUnknowns">
    <admst:variable name="branchConstantName" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
    dQdxdVp[%(xyceBranchLIDVariable(.))] += Jdxp_dynamic[$branchConstantName];
  </admst:for-each>
  }
  </admst:if>

  if (loadLeadCurrent)
  {
    double * leadQ = extData.nextLeadCurrQCompRawPtr;

    <admst:choose>
      <admst:when test="[count($theModule/node[grounded='no' and location='external']) = 2 ]">
        <admst:text format="    leadQ[%(xyceLeadBranchLIDVariable($theModule/node[2]))] = leadCurrentQ[0];\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:for-each select="$theModule/node[grounded='no' and location='external']">
          <admst:if test="[exists(#optional)]">
            <admst:text format="    if (portsConnected_[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)])\n    {\n"/>
          </admst:if>
          <admst:text format="    leadQ[%(xyceLeadBranchLIDVariable(.))] = leadCurrentQ[%(xyceNodeConstantName(.)/[name='nodeConstant']/value)];\n"/>
          <admst:if test="[exists(#optional)]">
            <admst:text format="    }\n"/>
          </admst:if>
        </admst:for-each>
      </admst:otherwise>
    </admst:choose>

  }
  return true;
}


<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::updatePrimaryState
// Purpose       :
// Special Notes : In this initial implementation, does little more than
//                 call updateIntermediateVars()
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::updatePrimaryState()
{
  bool bsuccess = true;

  bsuccess = updateIntermediateVars();

  // if old DAE were implemented, we'd save dynamic contributions as state
  // here.

<admst:if test="[count(@limitedProbes)>0 or count(variable[output='yes' and input!='yes'])>0]">
  double * stoVec = extData.nextStoVectorRawPtr;
  // Also need to save limited voltage drops and output vars
  // This formulation assumes that we have *always* written the
  // limited voltages back into the probeVars[] array.

  <admst:for-each select="@limitedProbes">
  stoVec[%(xyceLimitedProbeStoreLIDVariable(.))] = probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)];
  </admst:for-each>

  <admst:for-each select="variable[output='yes' and input!='yes']">
  stoVec[li_store_%(name)] = %(name);
  </admst:for-each>

</admst:if>

  return bsuccess;
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::updateSecondaryState
// Purpose       :
// Special Notes : In this initial implementation, does nothing
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::updateSecondaryState()
{
  bool bsuccess = true;

  // were old DAE implemented, we'd pull dynamic contribution derivatives
  // out of state.

  return bsuccess;
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::updateIntermediateVars
// Purpose       : update intermediate variables for one %(name) instance
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::updateIntermediateVars()
{

  bool bsuccess=true;
  Linear::Vector * solVectorPtr = extData.nextSolVectorPtr;

  if (DEBUG_DEVICE &amp;&amp; isActive(Diag::DEVICE_PARAMETERS) &amp;&amp; getSolverState().debugTimeFlag)
  {
    Xyce::dout() &lt;&lt; std::endl &lt;&lt; subsection_divider &lt;&lt; std::endl;
    Xyce::dout() &lt;&lt; &quot;  In $nameSpace::Instance::updateIntermediateVars\\n\\n&quot;;
    Xyce::dout() &lt;&lt; &quot;  name = &quot; &lt;&lt; getName() &lt;&lt; std::endl;
  }

  <!-- Declare all variables in analog/code that are not of global scope
       or used only in special sub-blocks (initial_model or initial_instance).

       This relies on us having called collectAssignedVariables for the
       top level already.  We did that in the first few lines of this file.

       The only things that need declaring here are the ones with local scope
   -->
  // Local variables

  <admst:for-each select="analog/code/@assignedVars">
    <admst:if test="[scope='local' and block/adms/datatypename='module']">
      <admst:text format="  "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:if>
  </admst:for-each>

  <admst:if test="[count(@limitedProbes)>0]">
    <admst:apply-templates select="." match="xyceDeclareLimitingTemporaries"/>
  </admst:if>

  // set the sizes of the Fad arrays:

  if (probeVars.size() != (%(xyceNumberProbes($theModule))))
  {
    probeVars.resize(%(xyceNumberProbes($theModule)));
    d_probeVars.resize(%(xyceNumberProbes($theModule)));
    for (int i=0;i&lt;%(xyceNumberProbes($theModule));i++)
    {
      d_probeVars[i].resize(%(xyceNumberProbes($theModule)));
      for (int j=0;j&lt;%(xyceNumberProbes($theModule));j++)
        d_probeVars[i][j]=0.0;
    }
    staticContributions.resize(%($numSolVars));
    d_staticContributions.resize(%($numSolVars));
    for (int i=0;i&lt;%($numSolVars);i++)
      d_staticContributions[i].resize(%(xyceNumberProbes($theModule)));
    dynamicContributions.resize(%($numSolVars));
    d_dynamicContributions.resize(%($numSolVars));
    for (int i=0;i&lt;%($numSolVars);i++)
      d_dynamicContributions[i].resize(%(xyceNumberProbes($theModule)));
    <admst:if test="[count(@limitedProbes)>0]">
    probeDiffs.resize(%(xyceNumberProbes($theModule)),0.0);
    Jdxp_static.resize(%($numSolVars));
    Jdxp_dynamic.resize(%($numSolVars));
    </admst:if>
  }

  <admst:if test="[count(contribution[whitenoise='yes' or flickernoise='yes'])>0]">
    noiseContribsPower.resize(%(count(contribution[whitenoise='yes' or flickernoise='yes'])));
    noiseContribsExponent.resize(%(count(contribution[whitenoise='yes' or flickernoise='yes'])));
  </admst:if>

  // initialize contributions to zero (automatically sets derivatives to zero)
  for (int i=0; i &lt; %($numSolVars) ; ++i)
  {
     staticContributions[i]=0;
     for (int j=0;j&lt;%(xyceNumberProbes($theModule));j++)
        d_staticContributions[i][j] = 0.0;
     dynamicContributions[i]=0;
     for (int j=0;j&lt;%(xyceNumberProbes($theModule));j++)
        d_dynamicContributions[i][j] = 0.0;
     <admst:if test="[count(@limitedProbes)>0]">
     Jdxp_static[i]=0;
     Jdxp_dynamic[i]=0;
     </admst:if>
  }

  <admst:if test="[count(@limitedProbes)>0]">
  <!-- initialize probeDiffs to zero -->
  for (int i=0; i &lt; %(xyceNumberProbes($theModule)) ; ++i)
  {
    probeDiffs[i] = 0.0;
  }
  </admst:if>
  // extract solution variables and set as Fad independent variables.

  <admst:for-each select="probe">
    <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
    <admst:choose>
      <admst:when test="[nature=discipline/potential]">
        <admst:choose>
          <admst:when test="branch/nnode[grounded='yes']">
            <admst:choose>
              <admst:when test="[exists(branch/pnode/#collapsible) and (branch/pnode/@collapsesTo/name='GND')]">
                <admst:text format="probeVars[%($probeConstantName)] = ((collapseNode_%(branch/pnode/name))?(0):((*solVectorPtr)[%(xyceNodeLIDVariable(branch/pnode))]));\n"/>
              </admst:when>
              <admst:otherwise>
                <admst:text format="probeVars[%($probeConstantName)] = (*solVectorPtr)[%(xyceNodeLIDVariable(branch/pnode))];\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:text format="probeVars[%($probeConstantName)] = "/>
            <admst:choose>
              <admst:when test="[exists(branch/pnode/#collapsible) and (branch/pnode/@collapsesTo/name='GND')]">
                <admst:text format="(collapseNode_%(branch/pnode/name))?(0):((*solVectorPtr)[%(xyceNodeLIDVariable(branch/pnode))])"/>
              </admst:when>
              <admst:otherwise>
                <admst:text format="(*solVectorPtr)[%(xyceNodeLIDVariable(branch/pnode))]"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[exists(branch/nnode/#collapsible) and (branch/nnode/@collapsesTo/name='GND')]">
                <admst:text format=" - ((collapseNode_%(branch/nnode/name))?(0):((*solVectorPtr)[%(xyceNodeLIDVariable(branch/nnode))]))"/>
              </admst:when>
              <admst:otherwise>
                <admst:text format=" - (*solVectorPtr)[%(xyceNodeLIDVariable(branch/nnode))]"/>
              </admst:otherwise>
            </admst:choose>
            <admst:text format=";\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[nature=discipline/flow]">
        <admst:text format="probeVars[%($probeConstantName)] = (*solVectorPtr)[%(xyceBranchLIDVariable(branch))];\n"/>
      </admst:when>
    </admst:choose>
    <admst:text format="d_probeVars[%($probeConstantName)][%($probeConstantName)] = 1.0;\n"/>

  </admst:for-each>

  <!-- do the assignments of probes that weren't caught by ADMS, because
       they're implicit in the use of voltage sources -->
  <admst:for-each select="@extraProbeBranches">
    <admst:variable name="probeConstantName" select="%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)"/>
    <admst:text format="probeVars[%($probeConstantName)] = (*solVectorPtr)[%(xyceBranchLIDVariable(.))];\n"/>
    <admst:text format="d_probeVars[%($probeConstantName)][%($probeConstantName)] = 1.0;\n"/>
  </admst:for-each>

  <admst:if test="[count(@limitedProbes)>0]">

    // pre-multiply any "typed" probes (i.e. those limited with "typedpnjlim")

  <admst:for-each select="@limiters/rhs/[probe/#typed='yes']">
    <admst:if test="[count(function[name='\$limit']/arguments)>2]">
      <admst:choose>
        <admst:when test="[function/[name='\$limit']/arguments[3]/datatypename='string']">
          <admst:if test="[function/[name='\$limit']/arguments[3]/value='typed']">
            <admst:text format="probeVars[%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[4]));\n"/>
            <admst:text format="d_probeVars[%(xyceProbeConstantName(probe)/[name='probeConstant']/value)][%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[4]));\n"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:text format="probeVars[%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[5]));\n"/>
          <admst:text format="d_probeVars[%(xyceProbeConstantName(probe)/[name='probeConstant']/value)][%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[5]));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
  </admst:for-each>

  <admst:text format="\n// Copy probes into limiting vars\n"/>
  <admst:for-each select="@limiters">
  %(printTerm(lhs))_orig = %(printTerm(lhs))_limited = probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];
  probeDiffs[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)] = 0.0;
  </admst:for-each>

  origFlag = true;

  if (getSolverState().newtonIter == 0)
  {

    if (!(getSolverState().dcopFlag)||(getSolverState().locaEnabledFlag &amp;&amp; getSolverState().dcopFlag))
    {
     <admst:for-each select="@limiters">
       %(printTerm(lhs))_old = ((*extData.currStoVectorPtr))[%(xyceLimitedProbeStoreLIDVariable(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];
     </admst:for-each>
    }
    else
    {
     <admst:for-each select="@limiters">
       %(printTerm(lhs))_old = %(printTerm(lhs))_limited;
     </admst:for-each>
    }
  }
  else
  {
  <admst:for-each select="@limiters">
     %(printTerm(lhs))_old = ((*extData.nextStoVectorPtr))[%(xyceLimitedProbeStoreLIDVariable(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];
  </admst:for-each>
  <admst:text format="\n}\n"/>
  </admst:if>

  <admst:if test="[exists(analog/code/item[adms/datatypename='block' and name='initial_step'])]">
    <admst:text format="if (getSolverState().dcopFlag)\n"/>
    <admst:text format="{\n"/>
            <admst:apply-templates select="analog/code/item[adms/datatypename='block' and name='initial_step']" match="block"/>
    <admst:text format="}\n"/>
  </admst:if>

  <admst:text format="// -- code converted from analog/code block\n"/>
  <!-- this belongs in a template -->
  <admst:for-each select="analog/code/item">
    <admst:choose>
      <admst:when test="adms[datatypename!='block']">
        <admst:apply-templates select="." match="%(adms/datatypename)"/>
      </admst:when>
      <admst:otherwise>
          <admst:if test="[name!='initial_model' and name !='initial_instance' and name != 'initial_step' ]">
            <admst:apply-templates select="." match="block"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>

  <!-- Ok... finish up the hackage for branch equations, because those
     still need one more term added -->
  <admst:apply-templates select="." match="finishUpBranchEquations"/>

  // -- endcode converted from analog/code block
  if (DEBUG_DEVICE &amp;&amp; isActive(Diag::DEVICE_PARAMETERS) &amp;&amp; getSolverState().debugTimeFlag)
  {
  <admst:for-each select="probe">
    <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
    Xyce::dout() &lt;&lt; &quot; probeVars[%($probeConstantName)] =  &quot;
         &lt;&lt;probeVars[%($probeConstantName)] &lt;&lt; std::endl;
  </admst:for-each>
  <admst:for-each select="node[grounded='no']">
    <admst:variable name="nodeConstantName" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    Xyce::dout() &lt;&lt; &quot; staticContributions[%($nodeConstantName)] =  &quot;
         &lt;&lt;staticContributions[%($nodeConstantName)] &lt;&lt; std::endl;
    <admst:for-each select="$theModule/probe">
      <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
      Xyce::dout() &lt;&lt; &quot;    staticContributions[%($nodeConstantName)].dx(%($probeConstantName)) =  &quot; &lt;&lt;d_staticContributions[%($nodeConstantName)][%($probeConstantName)] &lt;&lt; std::endl;
    </admst:for-each>
    Xyce::dout() &lt;&lt; &quot; dynamicContributions[%($nodeConstantName)] =  &quot;
         &lt;&lt;dynamicContributions[%($nodeConstantName)] &lt;&lt; std::endl;
    <admst:for-each select="$theModule/probe">
      <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
      Xyce::dout() &lt;&lt; &quot;    dynamicContributions[%($nodeConstantName)].dx(%($probeConstantName)) =  &quot; &lt;&lt;d_dynamicContributions[%($nodeConstantName)][%($probeConstantName)] &lt;&lt; std::endl;
    </admst:for-each>
    <admst:if test="[$theModule/count(@limitedProbes)>0]">
    Xyce::dout() &lt;&lt; &quot; Jdxp_static[%($nodeConstantName)] =  &quot;
         &lt;&lt;Jdxp_static[%($nodeConstantName)] &lt;&lt; std::endl;
    Xyce::dout() &lt;&lt; &quot; Jdxp_dynamic[%($nodeConstantName)] =  &quot;
         &lt;&lt;Jdxp_dynamic[%($nodeConstantName)] &lt;&lt; std::endl;
    </admst:if>

  </admst:for-each>

  <!-- Now debugging output for the branch currents -->
  <admst:for-each select="$theModule/@extraUnknowns">
    <admst:variable name="branchConstantName" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
    Xyce::dout() &lt;&lt; &quot; staticContributions[%($branchConstantName)] =  &quot;
         &lt;&lt;staticContributions[%($branchConstantName)] &lt;&lt; std::endl;
    <admst:for-each select="$theModule/probe">
      <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
      Xyce::dout() &lt;&lt; &quot;    staticContributions[%($branchConstantName)].dx(%($probeConstantName)) =  &quot; &lt;&lt;d_staticContributions[%($branchConstantName)][%($probeConstantName)] &lt;&lt; std::endl;
    </admst:for-each>
    Xyce::dout() &lt;&lt; &quot; dynamicContributions[%($branchConstantName)] =  &quot;
         &lt;&lt;dynamicContributions[%($branchConstantName)] &lt;&lt; std::endl;
    <admst:for-each select="$theModule/probe">
      <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
      Xyce::dout() &lt;&lt; &quot;    dynamicContributions[%($branchConstantName)].dx(%($probeConstantName)) =  &quot; &lt;&lt;d_dynamicContributions[%($branchConstantName)][%($probeConstantName)] &lt;&lt; std::endl;
    </admst:for-each>
  </admst:for-each>

    if (!origFlag)
      Xyce::dout() &lt;&lt; "This step was limited by this device." &lt;&lt; std::endl;
  }


  if (loadLeadCurrent)
  {
    // If needed, we must now copy all the data from staticContributions
    // and dynamicContributionsinto the lead current F vector
    // Must make sure all collapsed node contributions get summed into the
    // external nodes properly.
    for ( int unmappedNode=0; unmappedNode &lt; %(count($theModule/node[grounded='no' and location='external'])) ; unmappedNode++)
    {
      leadCurrentF[unmappedNode] = 0.0;
      leadCurrentQ[unmappedNode] = 0.0;
    }
    for ( int unmappedNode=0; unmappedNode &lt; %(count($theModule/node[grounded='no'])); unmappedNode++)
    {
      if (nodeMap[unmappedNode] &lt; %(count($theModule/node[grounded='no' and location='external'])) &amp;&amp; nodeMap[unmappedNode] != -1 )
      {
        leadCurrentF[nodeMap[unmappedNode]] += staticContributions[unmappedNode];
        leadCurrentQ[nodeMap[unmappedNode]] += dynamicContributions[unmappedNode];
      }
    }
  }
  return true;
}

<admst:if test="[count(contribution[whitenoise='yes' or flickernoise='yes'])>0]">
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::getNumNoiseSources
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
int Instance::getNumNoiseSources () const
{
return %(count(contribution[whitenoise='yes']) + count(contribution[flickernoise='yes']));
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::setupNoiseSources
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::setupNoiseSources (Xyce::Analysis::NoiseData &amp; noiseData)
{
int numSources=getNumNoiseSources();
noiseData.numSources = numSources;
noiseData.resize(numSources);

noiseData.deviceName = getName().getEncodedName();
std::string theNoiseName;

<admst:for-each select="contribution[whitenoise='yes' or flickernoise='yes']">
  <admst:variable name="theNoiseContributionName" select="%(xyceNoiseContributionName(.))"/>
  <admst:text format="theNoiseName = std::string(&quot;noise_&quot;)+getName().getEncodedName()+std::string(&quot;_%($theNoiseContributionName/[name='noiseName']/value)&quot;)"/>
  <admst:if test="[not(nilled($theNoiseContributionName/[name='givenName']))]">
    <admst:text format="+std::string(&quot;_&quot;)+std::string(%($theNoiseContributionName/[name='givenName']/value))"/>
  </admst:if>
  <admst:text format=";\n"/>
  <admst:text format="std::replace(theNoiseName.begin(), theNoiseName.end(), ' ', '_');\n"/>
  <admst:text format="noiseData.noiseNames[%(#noiseContIndex)]=theNoiseName;\n"/>
  <admst:choose>
    <admst:when test="[lhs/branch/pnode/grounded='yes']">
      <admst:text format="noiseData.li_Pos[%(#noiseContIndex)]=-1;\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="noiseData.li_Pos[%(#noiseContIndex)]=%(xyceNodeLIDVariable(lhs/branch/pnode));\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="[lhs/branch/nnode/grounded='yes']">
      <admst:text format="noiseData.li_Neg[%(#noiseContIndex)]=-1;\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="noiseData.li_Neg[%(#noiseContIndex)]=%(xyceNodeLIDVariable(lhs/branch/nnode));\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:for-each>

}
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::getNoiseSources
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
void Instance::getNoiseSources (Xyce::Analysis::NoiseData &amp; noiseData)
{
  <admst:for-each select="contribution[whitenoise='yes' or flickernoise='yes']">

    <admst:text format="noiseData.noiseDens[%(#noiseContIndex)] = noiseContribsPower[%(#noiseContIndex)];\n"/>

    <admst:if test="[flickernoise='yes']">
      noiseData.noiseDens[%(#noiseContIndex)] /= pow(noiseData.freq,noiseContribsExponent[%(#noiseContIndex)]);
    </admst:if>

    <admst:text format="noiseData.lnNoiseDens[%(#noiseContIndex)] = std::log(std::max(noiseData.noiseDens[%(#noiseContIndex)],N_MINLOG));\n"/>

  </admst:for-each>
}
</admst:if>

<admst:text format="\n\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::loadDAEdFdx
// Purpose       :
// Special Notes : Load the dFdx ("static jacobian") matrix
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::loadDAEdFdx()
{
  bool bsuccess = true;
  Linear::Matrix &amp; dFdx = *(extData.dFdxMatrixPtr);

#ifndef Xyce_NONPOINTER_MATRIX_LOAD

  <admst:for-each select="$theModule/jacobian">
    <admst:if test="[static='yes']">
      <!-- determine which drops this thing depends on, and use the chain rule
           to get the derivative with respect to the desired node -->
      <!-- We do this by stuffing the list of probes into an array in the
           /module path.  I'd rather do it by stuffing the array into the
           jacobian entry itself, but this segfaults ADMS -->
      <admst:variable name="jacrow" select="%(row/name)"/>
      <admst:variable name="jaccol" select="%(column/name)"/>
      <admst:variable name="rowConstant" select="%(xyceNodeConstantName(row)/[name='nodeConstant']/value)"/>
      <!-- find all the static contributions into flows that impact this
           jacobian row, and collect up all the probes for that
           contribution that involve this column -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="/module/contribution[lhs/nature=lhs/discipline/flow and (lhs/branch/pnode/name='$jacrow' or lhs/branch/nnode/name='$jacrow') ]">
        <admst:if test="[rhs/static = 'yes']">
          <admst:for-each select="rhs/probe[branch/pnode/name = '$jaccol' or branch/nnode/name='$jaccol']">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:for-each>
        </admst:if>
      </admst:for-each>
      <!-- now /module/@tempProbes has all the probes that impact this row. -->

      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(row/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(column/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:text format="  (*%(xycedFdXPtrName(.))) += "/>

      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$jaccol]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$jaccol]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_staticContributions[$rowConstant][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <admst:text format=";\n"/>
      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>


    </admst:if>
  </admst:for-each>

<!-- Now handle the extra columns of the jacobian for nodes that depend
     on branch variables -->
  <admst:for-each select="$theModule/node[not(nilled(@branchDeps))]">
    <admst:variable name="theNode" select="%(.)"/>
    <admst:for-each select="@branchDeps">
      <admst:variable name="rowConstant" select="%(xyceNodeConstantName($theNode)/[name='nodeConstant']/value)"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%($theNode/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:text format="  (*f_%($theNode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr) += "/>
      <admst:text format="d_staticContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>


    </admst:for-each>
  </admst:for-each>

<!-- finally, handle the branch equation rows themselves. -->
  <admst:for-each select="$theModule/@extraUnknowns">
    <admst:text format="    // there also need to be extra loads for branch %(.)\n"/>
    <admst:variable name="theBranch" select="%(.)"/>
    <admst:for-each select="@nodeDeps">
      <admst:variable name="theVar" select="%(.)"/>
      <admst:text format="    // Load for branch %($theBranch) equ var %($theVar)\n"/>
      <!-- Find all contributions into POTENTIALS involving this branch, and
          collect up all voltage probes on the RHS that involve this variable.
          -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="$theModule/contribution[lhs/nature=lhs/discipline/potential and (lhs/branch/pnode/name=$theBranch/pnode/name and lhs/branch/nnode/name=$theBranch/nnode/name) and rhs/static='yes']">
        <admst:for-each select="rhs/probe[branch/pnode/name=$theVar/name or branch/nnode/name=$theVar/name]">
          <admst:if test="[nature=discipline/potential]">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:if>
        </admst:for-each>
      </admst:for-each>

      <!-- We now know what probes this branch depends on.  Make noise -->
      <admst:for-each select="/module/@tempProbes">
        <admst:text format="     // depends on probe %(.)\n"/>
      </admst:for-each>

      <!-- Now emit the code -->
      <admst:if test="[count(/module/@tempProbes)>0 or $theVar/name=$theBranch/pnode/name or ($theVar/name=$theBranch/nnode/name and $theVar/grounded='no')]">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="  (*f_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_%(name)_Node_Ptr) += "/>
      </admst:if>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$theVar/name]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$theVar/name]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_staticContributions[%($rowConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <!-- if this var is the positive node of our branch, then we add -1
           and if negative, add +1.  This is because the branch equation is:
           (sum of contributions into V(b)) - v(b) = 0
           or
           (sum of contributions into V(b)) - (V(pnode) - V(nnode)) = 0
           or
           (sum of contributions into V(b)) - V(pnode) + V(nnode) = 0
      -->
      <admst:if test="[$theBranch/pnode/name=$theVar/name]">
        <admst:text format=" -1"/>
      </admst:if>
      <admst:if test="[$theBranch/nnode/name=$theVar/name]">
        <admst:text format=" +1"/>
      </admst:if>
      <admst:if test="[count(/module/@tempProbes)>0 or name=$theBranch/pnode/name or (name=$theBranch/nnode/name and grounded='no')]">
        <admst:text format=";\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:if>

    </admst:for-each>


    <!-- Now handle branch dependence on branches -->
    <admst:for-each select="@branchDeps">
      <admst:text format="    //load for branch %($theBranch) equ branch %(.) var\n"/>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:text format="  (*f_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr) += d_staticContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>

    </admst:for-each>
  </admst:for-each>
#else
  //use the offsets instead of pointers

  <admst:for-each select="$theModule/jacobian">
    <admst:if test="[static='yes']">
      <!-- determine which drops this thing depends on, and use the chain rule
           to get the derivative with respect to the desired node -->
      <!-- We do this by stuffing the list of probes into an array in the
           /module path.  I'd rather do it by stuffing the array into the
           jacobian entry itself, but this segfaults ADMS -->
      <admst:variable name="jacrow" select="%(row/name)"/>
      <admst:variable name="jaccol" select="%(column/name)"/>
      <admst:variable name="rowConstant" select="%(xyceNodeConstantName(row)/[name='nodeConstant']/value)"/>
      <!-- find all the static contributions into flows that impact this
           jacobian row, and collect up all the probes for that
           contribution that involve this column -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="/module/contribution[lhs/nature=lhs/discipline/flow and (lhs/branch/pnode/name='$jacrow' or lhs/branch/nnode/name='$jacrow') ]">
        <admst:if test="[rhs/static = 'yes']">
          <admst:for-each select="rhs/probe[branch/pnode/name = '$jaccol' or branch/nnode/name='$jaccol']">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:for-each>
        </admst:if>
      </admst:for-each>
      <!-- now /module/@tempProbes has all the probes that impact this row. -->

      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(row/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(column/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:text format="  dFdx[%(xyceNodeLIDVariable(row))][%(xyceJacobianOffsetName(.))] += "/>

      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$jaccol]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$jaccol]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_staticContributions[$rowConstant][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <admst:text format=";\n"/>
      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>


    </admst:if>
  </admst:for-each>

<!-- Now handle the extra columns of the jacobian for nodes that depend
     on branch variables -->
  <admst:for-each select="$theModule/node[not(nilled(@branchDeps))]">
    <admst:variable name="theNode" select="%(.)"/>
    <admst:for-each select="@branchDeps">
      <admst:variable name="rowConstant" select="%(xyceNodeConstantName($theNode)/[name='nodeConstant']/value)"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%($theNode/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:text format="  dFdx[%(xyceNodeLIDVariable($theNode))][A_%($theNode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset] += "/>
      <admst:text format="d_staticContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>


    </admst:for-each>
  </admst:for-each>

<!-- finally, handle the branch equation rows themselves. -->
  <admst:for-each select="$theModule/@extraUnknowns">
    <admst:text format="    // there also need to be extra loads for branch %(.)\n"/>
    <admst:variable name="theBranch" select="%(.)"/>
    <admst:for-each select="@nodeDeps">
      <admst:variable name="theVar" select="%(.)"/>
      <admst:text format="    // Load for branch %($theBranch) equ var %($theVar)\n"/>
      <!-- Find all contributions into POTENTIALS involving this branch, and
          collect up all voltage probes on the RHS that involve this variable.
          -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="$theModule/contribution[lhs/nature=lhs/discipline/potential and (lhs/branch/pnode/name=$theBranch/pnode/name and lhs/branch/nnode/name=$theBranch/nnode/name) and rhs/static='yes']">
        <admst:for-each select="rhs/probe[branch/pnode/name=$theVar/name or branch/nnode/name=$theVar/name]">
          <admst:if test="[nature=discipline/potential]">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:if>
        </admst:for-each>
      </admst:for-each>

      <!-- We now know what probes this branch depends on.  Make noise -->
      <admst:for-each select="/module/@tempProbes">
        <admst:text format="     // depends on probe %(.)\n"/>
      </admst:for-each>

      <!-- Now emit the code -->
      <admst:if test="[count(/module/@tempProbes)>0 or $theVar/name=$theBranch/pnode/name or ($theVar/name=$theBranch/nnode/name and $theVar/grounded='no')]">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="  dFdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_%(name)_Node_Offset] += "/>
      </admst:if>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$theVar/name]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$theVar/name]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_staticContributions[%($rowConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <!-- if this var is the positive node of our branch, then we add -1
           and if negative, add +1.  This is because the branch equation is:
           (sum of contributions into V(b)) - v(b) = 0
           or
           (sum of contributions into V(b)) - (V(pnode) - V(nnode)) = 0
           or
           (sum of contributions into V(b)) - V(pnode) + V(nnode) = 0
      -->
      <admst:if test="[$theBranch/pnode/name=$theVar/name]">
        <admst:text format=" -1"/>
      </admst:if>
      <admst:if test="[$theBranch/nnode/name=$theVar/name]">
        <admst:text format=" +1"/>
      </admst:if>
      <admst:if test="[count(/module/@tempProbes)>0 or name=$theBranch/pnode/name or (name=$theBranch/nnode/name and grounded='no')]">
        <admst:text format=";\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:if>

    </admst:for-each>


    <!-- Now handle branch dependence on branches -->
    <admst:for-each select="@branchDeps">
      <admst:text format="    //load for branch %($theBranch) equ branch %(.) var\n"/>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:text format="  dFdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset] += d_staticContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>

    </admst:for-each>
  </admst:for-each>
#endif

  return bsuccess;
}


<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::loadDAEdQdx
// Purpose       :
// Special Notes : Load the dQdx ("dynamic jacobian") matrix
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::loadDAEdQdx()
{
  bool bsuccess = true;
  Linear::Matrix &amp; dQdx = *(extData.dQdxMatrixPtr);

#ifndef Xyce_NONPOINTER_MATRIX_LOAD

  <admst:for-each select="$theModule/jacobian">
    <admst:if test="[dynamic='yes']">
      <!-- determine which drops this thing depends on, and use the chain rule
           to get the derivative with respect to the desired node -->
      <!-- We do this by stuffing the list of probes into an array in the
           /module path.  I'd rather do it by stuffing the array into the
           jacobian entry itself, but this segfaults ADMS -->
      <admst:variable name="jacrow" select="%(row/name)"/>
      <admst:variable name="jaccol" select="%(column/name)"/>
      <admst:variable name="rowConstant" select="%(xyceNodeConstantName(row)/[name='nodeConstant']/value)"/>
      <!-- find all the dynamic contributions into flows that impact this
           jacobian row, and collect up all the probes for that
           contribution that involve this column -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="/module/contribution[lhs/nature=lhs/discipline/flow and (lhs/branch/pnode/name='$jacrow' or lhs/branch/nnode/name='$jacrow') ]">
        <admst:if test="[rhs/dynamic = 'yes']">
          <admst:for-each select="rhs/probe[branch/pnode/name = '$jaccol' or branch/nnode/name='$jaccol'and nature=discipline/potential]">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:for-each>
        </admst:if>
      </admst:for-each>
      <!-- now /module/@tempProbes has all the probes that impact this row. -->

      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(row/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(column/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:text format="  (*%(xycedQdXPtrName(.))) += "/>

      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$jaccol]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$jaccol]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_dynamicContributions[$rowConstant][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <admst:text format=";\n"/>
      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>

    </admst:if>
  </admst:for-each>

<!-- Now handle the extra columns of the jacobian for nodes that depend
     on branch variables -->
  <admst:for-each select="$theModule/node[not(nilled(@branchDeps))]">
    <admst:variable name="theNode" select="%(.)"/>
    <admst:for-each select="@branchDeps">
    <admst:variable name="rowConstant" select="%(xyceNodeConstantName($theNode)/[name='nodeConstant']/value)"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%($theNode/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
    <admst:text format="  (*q_%($theNode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr) += "/>
    <admst:text format="d_dynamicContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>
    </admst:for-each>
  </admst:for-each>

<!-- finally, handle the branch equation rows themselves. -->
  <admst:for-each select="$theModule/@extraUnknowns">
    <admst:text format="    // there also need to be extra loads for branch %(.)\n"/>
    <admst:variable name="theBranch" select="%(.)"/>
    <admst:for-each select="@nodeDeps">
      <admst:variable name="theVar" select="%(.)"/>
      <admst:text format="    // Load for branch %($theBranch) equ var %($theVar)\n"/>
      <!-- Find all contributions into POTENTIALS involving this branch, and
          collect up all voltage probes on the RHS that involve this variable.
          -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="$theModule/contribution[lhs/nature=lhs/discipline/potential and (lhs/branch/pnode/name=$theBranch/pnode/name and lhs/branch/nnode/name=$theBranch/nnode/name) and rhs/dynamic='yes']">
        <admst:for-each select="rhs/probe[branch/pnode/name=$theVar/name or branch/nnode/name=$theVar/name]">
          <admst:if test="[nature=discipline/potential]">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:if>
        </admst:for-each>
      </admst:for-each>
      <admst:for-each select="/module/@tempProbes">
        <admst:text format="     // depends on probe %(.)\n"/>
      </admst:for-each>
      <admst:if test="[count(/module/@tempProbes)>0]">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="  (*q_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_%(name)_Node_Ptr) += "/>
      </admst:if>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$theVar/name]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$theVar/name]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_dynamicContributions[%($rowConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <admst:if test="[count(/module/@tempProbes)>0]">
        <admst:text format=";\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:if>
    </admst:for-each>
    <admst:for-each select="@branchDeps">
      <admst:text format="    //load for branch %($theBranch) equ branch %(.) var\n"/>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:text format="  (*q_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr) += d_dynamicContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
    </admst:for-each>
  </admst:for-each>
#else
  //use the offsets instead of pointers

  <admst:for-each select="$theModule/jacobian">
    <admst:if test="[dynamic='yes']">
      <!-- determine which drops this thing depends on, and use the chain rule
           to get the derivative with respect to the desired node -->
      <!-- We do this by stuffing the list of probes into an array in the
           /module path.  I'd rather do it by stuffing the array into the
           jacobian entry itself, but this segfaults ADMS -->
      <admst:variable name="jacrow" select="%(row/name)"/>
      <admst:variable name="jaccol" select="%(column/name)"/>
      <admst:variable name="rowConstant" select="%(xyceNodeConstantName(row)/[name='nodeConstant']/value)"/>
      <!-- find all the dynamic contributions into flows that impact this
           jacobian row, and collect up all the probes for that
           contribution that involve this column -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="/module/contribution[lhs/nature=lhs/discipline/flow and (lhs/branch/pnode/name='$jacrow' or lhs/branch/nnode/name='$jacrow') ]">
        <admst:if test="[rhs/dynamic = 'yes']">
          <admst:for-each select="rhs/probe[branch/pnode/name = '$jaccol' or branch/nnode/name='$jaccol'and nature=discipline/potential]">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:for-each>
        </admst:if>
      </admst:for-each>
      <!-- now /module/@tempProbes has all the probes that impact this row. -->

      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(row/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%(column/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
      <admst:text format="  dQdx[%(xyceNodeLIDVariable(row))][%(xyceJacobianOffsetName(.))] += "/>

      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$jaccol]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$jaccol]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_dynamicContributions[$rowConstant][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <admst:text format=";\n"/>
      <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>
      <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>

    </admst:if>
  </admst:for-each>

<!-- Now handle the extra columns of the jacobian for nodes that depend
     on branch variables -->
  <admst:for-each select="$theModule/node[not(nilled(@branchDeps))]">
    <admst:variable name="theNode" select="%(.)"/>
    <admst:for-each select="@branchDeps">
    <admst:variable name="rowConstant" select="%(xyceNodeConstantName($theNode)/[name='nodeConstant']/value)"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="if (!collapseNode_%($theNode/name))\n"/>
        <admst:text format="{\n"/>
      </admst:if>
    <admst:text format="  dQdx[%(xyceNodeLIDVariable($theNode))][A_%($theNode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset] += "/>
    <admst:text format="d_dynamicContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
      <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
        <admst:text format="}\n"/>
      </admst:if>
    </admst:for-each>
  </admst:for-each>

<!-- finally, handle the branch equation rows themselves. -->
  <admst:for-each select="$theModule/@extraUnknowns">
    <admst:text format="    // there also need to be extra loads for branch %(.)\n"/>
    <admst:variable name="theBranch" select="%(.)"/>
    <admst:for-each select="@nodeDeps">
      <admst:variable name="theVar" select="%(.)"/>
      <admst:text format="    // Load for branch %($theBranch) equ var %($theVar)\n"/>
      <!-- Find all contributions into POTENTIALS involving this branch, and
          collect up all voltage probes on the RHS that involve this variable.
          -->
      <admst:reset select="/module/@tempProbes"/>
      <admst:for-each select="$theModule/contribution[lhs/nature=lhs/discipline/potential and (lhs/branch/pnode/name=$theBranch/pnode/name and lhs/branch/nnode/name=$theBranch/nnode/name) and rhs/dynamic='yes']">
        <admst:for-each select="rhs/probe[branch/pnode/name=$theVar/name or branch/nnode/name=$theVar/name]">
          <admst:if test="[nature=discipline/potential]">
            <admst:push into="/module/@tempProbes" select="." onduplicate="ignore"/>
          </admst:if>
        </admst:for-each>
      </admst:for-each>
      <admst:for-each select="/module/@tempProbes">
        <admst:text format="     // depends on probe %(.)\n"/>
      </admst:for-each>
      <admst:if test="[count(/module/@tempProbes)>0]">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="  dQdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_%(name)_Node_Offset] += "/>
      </admst:if>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:for-each select="/module/@tempProbes">
        <admst:choose>
          <admst:when test="[branch/pnode/name=$theVar/name]">
            <admst:text format=" +"/>
          </admst:when>
          <admst:when test="[branch/nnode/name=$theVar/name]">
            <admst:text format=" -"/>
          </admst:when>
        </admst:choose>
        <admst:text format="d_dynamicContributions[%($rowConstant)][%(xyceProbeConstantName(.)/[name='probeConstant']/value)]"/>
      </admst:for-each>
      <admst:if test="[count(/module/@tempProbes)>0]">
        <admst:text format=";\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:if>
    </admst:for-each>
    <admst:for-each select="@branchDeps">
      <admst:text format="    //load for branch %($theBranch) equ branch %(.) var\n"/>
      <admst:variable name="rowConstant" select="%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value)"/>
      <admst:text format="  dQdx[%(xyceBranchLIDVariable($theBranch))][A_BRA_%($theBranch/pnode/name)_%($theBranch/nnode/name)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset] += d_dynamicContributions[$rowConstant][%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
    </admst:for-each>
  </admst:for-each>

#endif
  return bsuccess;
}


<admst:if test="[count($theModule/callfunction[function/name='\$bound_step'])>0]">
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::getMaxTimeStepSize
// Purpose       : restrict time integrator max time step
// Special Notes : 
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
double Instance::getMaxTimeStepSize()
{
return maxTimeStep_;
}

</admst:if>


<admst:text format="\n\n\n//-----------------------------------------------------------------------------"/>
// Function      : Instance::updateTemperature
// Purpose       : Set temperature and update any parameters that depend on it
// Special Notes : In Xyce ADMS, we'll simply copy the temperature, which is
//                 in Kelvin, to our "admsTemperature" variable, which needs
//                 to be in Celsius.
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Instance::updateTemperature(const double &amp; temperatureTemp)
{

  admsTemperature = temperatureTemp;
  adms_vt_nom = adms_vt(temperatureTemp);

  return true;
}

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="model"/>
// Class Model
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Model::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
bool Model::processParams()
{

  // Set any non-constant parameter defaults:
  // Set any parameters that were not given and whose defaults depend on other
  // parameters:

  <admst:for-each select="variable[(parametertype='model'  or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes']">
    <admst:if test="[exists(default) and exists(#dependent)]">
      <admst:text format="  if (!given(&quot;%(name)&quot;))\n  {\n"/>
      <admst:text format="  %(name) = %(printTerm(default));\n  }\n"/>
    </admst:if>
    <admst:if test="[exists(../attribute[name='xyceModelGroup']) and (../attribute[name='xyceModelGroup']/value='MOSFET' or ../attribute[name='xyceModelGroup']/value='BJT' or ../attribute[name='xyceModelGroup']/value='JFET') and (exists(../attribute[name='xyceTypeVariable']) and ../attribute[name='xyceTypeVariable']/value=name)]">
      <admst:apply-templates match="xyceSetTypeVariable" select=".."/>

    </admst:if>

  </admst:for-each>


  // Now we need to check that any parameters are within their ranges as
  // specified in the verilog:

  <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel'])))and input='yes' and not(nilled(range))]">
//    Parameter %(name) : %(formatted_range(.))

    <admst:apply-templates select="." match="check_range"/>
  </admst:for-each>
  // and of course, this routine is where we should put the initial_model
  // stuff

  <admst:for-each select="analog/code/item/adms[datatypename='block']/..[name='initial_model']">
    <!-- first declare any variables local to the initial_model block -->
    <admst:for-each select="@assignedVars/[scope='local']">
      <admst:text format="  "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <!-- then emit the code -->
    <admst:apply-templates select="." match="block"/>
  </admst:for-each>

  return true;
}
//----------------------------------------------------------------------------
// Function      : Model::processInstanceParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//----------------------------------------------------------------------------
bool Model::processInstanceParams()
{

  std::vector&lt;Instance*&gt;::iterator iter;
  std::vector&lt;Instance*&gt;::iterator first = instanceContainer.begin();
  std::vector&lt;Instance*&gt;::iterator last  = instanceContainer.end();

  for (iter=first; iter!=last; ++iter)
  {
    (*iter)-&gt;processParams();
  }

  return true;
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Model::Model
// Purpose       : model block constructor
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
Model::Model(
  const Configuration &amp; configuration,
  const ModelBlock &amp;    model_block,
  const FactoryBlock &amp;  factory_block)
  : DeviceModel(model_block, configuration.getModelParameters(), factory_block)
<admst:apply-templates select="." match="xyceModelInitializers"/>
{
  // Set params to constant default values (from parTable):
  setDefaultParams();

  // Set params according to .model line and constant defaults from metadata:
  setModParams(model_block.params);

  if (!given("XYCEADMSMODTEMP"))
    admsModTemp=getDeviceOptions().temp.getImmutableValue&lt;double&gt;();

  // Calculate any parameters specified as expressions:

  updateDependentParameters();

  // calculate dependent (ie computed) params and check for errors:
  processParams();
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Model::~Model
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
Model::~Model()
{
  std::vector&lt;Instance*&gt;::iterator iterI;
  std::vector&lt;Instance*&gt;::iterator firstI = instanceContainer.begin ();
  std::vector&lt;Instance*&gt;::iterator lastI  = instanceContainer.end ();

  // loop over instances:
  for (iterI = firstI; iterI != lastI; ++iterI)
  {
    delete (*iterI);
  }
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Model::printOutInstances
// Purpose       : debugging tool.
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
std::ostream &amp;Model::printOutInstances(std::ostream &amp;os) const
{
  std::vector&lt;Instance*&gt;::const_iterator iter;
  std::vector&lt;Instance*&gt;::const_iterator first = instanceContainer.begin();
  std::vector&lt;Instance*&gt;::const_iterator last  = instanceContainer.end();

  int i;
  os &lt;&lt; std::endl;
  os &lt;&lt; "    name     model name  Parameters" &lt;&lt; std::endl;
  for (i=0, iter=first; iter!=last; ++iter, ++i)
  {
    os &lt;&lt; "  " &lt;&lt; i &lt;&lt; ": " &lt;&lt; (*iter)-&gt;getName() &lt;&lt; "      ";
    os &lt;&lt; getName();

    os &lt;&lt; std::endl;
    <admst:for-each select="variable[parametertype='instance' and input='yes']">
      os &lt;&lt; &quot;%(upper-case(name))  =  &quot; &lt;&lt; (*iter)-&gt;%(name) &lt;&lt; std::endl;
    </admst:for-each>
    os &lt;&lt; std::endl;
  }

  os &lt;&lt; std::endl;

  return os;
}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : Model::forEachInstance
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : David Baur
// Creation Date : 2/4/2014
<admst:text format="\n//-----------------------------------------------------------------------------"/>
/// Apply a device instance "op" to all instances associated with this
/// model
///
/// @param[in] op Operator to apply to all instances.
///
///
void Model::forEachInstance(DeviceInstanceOp &amp;op) const
{
  for (std::vector&lt;Instance *&gt;::const_iterator it = instanceContainer.begin(); it != instanceContainer.end(); ++it)
    op(*it);
}


<admst:apply-templates select="$theModule" match="xyceDeviceFactoryandRegisterDevice"/>

<admst:variable name="globalCurrentScope" select="sensitivity"/>
<admst:variable name="globalSensitivityScope" select="instance"/>
#ifdef Xyce_ADMS_SENSITIVITIES
<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : evaluateInitialInstance
// Purpose       : Evaluate the statements in the initial_instance block
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------\n"/>

<admst:text format="void evaluateInitialInstance(\n"/>
<admst:text format="instanceSensStruct &amp; instanceStruct,\n"/>
<admst:text format="modelSensStruct &amp; modelStruct,\n"/>
<admst:if test="[exists(@optnodes)]">
  <admst:join select="node[grounded='no']" separator=",\n">
    <admst:text format="const int "/>
    <admst:text format="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
  </admst:join>
  <admst:text format=",\n const std::vector&lt;bool&gt; &amp; portsConnected_,\n"/>
</admst:if>
<admst:text format=" double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, const Instance &amp; theInstance)\n"/>
<admst:text format="{\n"/>
<admst:for-each select="analog/code/item/adms[datatypename='block']/..[name='initial_instance']">
  <!-- first declare any variables local to the initial_instance block -->
  <admst:for-each select="@assignedVars/[scope='local']">
    <admst:text format="  "/>
    <admst:apply-templates select="." match="collectParamDependence"/>
    <admst:apply-templates select="." match="xyceDeclareVariable"/>
  </admst:for-each>
  <!-- then emit the code -->
  <admst:apply-templates select="." match="block"/>
</admst:for-each>
<admst:text format="}\n\n"/>

<admst:variable name="globalSensitivityScope" select="model"/>

<admst:text format="\n\n//-----------------------------------------------------------------------------"/>
// Function      : evaluateInitialModel
// Purpose       : Evaluate the statements in the initial_model block
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------\n"/>

<admst:text format="void evaluateInitialModel(\n"/>
<admst:text format="modelSensStruct &amp; modelStruct,\n"/>
<admst:text format=" double admsTemperature, double ADMSgmin_arg, const Instance &amp; theInstance)\n"/>
<admst:text format="{\n"/>
<admst:for-each select="analog/code/item/adms[datatypename='block']/..[name='initial_model']">
  <!-- first declare any variables local to the initial_model block -->
  <admst:for-each select="@assignedVars/[scope='local']">
    <admst:text format="  "/>
    <admst:apply-templates select="." match="collectParamDependence"/>
    <admst:apply-templates select="." match="xyceDeclareVariable"/>
  </admst:for-each>
  <!-- then emit the code -->
  <admst:apply-templates select="." match="block"/>
</admst:for-each>
<admst:text format="}\n\n"/>

<admst:variable name="globalSensitivityScope" select="neither"/>

<admst:text format="\n\n//-----------------------------------------------------------------------------"/>
// Function      : evaluateModelEquations
// Purpose       : Evaluate the main module block.  Similar to
//                 updateIntermediateVars, but takes all instance and model
//                 parameters and variables as arguments instead of using
//                 the ones stored in the objects.
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------\n"/>

<admst:text format="void evaluateModelEquations(\n"/>
<admst:variable name="globalDeclareVars" select="yes"/>
<admst:apply-templates select="." match="generateEvaluateModelEquationsArgs"/>
<admst:text format=")\n"/>
<admst:text format="{\n"/>

  <!-- Declare all variables in analog/code that are not of global scope
       or used only in special sub-blocks (initial_model or initial_instance).

       This relies on us having called collectAssignedVariables for the
       top level already.  We did that in the first few lines of this file.

       The only things that need declaring here are the ones with local scope
   -->
  // Local variables

  <admst:for-each select="analog/code/@assignedVars">
    <admst:if test="[scope='local' and block/adms/datatypename='module']">
      <admst:text format="  "/>
      <admst:apply-templates select="." match="collectParamDependence"/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:if>
  </admst:for-each>

  // -- code converted from analog/code block

  <!-- this belongs in a template -->
  <admst:for-each select="analog/code/item">
    <admst:choose>
      <admst:when test="adms[datatypename!='block']">
        <admst:apply-templates select="." match="%(adms/datatypename)"/>
      </admst:when>
      <admst:otherwise>
        <admst:if test="[name!='initial_model' and name !='initial_instance' and name != 'noise']">
          <admst:apply-templates select="." match="block"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
<admst:text format="}\n\n"/>

<admst:text format="\n\n//-----------------------------------------------------------------------------"/>
// Function      : InstanceSensitivity::operator()
// Purpose       : return sensitivity for a single instance parameter
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
/// Compute sensitivity of a device instance&apos;s outputs to a specified instance
/// parameter
///
///
/// @param[in] entity  The device entity that owns the parameter
/// @param[in] name    The unadorned parameter name specific to the entity
/// @param[out] dfdp   The derivative of the F vector with respect to the parameter
/// @param[out] dqdp   The derivative of the Q vector with respect to the parameter
/// @param[out] dbdp   The derivative of the B vector with respect to the parameter
/// @param[out] Findices   The indices into the F vector corresponding to the elements of dfdp
/// @param[out] Qindices   The indices into the Q vector corresponding to the elements of dfdp
/// @param[out] Bindices   The indices into the B vector corresponding to the elements of dfdp
///
///
void InstanceSensitivity::operator()
(
const ParameterBase &amp;entity,
const std::string &amp;name,
std::vector&lt;double&gt; &amp; dfdp,
std::vector&lt;double&gt; &amp; dqdp,
std::vector&lt;double&gt; &amp; dbdp,
std::vector&lt;int&gt; &amp; Findices,
std::vector&lt;int&gt; &amp; Qindices,
std::vector&lt;int&gt; &amp; Bindices
) const
{
const ParameterBase * e1 = &entity;
const Instance &amp; in = *(dynamic_cast&lt;const Instance *&gt; (e1));
const Model &amp; mod =in.model_;

dfdp.resize(%($numSolVars));
dqdp.resize(%($numSolVars));
Findices.resize(%($numSolVars));
Qindices.resize(%($numSolVars));

std::vector &lt;double&gt; probeVars(%(xyceNumberProbes($theModule)));
std::vector &lt;double&gt; d_staticContributions_dX(%($numSolVars));
std::vector &lt;double&gt; d_dynamicContributions_dX(%($numSolVars));


// initialize contributions to zero (automatically sets derivatives to zero)
for (int i=0; i &lt; %($numSolVars) ; ++i)
{
   d_staticContributions_dX[i]=0;
   d_dynamicContributions_dX[i]=0;
}

// Copy out all the model parameters (doubles) into local structure
modelSensStruct modelStruct;

//reals

<admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real']">
  <admst:text format="modelStruct.modelPar_%(name)=mod.%(name);\n"/>
  <admst:text format="modelStruct.d_modelPar_%(name)_dX=0.0;\n"/>
  <admst:text format="modelStruct.modelPar_given_%(name)=mod.given(&quot;%(name)&quot;);\n"/>
</admst:for-each>

// hidden reals

  <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real']">
    <admst:text format="modelStruct.modelPar_%(name)=mod.%(name);\n"/>
    <admst:text format="modelStruct.d_modelPar_%(name)_dX=0.0;\n"/>
  </admst:for-each>

// non-reals (including hiddens)

  <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')]">
    <admst:text format="modelStruct.modelPar_%(name)=mod.%(name);\n"/>
    <admst:if test="[not(exists(attribute[name='hidden']))]">
      <admst:text format="modelStruct.modelPar_given_%(name)=mod.given(&quot;%(name)&quot;);\n"/>
    </admst:if>
  </admst:for-each>


// Copy out all the instance parameters (doubles) into local struct
// Keep a map so we can set the right one to the independent variable
// We do this solely to avoid a big ugly &quot;if/else&quot; block just to find the
// one parameter we&apos;re doing sensitivities on.
unordered_map &lt;std::string,double*,HashNoCase,EqualNoCase&gt; inParamMap;
instanceSensStruct instanceStruct;
// reals

<admst:for-each select="variable[parametertype='instance' and input='yes' and type='real']">
  <admst:text format="instanceStruct.instancePar_%(name)=in.%(name);\n"/>
  <admst:text format="instanceStruct.d_instancePar_%(name)_dX=0.0;\n"/>
  <admst:text format="instanceStruct.instancePar_given_%(name)=in.given(&quot;%(name)&quot;);\n"/>
  <admst:text format="inParamMap[&quot;%(name)&quot;] = &amp;(instanceStruct.d_instancePar_%(name)_dX);\n"/>
</admst:for-each>

// Copy all the real hidden instance params into local struct

<admst:for-each select="variable[parametertype='instance' and (input='no' and exists(attribute[name='hidden'])) and type='real']">
  <admst:text format="instanceStruct.instancePar_%(name)=in.%(name);\n"/>
  <admst:text format="instanceStruct.d_instancePar_%(name)_dX=0.0;\n"/>
</admst:for-each>


// Copy all the non-real instance params into vars of their appropriate type:

<admst:for-each select="variable[parametertype='instance' and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')]">
  <admst:text format="instanceStruct.instancePar_%(name)=in.%(name);\n"/>
  <admst:if test="[not(exists(attribute[name='hidden']))]">
    <admst:text format="instanceStruct.instancePar_given_%(name)=in.given(&quot;%(name)&quot;);\n"/>
  </admst:if>
</admst:for-each>

// Set the one parameter whose name was passed in to be the independent
// variable for differentiation purposes.  Since we stored variable pointers, this
// makes sure that that ONE variable gets set right.
// FIXME: make this check the name first, otherwise segfault on invalid name!
*(inParamMap[name])=1.0;

//make local copies of all instance vars
//reals

<admst:for-each select="variable[scope='global_instance' and input='no' and type='real' and not(insource='no' and output='yes')]">
  <admst:apply-templates select="." match="collectParamDependence"/>
  <admst:text format="instanceStruct.instanceVar_%(name)=in.%(name);\n"/>
  <admst:if test="[exists(#Pdependent)]">
    <!-- Initialize this, but we're gonna clobber it -->
    <admst:text format="instanceStruct.d_instanceVar_%(name)_dX=0.0;\n"/>
  </admst:if>
</admst:for-each>

//non-reals

<admst:for-each select="variable[scope='global_instance' and input='no' and not(type='real')]">
  <admst:text format="instanceStruct.instanceVar_%(name)=in.%(name);\n"/>
</admst:for-each>

//make local copies of all model vars
//reals

<admst:for-each select="variable[scope='global_model' and input='no' and type='real']">
  <admst:apply-templates select="." match="collectParamDependence"/>
  <admst:text format="modelStruct.modelVar_%(name)=mod.%(name);\n"/>
  <admst:if test="[exists(#Pdependent)]">
    <!-- Initialize this, but we're gonna clobber it -->
    <admst:text format="modelStruct.d_modelVar_%(name)_dX=0.0;\n"/>
  </admst:if>
</admst:for-each>

// non-reals

<admst:for-each select="variable[scope='global_model' and input='no' and not(type='real')]">
  <admst:text format="modelStruct.modelVar_%(name)=mod.%(name);\n"/>
</admst:for-each>


Linear::Vector * solVectorPtr = in.extData.nextSolVectorPtr;

// extract solution variables

<admst:for-each select="probe">
  <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
  <admst:choose>
    <admst:when test="[nature=discipline/potential]">
      <admst:choose>
        <admst:when test="branch/nnode[grounded='yes']">
            <admst:choose>
              <admst:when test="[exists(branch/pnode/#collapsible) and (branch/pnode/@collapsesTo/name='GND')]">
                <admst:text format="probeVars[in.%($probeConstantName)] = (in.collapseNode_%(branch/pnode/name))?(0):((*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))]);\n"/>
              </admst:when>
              <admst:otherwise>
                <admst:text format="probeVars[in.%($probeConstantName)] = (*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))];\n"/>
              </admst:otherwise>
            </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:text format="probeVars[in.%($probeConstantName)] = "/>
          <admst:choose>
            <admst:when test="[exists(branch/pnode/#collapsible) and (branch/pnode/@collapsesTo/name='GND')]">
              <admst:text format="(in.collapseNode_%(branch/pnode/name))?(0):((*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))])"/>
            </admst:when>
            <admst:otherwise>
              <admst:text format="(*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))]"/>
            </admst:otherwise>
          </admst:choose>
          <admst:choose>
            <admst:when test="[exists(branch/nnode/#collapsible) and (branch/nnode/@collapsesTo/name='GND')]">
              <admst:text format=" - ((in.collapseNode_%(branch/nnode/name))?(0):((*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/nnode))]))"/>
            </admst:when>
            <admst:otherwise>
              <admst:text format="- (*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/nnode))]"/>
            </admst:otherwise>
          </admst:choose>
          <admst:text format=";\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[nature=discipline/flow]">
      probeVars[in.%($probeConstantName)] = (*solVectorPtr)[in.%(xyceBranchLIDVariable(branch))];
    </admst:when>
  </admst:choose>
</admst:for-each>
  <!-- do the assignments of probes that weren't caught by ADMS, because
       they're implicit in the use of voltage sources -->
  <admst:for-each select="@extraProbeBranches">
    <admst:variable name="probeConstantName" select="%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)"/>
    probeVars[in.%($probeConstantName)] = (*solVectorPtr)[in.%(xyceBranchLIDVariable(.))];
  </admst:for-each>


  <admst:if test="[(count(@limitedProbes)>0) and exists(@limiters/rhs/[probe/#typed='yes'])]">

    // pre-multiply any "typed" probes (i.e. those limited with "typedpnjlim")

    <admst:variable name="globalMustForceScalar" select="yes"/>
    <admst:for-each select="@limiters/rhs/[probe/#typed='yes']">
      <admst:if test="[count(function[name='\$limit']/arguments)>2]">
        <admst:choose>
          <admst:when test="[function/[name='\$limit']/arguments[3]/datatypename='string']">
            <admst:if test="[function/[name='\$limit']/arguments[3]/value='typed']">
              <admst:apply-templates select="function/[name='\$limit']/arguments[4]" match="collectParamDependence"/>
              probeVars[in.%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[4]));
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="function/[name='\$limit']/arguments[5]" match="collectParamDependence"/>
            probeVars[in.%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[5]));
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:for-each>
  </admst:if>
  <admst:variable name="globalMustForceScalar" select="no"/>

  <admst:text format="\n\n"/>

<admst:if test="[exists(analog/code/item/adms[datatypename='block']/..[name='initial_model'])]">
  // Need to use processParams-like function to process the
  // initial_model and initial_instance blocks with the LOCAL copies of
  // instance and model vars, and local copies of instance and model
  // params.

<admst:text format="evaluateInitialModel(\n"/>
<admst:text format="modelStruct,\n"/>
<admst:text format=" mod.admsModTemp,in.getDeviceOptions().gmin,in);\n"/>
</admst:if>

<admst:if test="[exists(analog/code/item/adms[datatypename='block']/..[name='initial_instance'])]">
  <admst:text format="evaluateInitialInstance(\n"/>
  <admst:text format="instanceStruct,\n"/>
  <admst:text format="modelStruct,\n"/>
  <admst:if test="[exists(@optnodes)]">
    <admst:join select="node[grounded='no']" separator=",\n">
      <admst:text format="in.%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    </admst:join>
    <admst:text format=",\n in.portsConnected_,\n"/>
  </admst:if>
  <admst:text format="in.admsTemperature,in.adms_vt_nom,in.getDeviceOptions().gmin,in);\n"/>
</admst:if>

// Now call  the function that does the heavy lifting.
evaluateModelEquations(
probeVars,
// probe constants

<admst:if test="[count(probe)>0]">
  <admst:join select="probe" separator=",\n">
    <admst:text format="in.%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
  </admst:join>
  <admst:text format=",\n"/>
</admst:if>
<admst:if test="[count(@extraProbeBranches)>0]">
  <admst:join select="@extraProbeBranches" separator=",\n">
    <admst:text format="in.%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)"/>
  </admst:join>
  <admst:text format=",\n"/>
</admst:if>
// node constants

<admst:join select="node[grounded='no']" separator=",\n">
  <admst:text format="in.%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
</admst:join>
<admst:if test="[count(@extraUnknowns)>0]">
  <admst:text format=",\n"/>
  <admst:join select="@extraUnknowns" separator=",\n">
    <admst:text format="in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
  </admst:join>
</admst:if>
<admst:variable name="globalDeclareVars" select="no"/>
<admst:apply-templates select="." match="generateEvaluateModelEquationsArgs"/>
<admst:if test="[exists(@optnodes)]">
  <admst:text format="in.portsConnected_,\n"/>
</admst:if>
<admst:text format=" in.admsTemperature,\n in.adms_vt_nom,\n in.getDeviceOptions().gmin,\n d_staticContributions_dX,\n d_dynamicContributions_dX,\n in);\n"/>

// We now have the F and Q vector stuff, populate the dependencies:

<admst:for-each select="node[grounded='no']">
  <admst:variable name="nodeConstantName" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    dfdp[in.$nodeConstantName] += d_staticContributions_dX[in.$nodeConstantName];
    dqdp[in.$nodeConstantName] += d_dynamicContributions_dX[in.$nodeConstantName];
    Findices[in.$nodeConstantName] = in.%(xyceNodeLIDVariable(.));
    Qindices[in.$nodeConstantName] = in.%(xyceNodeLIDVariable(.));
</admst:for-each>

<!-- now handle branch equations -->
<admst:for-each select="$theModule/@extraUnknowns">
  dfdp[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)] += d_staticContributions_dX[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)];
  dqdp[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)] += d_dynamicContributions_dX[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)];
  Findices[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)] = in.%(xyceBranchLIDVariable(.));
  Qindices[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)] = in.%(xyceBranchLIDVariable(.));
  </admst:for-each>


}

<admst:text format="\n//-----------------------------------------------------------------------------"/>
// Function      : ModelSensitivity::operator()
// Purpose       : return sensitivity for a single model parameter
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
<admst:text format="\n//-----------------------------------------------------------------------------"/>
/// Compute sensitivity to a specified model
/// parameter of all device instances of that model's outputs
///
///
/// @param[in] entity  The device entity that owns the parameter
/// @param[in] name    The unadorned parameter name specific to the entity
/// @param[out] dfdp   The derivative of the F vector with respect to the parameter
/// @param[out] dqdp   The derivative of the Q vector with respect to the parameter
/// @param[out] dbdp   The derivative of the B vector with respect to the parameter
/// @param[out] Findices   The indices into the F vector corresponding to the elements of dfdp
/// @param[out] Qindices   The indices into the Q vector corresponding to the elements of dfdp
/// @param[out] Bindices   The indices into the B vector corresponding to the elements of dfdp
///
///
void ModelSensitivity::operator()
(
const ParameterBase &amp;entity,
const std::string &amp;name,
std::vector&lt;double&gt; &amp; dfdp,
std::vector&lt;double&gt; &amp; dqdp,
std::vector&lt;double&gt; &amp; dbdp,
std::vector&lt;int&gt; &amp; Findices,
std::vector&lt;int&gt; &amp; Qindices,
std::vector&lt;int&gt; &amp; Bindices
) const
{
const ParameterBase * e1 = &entity;
const Model &amp; mod = *(dynamic_cast&lt;const Model *&gt; (e1));
int sizeInstance = mod.instanceContainer.size();

dfdp.resize((%($numSolVars))*sizeInstance);
dqdp.resize((%($numSolVars))*sizeInstance);
Findices.resize((%($numSolVars))*sizeInstance);
Qindices.resize((%($numSolVars))*sizeInstance);

std::vector &lt;double&gt; probeVars(%(xyceNumberProbes($theModule)));
std::vector &lt;double&gt; d_staticContributions_dX(%($numSolVars));
std::vector &lt;double&gt; d_dynamicContributions_dX(%($numSolVars));


// Copy out all the model parameters (doubles) into local structure
modelSensStruct modelStruct;

// Keep a map so we can set the right one to the independent variable
// We do this solely to avoid a big ugly "if/else" block just to find the
// one parameter we're doing sensitivities on.
unordered_map &lt;std::string,double*,HashNoCase,EqualNoCase&gt; modParamMap;

// reals

<admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real']">
  <admst:text format="modelStruct.modelPar_%(name)=mod.%(name);\n"/>
  <admst:text format="modelStruct.d_modelPar_%(name)_dX=0.0;\n"/>
  <admst:text format="modelStruct.modelPar_given_%(name)=mod.given(&quot;%(name)&quot;);\n"/>
  <admst:text format="modParamMap[&quot;%(name)&quot;] = &amp;(modelStruct.d_modelPar_%(name)_dX);\n"/>
</admst:for-each>

// hidden reals

<admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real']">
  <admst:text format="modelStruct.modelPar_%(name)=mod.%(name);\n"/>
  <admst:text format="modelStruct.d_modelPar_%(name)_dX=0.0;\n"/>
</admst:for-each>

// non-reals (including hiddens)

<admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')]">
  <admst:text format="modelStruct.modelPar_%(name)=mod.%(name);\n"/>
  <admst:if test="[not(exists(attribute[name='hidden']))]">
    <admst:text format="modelStruct.modelPar_given_%(name)=mod.given(&quot;%(name)&quot;);\n"/>
  </admst:if>
</admst:for-each>

// Set the one parameter whose name was passed in to be the independent
// variable for differentiation purposes.  Since we stored variable pointers, this
// makes sure that that ONE variable gets set right.
// FIXME: make this check name for presence first!  Segfault on invalid.
*(modParamMap[name])=1.0;

//make local copies of all model vars
//reals

<admst:for-each select="variable[scope='global_model' and input='no' and type='real']">
  <admst:apply-templates select="." match="collectParamDependence"/>
  <admst:text format="modelStruct.modelVar_%(name)=mod.%(name);\n"/>
  <admst:if test="[exists(#Pdependent)]">
    <!-- Initialize this, but we're gonna clobber it -->
    <admst:text format="modelStruct.d_modelVar_%(name)_dX=0.0;\n"/>
  </admst:if>
</admst:for-each>

// non-reals

<admst:for-each select="variable[scope='global_model' and input='no' and not(type='real')]">
  <admst:text format="modelStruct.modelVar_%(name)=mod.%(name);\n"/>
</admst:for-each>


// Now loop over all instances and do the deed
int inst=0;
for (std::vector&lt;Instance*&gt;::const_iterator in_it=mod.instanceContainer.begin(); in_it != mod.instanceContainer.end(); ++in_it,++inst)
{

  Instance &amp; in=*(*in_it);
  // initialize contributions to zero (automatically sets derivatives to zero)
  for (int i=0; i &lt; %($numSolVars) ; ++i)
  {
  d_staticContributions_dX[i]=0;
  d_dynamicContributions_dX[i]=0;
  }



  // Copy out all the instance parameters (doubles) into local struct
 instanceSensStruct instanceStruct;

 // reals

  <admst:for-each select="variable[parametertype='instance' and input='yes' and type='real']">
    <admst:text format="instanceStruct.instancePar_%(name)=in.%(name);\n"/>
    <admst:text format="instanceStruct.d_instancePar_%(name)_dX=0.0;\n"/>
    <admst:text format="instanceStruct.instancePar_given_%(name)=in.given(&quot;%(name)&quot;);\n"/>
  </admst:for-each>

  // real hidden instance

  <admst:for-each select="variable[parametertype='instance' and (input='no' and exists(attribute[name='hidden'])) and type='real']">
    <admst:text format="instanceStruct.instancePar_%(name)X=in.%(name);\n"/>
    <admst:text format="instanceStruct.d_instancePar_%(name)_dX=0.0;\n"/>
  </admst:for-each>

  // Copy all the non-real instance params into vars of their appropriate type:

  <admst:for-each select="variable[parametertype='instance' and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')]">
    <admst:text format="instanceStruct.instancePar_%(name)=in.%(name);\n"/>
    <admst:if test="[not(exists(attribute[name='hidden']))]">
      <admst:text format="instanceStruct.instancePar_given_%(name)=in.given(&quot;%(name)&quot;);\n"/>
    </admst:if>
  </admst:for-each>



  // If there are any instance parameters that were not given, and have
  // corresponding model params, copy the model param into the instance.
  // This was already done by the instance constructor, but we do it again
  // because now we're propagating derivatives, and the user could be trying
  // to get sensitivity to the model parameter.

  <admst:for-each select="variable[parametertype='instance' and exists(attribute[name='xyceAlsoModel']) and input='yes']">
    <admst:text format="   if (!(in.given(&quot;%(name)&quot;)))\n"/>
    <admst:text format="   {\n"/>
    <admst:text format="      instanceStruct.instancePar_%(name) = modelStruct.modelPar_%(name);\n"/>
    <admst:if test="[type='real']">
      <admst:text format="      instanceStruct.d_instancePar_%(name)_dX = modelStruct.d_modelPar_%(name)_dX;\n"/>
    </admst:if>
    <admst:text format="   }\n"/>
  </admst:for-each>

  //make local copies of all instance vars
  //reals

  <admst:for-each select="variable[scope='global_instance' and input='no' and type='real' and not(insource='no' and output='yes')]">
    <admst:apply-templates select="." match="collectParamDependence"/>
    <admst:text format="instanceStruct.instanceVar_%(name)=in.%(name);\n"/>
    <admst:if test="[exists(#Pdependent)]">
      <!-- this will wind up being set properly either in the evaluateInitialInstance
           or evaluateModelEquations calls -->
      <admst:text format="instanceStruct.d_instanceVar_%(name)_dX=0.0;\n"/>
    </admst:if>
  </admst:for-each>

  //non-reals

  <admst:for-each select="variable[scope='global_instance' and input='no' and not(type='real')]">
    <admst:text format="instanceStruct.instanceVar_%(name)=in.%(name);\n"/>
  </admst:for-each>


  Linear::Vector * solVectorPtr = in.extData.nextSolVectorPtr;

  // extract solution variables

  <admst:for-each select="probe">
    <admst:variable name="probeConstantName" select="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
    <admst:choose>
      <admst:when test="[nature=discipline/potential]">
        <admst:choose>
          <admst:when test="branch/nnode[grounded='yes']">
            <admst:choose>
              <admst:when test="[exists(branch/pnode/#collapsible) and (branch/pnode/@collapsesTo/name='GND')]">
                <admst:text format="probeVars[in.%($probeConstantName)] = (in.collapseNode_%(branch/pnode/name))?(0):((*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))]);\n"/>
              </admst:when>
              <admst:otherwise>
                <admst:text format="probeVars[in.%($probeConstantName)] = (*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))];\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:text format="probeVars[in.%($probeConstantName)] = "/>
            <admst:choose>
              <admst:when test="[exists(branch/pnode/#collapsible) and (branch/pnode/@collapsesTo/name='GND')]">
                <admst:text format="(in.collapseNode_%(branch/pnode/name))?(0):((*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))])"/>
              </admst:when>
              <admst:otherwise>
                <admst:text format="(*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/pnode))]"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[exists(branch/nnode/#collapsible) and (branch/nnode/@collapsesTo/name='GND')]">
                <admst:text format=" - ((in.collapseNode_%(branch/nnode/name))?(0):((*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/nnode))]))"/>
              </admst:when>
              <admst:otherwise>
                <admst:text format=" - (*solVectorPtr)[in.%(xyceNodeLIDVariable(branch/nnode))]"/>
              </admst:otherwise>
            </admst:choose>
            <admst:text format=";\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[nature=discipline/flow]">
        <admst:text format="probeVars[in.%($probeConstantName)] = (*solVectorPtr)[in.%(xyceBranchLIDVariable(branch))];\n"/>
      </admst:when>
    </admst:choose>
  </admst:for-each>
  <!-- do the assignments of probes that weren't caught by ADMS, because
       they're implicit in the use of voltage sources -->
  <admst:for-each select="@extraProbeBranches">
    <admst:variable name="probeConstantName" select="%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)"/>
    <admst:text format="probeVars[in.%($probeConstantName)] = (*solVectorPtr)[in.%(xyceBranchLIDVariable(.))];\n"/>
  </admst:for-each>


  <admst:if test="[(count(@limitedProbes)>0) and exists(@limiters/rhs/[probe/#typed='yes'])]">

    // pre-multiply any "typed" probes (i.e. those limited with "typedpnjlim")

    <admst:variable name="globalMustForceScalar" select="yes"/>
    <admst:for-each select="@limiters/rhs/[probe/#typed='yes']">
      <admst:if test="[count(function[name='\$limit']/arguments)>2]">
        <admst:choose>
          <admst:when test="[function/[name='\$limit']/arguments[3]/datatypename='string']">
            <admst:if test="[function/[name='\$limit']/arguments[3]/value='typed']">
              <admst:apply-templates select="function/[name='\$limit']/arguments[4]" match="collectParamDependence"/>
              <admst:text format="probeVars[in.%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[4]));\n"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="function/[name='\$limit']/arguments[5]" match="collectParamDependence"/>
            <admst:text format="probeVars[in.%(xyceProbeConstantName(probe)/[name='probeConstant']/value)] *= %(printTerm(function/[name='\$limit']/arguments[5]));\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:for-each>
  </admst:if>
  <admst:variable name="globalMustForceScalar" select="no"/>

  <admst:text format="\n\n"/>

  <admst:if test="[exists(analog/code/item/adms[datatypename='block']/..[name='initial_model'])]">
    // Need to use processParams-like function to process the
    // initial_model block with the LOCAL copies of
    //  model vars, and local copies of model
    // params.

    <admst:text format="evaluateInitialModel(\n"/>
    <admst:text format="modelStruct,\n"/>
    <admst:text format=" mod.admsModTemp,in.getDeviceOptions().gmin,in);\n"/>
  </admst:if>

  <admst:if test="[exists(analog/code/item/adms[datatypename='block']/..[name='initial_instance'])]">
    <admst:text format="evaluateInitialInstance(\n"/>
    <admst:text format="instanceStruct,\n"/>
    <admst:text format="modelStruct,\n"/>
    <admst:if test="[exists(@optnodes)]">
      <admst:join select="node[grounded='no']" separator=",\n">
        <admst:text format="in.%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
      </admst:join>
      <admst:text format=",\n in.portsConnected_,\n"/>
    </admst:if>
    <admst:text format="in.admsTemperature, in.adms_vt_nom,in.getDeviceOptions().gmin,in);\n"/>
  </admst:if>

// Now call  the function that does the heavy lifting.

evaluateModelEquations(
probeVars,
// probe constants

<admst:if test="[count(probe)>0]">
  <admst:join select="probe" separator=",\n">
    <admst:text format="in.%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
  </admst:join>
  <admst:text format=",\n"/>
</admst:if>
<admst:if test="[count(@extraProbeBranches)>0]">
  <admst:join select="@extraProbeBranches" separator=",\n">
    <admst:text format="in.%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)"/>
  </admst:join>
  <admst:text format=",\n"/>
</admst:if>
// node constants

<admst:join select="node[grounded='no']" separator=",\n">
  <admst:text format="in.%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
</admst:join>
<admst:if test="[count(@extraUnknowns)>0]">
  <admst:text format=",\n"/>
  <admst:join select="@extraUnknowns" separator=",\n">
    <admst:text format="in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
  </admst:join>
</admst:if>
<admst:variable name="globalDeclareVars" select="no"/>
<admst:apply-templates select="." match="generateEvaluateModelEquationsArgs"/>
<admst:if test="[exists(@optnodes)]">
  <admst:text format=" in.portsConnected_,\n"/>
</admst:if>
<admst:text format=" in.admsTemperature,\n in.adms_vt_nom,\n in.getDeviceOptions().gmin,\n d_staticContributions_dX,\n d_dynamicContributions_dX,\n in);\n"/>

  // We now have the F and Q vector stuff, populate the dependencies:

  <admst:for-each select="node[grounded='no']">
    <admst:variable name="nodeConstantName" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
    dfdp[in.$nodeConstantName+inst*(%($numSolVars))] += d_staticContributions_dX[in.$nodeConstantName];
    dqdp[in.$nodeConstantName+inst*(%($numSolVars))] += d_dynamicContributions_dX[in.$nodeConstantName];
    Findices[in.$nodeConstantName+inst*(%($numSolVars))] = in.%(xyceNodeLIDVariable(.));
    Qindices[in.$nodeConstantName+inst*(%($numSolVars))] = in.%(xyceNodeLIDVariable(.));
  </admst:for-each>

  <!-- now handle branch equations -->
  <admst:for-each select="$theModule/@extraUnknowns">
    dfdp[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)+inst*(%($numSolVars))] += d_staticContributions_dX[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)];
    dqdp[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)+inst*(%($numSolVars))] += d_dynamicContributions_dX[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)];
    Findices[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)+inst*(%($numSolVars))] = in.%(xyceBranchLIDVariable(.));
    Qindices[in.%(xyceBranchConstantName(.)/[name='branchConstant']/value)+inst*(%($numSolVars))] = in.%(xyceBranchLIDVariable(.));
  </admst:for-each>
}

}

#endif // Xyce_ADMS_SENSITIVITIES
<admst:variable name="skipFunctionPrecomp" select="y"/>

} // namespace %($nameSpace)
} // namespace Device
} // namespace Xyce

    </admst:open>
  </admst:for-each>
</admst>
